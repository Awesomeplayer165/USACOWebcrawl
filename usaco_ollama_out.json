{"https://usaco.org/index.php?page=viewproblem2&cpid=84": {"code": "```\npython\nstart_date = \"11/11/2011\"\nstart_time = \"11:11 AM\"\n\nend_date, end_hour, end_minute = map(int, input().split())\n\n# convert start and end times to minutes from midnight\nstart_minutes = (int(start_date.split(\"/\")[0]) * 60 + int(start_date.split(\"/\")[1])) * 24 + int(start_time[:2]) * 60 + int(start_time[3:5])\n\nend_minutes = (12 * 60) + 13 * 60 + int(end_minute)\ntotal_minutes = end_minutes - start_minutes\n\nif total_minutes < 0:\n    print(-1)\nelse:\n    print(total_minutes)\n```", "time_gen": "\ntime generating: 3.946495s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=85": {"code": "```\nfrom collections import defaultdict\n\ndef convert_base(num, base):\n    convert_string = \"0123456789ABC\"\n    if num < base:\n        return convert_string[num]\n    else:\n        return convert_base(num//base, base) + convert_string[num%base]\n\ndef solve():\n    b2, b3 = input().strip(), input().strip()\n    \n    # Find incorrect digits in both bases\n    for i in range(1, len(b2)):\n        if b2[i] != '0' and b2[i-1] == '0':\n            b2i = int(b2, 2)\n            b3i = int(b3, 3)\n            b2n = convert_base(b2i^b3i, 10).lstrip('0')\n            if len(b2n) > 0:\n                return str(int(b2n, 10))\n\n# Run the solver\nprint(solve())\n```", "time_gen": "\ntime generating: 5.13914s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=86": {"code": "```\nimport re\n\nn = int(input())\nnotes = list(map(int, input().split()))\nc = int(input())\nchord = list(map(int, input().split()))\n\npattern = r'\\b' + '|'.join(map(str, chord)) + r'\\b'\nmatch_count = 0\nstart_index = []\n\nfor i in range(len(notes)):\n    if re.fullmatch(pattern, ','.join(map(str, notes[i:i+c]))):\n        match_count += 1\n        start_index.append(i+1)\n\nprint(match_count)\nfor index in sorted(start_index):\n    print(index)", "time_gen": "\ntime generating: 5.135306s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=87": {"code": "Here is the Python code for Problem 4: Cow Beauty Pageant (Bronze Level):\n```\nn, m = map(int, input().split())\nspots = []\nfor _ in range(n):\n    spots.append(list(input()))\n\ndef dfs(i, j):\n    if i < 0 or i >= n or j < 0 or j >= m:\n        return\n    if spots[i][j] == '.':\n        return\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    for direction in directions:\n        new_i, new_j = i + direction[0], j + direction[1]\n        if 0 <= new_i < n and 0 <= new_j < m and spots[new_i][new_j] == 'X':\n            dfs(new_i, new_j)\n\nmin_paints = float('inf')\nfor i in range(n):\n    for j in range(m):\n        if spots[i][j] == 'X':\n            dfs(i, j)\n            paints = 0\n            for k in range(n):\n                for l in range(m):\n                    if spots[k][l] == '.':\n                        paints += 1\n            min_paints = min(min_paints, paints)\n\nprint(min_paints)\n```\nNote: This code uses depth-first search (DFS) to find all the connected 'X' characters and then calculates the minimum number of new 'X' characters needed to merge the two spots into one.", "time_gen": "\ntime generating: 9.51874s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=88": {"code": "Here is the Python solution for the problem:\n```\ndef merge_spots(N, M, grid):\n    # Initialize variables\n    total = 0\n    stack = []\n    \n    # Iterate over each row of the grid\n    for i in range(N):\n        # Add '.' characters to the stack if they are not part of a spot\n        for j in range(M-1):\n            if grid[i][j] == '.' and grid[i][j+1] == '.':\n                stack.append('.')\n        \n        # Check if there is no spot on this row or the current spot ends here\n        if len(stack) % 2 == 0:\n            continue\n        \n        # If there are odd number of spots, it means we have at least one full spot\n        total += len(stack)\n    \n    return total\n\nN, M = map(int, input().split())\ngrid = [input() for _ in range(N)]\nprint(merge_spots(N, M, grid))\n```\nThis code defines a function `merge_spots` that takes the dimensions of the grid and the grid itself as input. It then iterates over each row of the grid, keeping track of non-spot characters (`'.'`) on a stack. When it encounters a spot (i.e., an odd number of characters), it adds the size of the current spot to the total count. Finally, it returns the minimum number of new `'X'`s that must be added to merge three spots into one.", "time_gen": "\ntime generating: 9.551829s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=89": {"code": "Here is the Python solution for the problem:\n```\nn = int(input())\ncows = []\nfor _ in range(n):\n    x, breed = map(int, input().split())\n    cows.append((x, breed))\n\ncow_breeds = set()\nmin_cost = float('inf')\nleft = 0\nright = 0\n\nwhile right < n:\n    while left <= right and cow_breeds & set([cow[1] for cow in cows[left:right+1]]) != set():\n        left += 1\n    if left > right:\n        break\n    min_cost = min(min_cost, right - left + 1)\n    right += 1\n\nprint(min_cost)\n```", "time_gen": "\ntime generating: 5.115627s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=90": {"code": "Here is a Python solution for the problem:\n```markdown\n```\n```python\nn, m = map(int, input().split())\nareas = list(map(int, input().split()))\ncosts = [0] * (n + 1)\nfor i in range(1, n + 1):\n    costs[i] = costs[i - 1] + areas[i - 1]\nres = float('inf')\nleft = 0\nright = m\nwhile left <= right:\n    mid = (left + right) // 2\n    if costs[n] - costs[0] > mid:\n        res = min(res, costs[n] - costs[0] - mid)\n        right = mid - 1\n    else:\n        left = mid + 1\nif m <= costs[0]:\n    print(-1)\nelse:\n    print(res)\n```", "time_gen": "\ntime generating: 6.371908s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=91": {"code": "Here is the Python solution for this problem:\n```\nn, x = map(int, input().split())\nheights = [int(input()) for _ in range(n)]\n\ndef count_subsequences(heights):\n    n = len(heights)\n    left = 0\n    right = 0\n    count = 0\n    total = sum(1 for height in heights if height >= x)\n    \n    while right < n:\n        if heights[right] >= x:\n            total += 1\n        while total > (right - left + 1) // 2 and left <= right:\n            if heights[left] < x:\n                total -= 1\n            left += 1\n        \n        count += right - left + 1\n        right += 1\n    \n    return count\n\nprint(count_subsequences(heights))\n```", "time_gen": "\ntime generating: 6.043829s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=92": {"code": "```\nimport re\n\ndef count_toggles(board):\n    rows = [list(map(int, row)) for row in board]\n    cols = [[row[i] for row in rows] for i in range(9)]\n    subs = [[rows[i//3*3 + j//3][i%3*3+j%3] for j in range(9)] for i in range(81)]\n\n    toggle_rows = []\n    toggle_cols = []\n    toggle_subs = []\n\n    # toggle rows\n    for row in rows:\n        ones = sum(row)\n        if ones % 2 != 0:\n            toggle_rows.append(list(map(lambda x: int(not x), row)))\n\n    # toggle cols\n    for col in cols:\n        ones = sum(col)\n        if ones % 2 != 0:\n            idx = [i for i, row in enumerate(rows) if row == col][0]\n            rows[idx] = list(map(lambda x: int(not x), col))\n\n    # toggle subs\n    for sub in subs:\n        ones = sum(sub)\n        if ones % 2 != 0:\n            for i, row in enumerate(sub):\n                for j, val in enumerate(row):\n                    if val == 1:\n                        rows[i//3*3 + j//3][i%3*3+j%3] = int(not val)\n\n    total_toggles = len(toggle_rows) + len(toggle_cols) + len(toggle_subs)\n    return str(total_toggles)\n\n\nboard = []\nfor _ in range(9):\n    board.append(re.sub('(.{3})', r'\\1 ', input().strip()).split())\n\nprint(count_toggles(board))\n```", "time_gen": "\ntime generating: 10.148525s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=93": {"code": "```\npython\nimport math\n\ndef max_segments():\n    N = int(input())\n    obstacles = []\n    for _ in range(N):\n        x1, y1, x2, y2 = map(int, input().split())\n        if x1 == x2:\n            orientation = 'v'\n            start, end = min(y1, y2), max(y1, y2)\n        else:\n            orientation = 'h'\n            start, end = min(x1, x2), max(x1, x2)\n\n        obstacles.append((orientation, start, end))\n\n    events = []\n    for obstacle in obstacles:\n        if obstacle[0] == 'v':\n            events.append((obstacle[1], 'start'))\n            events.append((obstacle[2], 'end'))\n        else:\n            events.append((obstacle[1], 'start'))\n            events.append((obstacle[2], 'end'))\n\n    events.sort()\n\n    active = 0\n    max_segments = 0\n\n    for event in events:\n        if event[1] == 'start':\n            active += 1\n        else:\n            active -= 1\n        max_segments = max(max_segments, active)\n\n    print(max_segments)\n\n\nif __name__ == '__main__':\n    max_segments()\n```", "time_gen": "\ntime generating: 9.126774s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=94": {"code": "```\n```python\nn = int(input())\ntotal = sum(int(input()) for _ in range(n))\ndiff = total // n\nextra = total % n\n\nmoves = 0\nfor i in range(n):\n    moves += abs(int(input()) - diff)\nif extra > 0:\n    moves += extra\nprint(moves)\n```", "time_gen": "\ntime generating: 3.081702s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=95": {"code": "```\nn = int(input())\nphotos = []\nfor i in range(5):\n    photo = [int(x) for x in input().split()]\n    photos.append(photo)\n\nlast_photo = photos[-1]\noriginal_order = [0] * (n+1)\nfor i in range(n):\n    original_order[last_photo[i]] = i + 1\n\nprint(\"\\n\".join(map(str, original_order[1:])))\n```", "time_gen": "\ntime generating: 4.731848s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=96": {"code": "```\nimport heapq\n\nN = int(input())\nweights = []\nfor _ in range(N):\n    weights.append(int(input()))\n\nheap = []\nfor weight in weights:\n    if len(heap) > 0 and heap[0] + weight <= 10000000: \n        heapq.heappush(heap, weight)\n    else:\n        while len(heap) > 1 and (heap[0] + weight > 10000000 or heap[0] + heap[1] > 10000000):\n            heapq.heappop(heap)\n        heapq.heappush(heap, weight)\n\nprint(len(heap))\n```", "time_gen": "\ntime generating: 4.903615s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=97": {"code": "```\ndef photo():\n    n = int(input())\n    photos = []\n    for _ in range(5):\n        cows = [int(x) for x in input().split()]\n        photos.append(cows)\n        \n    for i in range(len(photos[0])):\n        cows = [x[i] for x in photos]\n        if len(set(cows)) == 1:\n            print(cows[0])\n            return\n```", "time_gen": "\ntime generating: 4.764567s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=98": {"code": "```\nfrom heapq import *\nfrom collections import defaultdict\n\nN, M = map(int, input().split())\ngraph = defaultdict(dict)\nfor _ in range(M):\n    A, B, L = map(int, input().split())\n    graph[A][B] = L\n    graph[B][A] = L\n\nINF = float('inf')\ndp = [INF] * (N + 1)\ndp[0] = 0\nqueue = [(0, 0)]\nwhile queue:\n    dist, node = heappop(queue)\n    if dist > dp[node]:\n        continue\n    for neighbor, length in graph[node].items():\n        new_dist = dp[node] + length\n        if new_dist < dp[neighbor]:\n            dp[neighbor] = new_dist\n            heappush(queue, (new_dist, neighbor))\n\nans = INF\nfor i in range(1, N):\n    ans = min(ans, dp[i])\n\nprint(max(0, dp[N - 1] - ans))\n```", "time_gen": "\ntime generating: 7.712682s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=99": {"code": "```\n```\n\n```\n```", "time_gen": "\ntime generating: 2.117871s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=100": {"code": "```\nimport sys\n\nn = int(sys.stdin.readline())\nfor _ in range(5):\n    photo = [int(line) for line in sys.stdin.readlines(n)]\n    sys.stdin.seek(0)\n    if i == 0:\n        ordering = photo\n    else:\n        for j in range(len(ordering)):\n            if ordering[j] != photo[0]:\n                ordering.insert(0, ordering.pop(j))\n                break\n\nprint(*ordering, sep='\\n')\n```", "time_gen": "\ntime generating: 5.166681s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=101": {"code": "```\nimport heapq\nfrom collections import defaultdict\n\nN, M = map(int, input().split())\nedges = []\nfor _ in range(M):\n    a, b, n = map(int, input().split())\n    edges.append((n, a, b))\n\ngraph = defaultdict(list)\nfor edge in edges:\n    _, a, b = edge\n    graph[a].append(b)\n    graph[b].append(a)\n\nheap = []\nfor node in range(1, N+1):\n    if len(graph[node]) > 0:\n        for neighbor in graph[node]:\n            heapq.heappush(heap, (1, node, neighbor))\n\nparent = [i for i in range(N+1)]\nrank = [0] * (N+1)\n\ndef find(node):\n    if parent[node] != node:\n        parent[node] = find(parent[node])\n    return parent[node]\n\ndef union(a, b):\n    root_a = find(a)\n    root_b = find(b)\n    if root_a != root_b:\n        if rank[root_a] > rank[root_b]:\n            parent[root_b] = root_a\n        else:\n            parent[root_a] = root_b\n            if rank[root_a] == rank[root_b]:\n                rank[root_b] += 1\n\nmst_sum = 0\ncount = 0\n\nwhile heap and len(graph) > 1:\n    length, a, b = heapq.heappop(heap)\n    if find(a) != find(b):\n        mst_sum += length\n        union(a, b)\n        graph[a].remove(b)\n        graph[b].remove(a)\n        for neighbor in graph[a]:\n            if (1, a, neighbor) in edges:\n                heapq.heappush(heap, (1, a, neighbor))\n        for neighbor in graph[b]:\n            if (1, b, neighbor) in edges:\n                heapq.heappush(heap, (1, b, neighbor))\n        count += 1\n\nprint(mst_sum % int(1e9+7), count % int(1e9+7))\n```", "time_gen": "\ntime generating: 13.079675s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=102": {"code": "```\n```python\nn, m = map(int, input().split())\ngraph = [[] for _ in range(n+1)]\nfor i in range(1, n):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\ndef dfs(node, visited, count):\n    if node not in visited:\n        visited.add(node)\n        count[0] += 1\n        for neighbor in graph[node]:\n            dfs(neighbor, visited, count)\n\ncount = [0]\nvisited = set()\nfor _ in range(m):\n    action, a, b = input().split()\n    a, b = map(int, (a, b))\n    if action == 'P':\n        graph[a].append(b)\n        graph[b].append(a)\n        dfs(a, visited, count)\n        dfs(b, visited, count)\n    elif action == 'Q':\n        print(count[0] - 1)\n\n```\n```", "time_gen": "\ntime generating: 6.884413s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=103": {"code": "Here is the Python code for the problem:\n```\nn, b = map(int, input().split())\np = [int(input()) for _ in range(n)]\ns = [int(input()) for _ in range(n)]\n\ngifts_given = 0\ntotal_cost = 0\n\nfor i in range(n):\n    if p[i] / 2 + s[i] <= b:\n        total_cost += p[i] + s[i]\n        gifts_given += 1\n    elif p[i] + s[i] <= b:\n        total_cost += p[i] + s[i]\n        gifts_given += 1\n\nprint(gifts_given)\n```", "time_gen": "\ntime generating: 5.252585s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=104": {"code": "Here is a Python solution for this problem:\n\n```markdown\n```\n```\nn, k = map(int, input().split())\nstacks = [0] * n\nfor _ in range(k):\n    a, b = map(int, input().split())\n    for i in range(a-1, b):\n        stacks[i] += 1\n\nstacks.sort()\nmedian_height = stacks[n//2]\nprint(median_height)\n```", "time_gen": "\ntime generating: 3.874783s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=105": {"code": "Here is the solution to the problem:\n```\nimport sys\nfrom collections import deque\n\ndef bfs(grid, bessie_start, mildred_start):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n    queue = deque([(bessie_start, mildred_start, 0)])\n    result = []\n    \n    while queue:\n        bessie, mildred, step = queue.popleft()\n        \n        if (bessie, mildred) not in visited and grid[bessie][mildred] == '.':\n            visited.add((bessie, mildred))\n            \n            if bessie == mildred:\n                result.append(step)\n            else:\n                for d in directions:\n                    new_bessie = bessie + d[0]\n                    new_mildred = mildred + d[1]\n                    \n                    if 0 <= new_bessie < len(grid) and 0 <= new_mildred < len(grid[0]) and (new_bessie, new_mildred) not in visited:\n                        queue.append((new_bessie, new_mildred, step + 1))\n    \n    return len(result)\n\nK = int(input())\ngrid = [['.' for _ in range(5)] for _ in range(5)]\nfor _ in range(K):\n    i, j = map(int, input().split())\n    grid[i][j] = 'x'\n\nprint(bfs(grid, 0, 4))\n```", "time_gen": "\ntime generating: 10.520629s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=106": {"code": "```\ndef delivery():\n    N = int(input())\n    farms = []\n    for _ in range(N):\n        x, y = map(int, input().split())\n        farms.append((x, y))\n\n    farms.sort()\n\n    total_time = 0\n    current_position = (farms[1][0], farms[1][1])\n\n    for i in range(2, N):\n        dx = abs(farms[i][0] - current_position[0])\n        dy = abs(farms[i][1] - current_position[1])\n        total_time += max(dx, dy)\n        current_position = (farms[i][0], farms[i][1])\n\n    dx = abs(farms[0][0] - current_position[0])\n    dy = abs(current_position[1] - farms[0][1])\n    total_time += min(dx, dy) + 2\n\n    print(total_time)\n\n\ndelivery()\n```", "time_gen": "\ntime generating: 6.175083s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=107": {"code": "```\n```\n\n```\nn = int(input())\nsizes = list(map(int, input().split() for _ in range(n)))\nsizes.sort(reverse=True)\nb1 = sum(sizes[i:i+3] for i in range(0, n, 3))\nprint(b1)\n```", "time_gen": "\ntime generating: 2.657223s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=108": {"code": "```\n```\n```python\nimport heapq\n\nn = int(input())\npq = []\ntotal_time = 0\n\nfor _ in range(n):\n    u, d = map(int, input().split())\n    pq.append((u, 1))  # (time, direction)\n    pq.append((d, -1))\n\npq.sort()\ncurr_time = 0\nprev_direction = None\n\nwhile pq:\n    time, direction = heapq.heappop(pq)\n\n    if direction == 1:  # climbing up\n        curr_time += time\n        prev_direction = 1\n    else:  # descending down\n        curr_time += time\n        prev_direction = -1\n\n    while pq and pq[0][1] != prev_direction:\n        heapq.heappop(pq)\n\nprint(curr_time)\n```", "time_gen": "\ntime generating: 5.555865s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=109": {"code": "```\ndef read_input():\n    N, K = map(int, input().split())\n    combos = []\n    for _ in range(N):\n        combos.append(input())\n    return N, K, combos\n\ndef solve(N, K, combos):\n    dp = [0] * (K + 1)\n    for combo in combos:\n        i = j = 0\n        while i <= K and j < len(combo):\n            if combo[j] == 'A':\n                while i < K and not any(c == 'A' for c in combos[i][j:j+2]):\n                    dp[i] += 1\n                    i += 1\n            elif combo[j] == 'B':\n                while i < K and not any(c == 'B' for c in combos[i][j:j+2]):\n                    dp[i] += 1\n                    i += 1\n            j += 1\n    return max(dp)\n\nN, K, _ = read_input()\nprint(solve(N, K, []))\n```", "time_gen": "\ntime generating: 6.848256s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=110": {"code": "```\npython\nimport sys\n\nN, M, K = map(int, input().split())\nmoves = list(input())\n\nfor _ in range(N):\n    cards = list(map(int, input().split()))\n    if moves[_] == 'T':\n        print('TB'[cards.index(max(cards)) < (M+K)//2], end='')\n    else:\n        print('BT'[cards.index(min(cards)) >= (M-K)//2], end='')\n```", "time_gen": "\ntime generating: 8.395578s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=111": {"code": "```\npython\ndef alliance(n, m):\n    MOD = 1000000007\n    res = 1\n    for _ in range(m - 2):\n        res = (res * (n - 2)) % MOD\n        n -= 1\n    return res\n```", "time_gen": "\ntime generating: 6.293757s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=112": {"code": "```\ndef count_folding_points(N, L):\n    folding_points = 0\n    for i in range(1, N-1):\n        if (i + 1) % ((L+1)//2) == 0:\n            folding_points += 1\n    return folding_points\n\nN, L = map(int, input().split())\nprint(count_folding_points(N, L))\n```", "time_gen": "\ntime generating: 5.886263s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=113": {"code": "```\n# Problem 2: Overplanting (Bronze)\nN = int(input())\ntotal_area = 0\nfor _ in range(N):\n    x1, y1, x2, y2 = map(int, input().split())\n    total_area += (x2 - x1) * (y2 - y1)\n\nprint(total_area)\n```", "time_gen": "\ntime generating: 4.711732s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=114": {"code": "```\n```python\nN = int(input())\n\ndef get_moo(N):\n    moomoos = \"m o \"\n    moo_length = len(moomoos)\n    result = \"\"\n    \n    while N > 0:\n        if N >= moo_length:\n            result += moomoos\n            N -= moo_length\n        else:\n            result += moomoos[:N]\n            break\n    \n    return \"m\" if result[N-1] == \"m\" else \"o\"\n\nprint(get_moo(N))\n```", "time_gen": "\ntime generating: 8.067201s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=115": {"code": "```\ndef calculate_area():\n    n = int(input())\n    total_area = 0\n    \n    for _ in range(n):\n        x1, y1, x2, y2 = map(int, input().split())\n        \n        # Calculate area of each rectangle\n        area = abs((x2 - x1) * (y2 - y1))\n        \n        # Add to total area\n        total_area += area\n    \n    print(total_area)\n```", "time_gen": "\ntime generating: 6.268461s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=116": {"code": "```\nimport sys\n\nN, K = map(int, sys.stdin.readline().split())\n\ndef generate_cow_ids(K):\n    cow_ids = []\n    for i in range(2**K):\n        id_str = ''\n        count = 0\n        for j in range(K-1, -1, -1):\n            if (i >> j) & 1:\n                id_str += '1'\n                count += 1\n            else:\n                id_str += '0'\n        if count == K and len(id_str) == K:\n            cow_ids.append(int(id_str, 2))\n    return cow_ids\n\ncow_ids = generate_cow_ids(K)\nprint(cow_ids[N-1])\n```", "time_gen": "\ntime generating: 8.477978s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=117": {"code": "Here is the Python code to solve this problem:\n```\nimport sys\nfrom collections import deque\n\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([(start, 0)])\n    min_distance = {i: float('inf') for i in range(1, N+1)}\n    min_distance[start] = 0\n\n    while queue:\n        (node, distance) = queue.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    queue.append((neighbor, distance + graph[node][neighbor]))\n                    if distance + graph[node][neighbor] < min_distance[neighbor]:\n                        min_distance[neighbor] = distance + graph[node][neighbor]\n\n    return min_distance\n\nN, M, K = map(int, sys.stdin.readline().split())\nmarkets = [int(i) for i in sys.stdin.read().splitlines()[:K]]\nroads = [[*map(int, line.split())] for line in sys.stdin.read().splitlines()[K:]]\ngraph = {i: {} for i in range(1, N+1)}\n\nfor road in roads:\n    graph[road[0]][road[1]] = road[2]\n    graph[road[1]][road[0]] = road[2]\n\nmin_distance = bfs(graph, 0)  # Start at town 1\ntotal_distance = sum(min_distance[i] for i in range(1, N+1) if i not in markets)\nprint(total_distance)\n```\nThis code first reads the input and constructs the graph. Then it uses a breadth-first search (BFS) algorithm to find the minimum distance from each town to all other towns. Finally, it calculates the total minimum distance by summing up the distances for the N-K towns without markets.", "time_gen": "\ntime generating: 22.958478s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=118": {"code": "Here is the Python solution:\n```markdown\n```\n```python\nn, k, m = map(int, input().split())\np = []\nc = []\n\nfor i in range(n):\n    pi, ci = map(int, input().split())\n    p.append(pi)\n    c.append(ci)\n\np.sort(reverse=True)\nc.sort()\n\nans = 0\n\nfor i in range(min(k, n)):\n    if p[i] <= m:\n        ans += 1\n        m -= p[i]\n    else:\n        break\n\nif k > n and m >= min(c):\n    ans += (k - n)\n\nprint(ans)\n```", "time_gen": "\ntime generating: 8.393565s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=119": {"code": "```\nimport itertools\nN = int(input())\npoints = [list(map(int, input().split())) for _ in range(N)]\nlines_of_symmetry = 0\n\nfor p1, p2 in itertools.combinations(range(N), 2):\n    x1, y1 = points[p1]\n    x2, y2 = points[p2]\n    \n    if (x1 == x2 and y1 != y2) or (y1 == y2 and x1 != x2):\n        lines_of_symmetry += 1\n    elif x1 == x2:\n        for p3 in range(N):\n            if p3 != p1 and p3 != p2:\n                x3, y3 = points[p3]\n                if x1 == x3 and y1 + y2 - 2*y3 != 0:\n                    lines_of_symmetry += 1\n                    break\n    elif y1 == y2:\n        for p3 in range(N):\n            if p3 != p1 and p3 != p2:\n                x3, y3 = points[p3]\n                if y1 == y3 and x1 + x2 - 2*x3 != 0:\n                    lines_of_symmetry += 1\n                    break\n\nprint(lines_of_symmetry)\n```", "time_gen": "\ntime generating: 14.278291s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=120": {"code": "```\nimport networkx as nx\nfrom collections import deque\n\nG = nx.Graph()\nN, K = map(int, input().split())\nfor _ in range(N-1):\n    i, j = map(int, input().split())\n    G.add_edge(i, j)\n\nC = [int(input()) for _ in range(N)]\n\ndef dfs(node, visited, max_cows):\n    if node not in visited:\n        visited.add(node)\n        return C[node]\n    else:\n        return 0\n\nM = [0]*N\nfor i in range(1, N):\n    queue = deque([(i, K)])\n    while queue and K > 0:\n        node, trails_left = queue.popleft()\n        if node not in M[i-1]:\n            continue\n        for neighbor in G.neighbors(node):\n            if M[neighbor-1] + C[neighbor] > max_cows[neighbor-1]:\n                max_cows[neighbor-1] = M[neighbor-1] + C[neighbor]\n                queue.append((neighbor, trails_left-1))\n    M[i-1] = max_cows[i-1]\n\nfor i in range(N):\n    print(M[i])\n```", "time_gen": "\ntime generating: 13.918073s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=121": {"code": "Here is the solution:\n```\nn = int(input(), 2)\nresult = bin(n * 17)[2:]\nprint(result.zfill(1000))\n```", "time_gen": "\ntime generating: 2.895366s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=122": {"code": "Here is the Python code for Problem 2: Connect the Cows:\n```\nn = int(input())\nroutes = 0\nfor i in range(1, n):\n    if (i % 4 == 1) or (i % 4 == 3):\n        routes += 1\nprint(routes)\n```", "time_gen": "\ntime generating: 5.283672s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=123": {"code": "```\ndef wrongdir():\n    s = input().strip()\n    n = len(s)\n    x, y = 0, 0\n    for c in s:\n        if c == 'F':\n            y += 1\n        elif c == 'L':\n            x -= 1\n        elif c == 'R':\n            x += 1\n    directions = ['N', 'E', 'S', 'W']\n    dir_index = 0\n    for c in s:\n        if c == 'F':\n            pass\n        elif c == 'L':\n            dir_index = (dir_index + 1) % 4\n        elif c == 'R':\n            dir_index = (dir_index - 1) % 4\n    dir_types = ['N', 'E', 'S', 'W']\n    dir_type_index = 0 if s.count('F') > s.count('L') and s.count('F') > s.count('R') else 1 if s.count('L') > s.count('R') else 2\n    print(len({(x, y), (x-1, y), (x+1, y), (-1*y, -1*x)}))\n\nwrongdir()\n```", "time_gen": "\ntime generating: 13.034008s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=124": {"code": "```\n```\n```python\nfrom collections import deque\n\ndef tractor(start, end, hays):\n    queue = deque([(start, 0)])\n    visited = {start}\n\n    while queue:\n        (x, y), dist = queue.popleft()\n\n        if (x, y) == end:\n            return dist\n\n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) not in visited and 1 <= nx <= 1000 and 1 <= ny <= 1000:\n                for hay in hays:\n                    if (nx, ny) == hay:\n                        break\n                else:\n                    queue.append(((nx, ny), dist + 1))\n                    visited.add((nx, ny))\n\n    return -1\n\nn, x, y = map(int, input().split())\nhays = [map(int, input().split()) for _ in range(n)]\nprint(tractor((x, y), (0, 0), hays))\n```", "time_gen": "\ntime generating: 12.853933s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=125": {"code": "```\nimport sys\n\nN, D = map(int, raw_input().split())\nraindrops = [map(int, line.split()) for line in sys.stdin.readlines()[1:]]\n\nmin_width = float('inf')\n\nfor i in range(N):\n    left = 0\n    right = max(x for x, _ in raindrops)\n    \n    while right - left > D:\n        min_width = min(min_width, right - left)\n        mid = (left + right) / 2\n        count = sum(1 for x, y in raindrops if x <= mid and y <= mid + D)\n        \n        if count < N:\n            right = mid\n        else:\n            left = mid + 1\n\nif min_width == float('inf'):\n    print(-1)\nelse:\n    print(min_width)\n```", "time_gen": "\ntime generating: 9.899122s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=126": {"code": "Here is a Python solution for the problem:\n```\nN, X, Y, Z = map(int, input().split())\nA = [0] * N\nB = [0] * N\nfor i in range(N):\n    A[i], B[i] = map(int, input().split())\n\ndp = [[float('inf')] * (N + 1) for _ in range(N + 1)]\ndp[0][0] = 0\n\nfor i in range(1, N + 1):\n    for j in range(max(i - 1, 0), min(N, i + 2)):\n        dp[i][j] = min(dp[i][j], dp[i-1][k] + X if A[k-1] < B[k-1] else dp[i-1][k] + Y for k in range(1, j+1))\n        dp[i][j] = min(dp[i][j], dp[j-1][k] + Z * abs(i-k) if A[k-1] > B[k-1] else dp[j-1][k] + X if A[k-1] < B[k-1] else dp[j-1][k] + Y for k in range(j+1, N))\n\nprint(dp[-1][-1])\n```", "time_gen": "\ntime generating: 14.481364s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=127": {"code": "```python\ndef solve():\n    m, n, l, h, b = map(int, input().split())\n    count = 0\n    for i in range(m+1):\n        for j in range(n+1):\n            if (i == 0 or j == 0) and (i == m or j == n):\n                continue\n            if l <= abs(i-j) + max(abs(i-m), abs(j-n)) <= h:\n                count += 1\n    print(count % b)\n\nsolve()\n```", "time_gen": "\ntime generating: 8.415319s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=128": {"code": "```\n```python\nn = int(input())\ndiffs = []\nfor i in range(n):\n    a, b = map(int, input().split())\n    diffs.append(abs(a - b))\n\ntotal_work = 0\ni = 0\nwhile len(diffs) > 1:\n    min_diff = min(diffs)\n    for _ in range(min_diff // 2):\n        if i == n - 1:\n            i = 0\n        else:\n            i += 1\n        total_work += min_diff\n        diffs[i % n] -= 2\n    i = (i + 1) % n\n\nprint(total_work)\n```", "time_gen": "\ntime generating: 8.148479s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=129": {"code": "Here is a Python solution for the problem:\n```\ndef skyscraper():\n    N, W = map(int, input().split())\n    cows = list(map(int, [input() for _ in range(N)]))\n\n    rides = 0\n    remaining_weight = W\n    current_cows = []\n\n    for cow in sorted(cows):\n        if cow > remaining_weight:\n            rides += 1\n            remaining_weight = W\n            current_cows = []\n        if sum(current_cows) + cow <= remaining_weight:\n            current_cows.append(cow)\n        else:\n            print(rides + 1)\n            for i in range(len(current_cows)):\n                print(len(current_cows), end=' ')\n                for j in range(len(current_cows)):\n                    if j < i:\n                        print(j, end=' ')\n            return\n\n    print(rides)\n    for i in range(rides):\n        print(len(current_cows[i]), end=' ')\n        for cow in current_cows[i]:\n            print(cow, end=' ')\n        print()\n\nskyscraper()\n```", "time_gen": "\ntime generating: 12.335009s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=130": {"code": "Here is the solution in Python:\n```\nn = int(input())\nbreed_ids = list(map(int, input().split() for _ in range(n)))\nmax_length = 0\ncurrent_length = 1\n\nfor i in range(1, n):\n    if breed_ids[i] == breed_ids[i-1]:\n        current_length += 1\n    else:\n        max_length = max(max_length, current_length)\n        current_length = 1\n\nprint(max_length)\n```", "time_gen": "\ntime generating: 6.232092s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=131": {"code": "```\n# 3lines problem\nimport sys\n\nN = int(input())\ncow_locations = [list(map(int, input().split())) for _ in range(N)]\n\ndef can_monitor_all_cows():\n    # Get all unique x and y coordinates\n    x_coords = set([location[0] for location in cow_locations])\n    y_coords = set([location[1] for location in cow_locations])\n\n    # Check if we have enough lines to cover all cows\n    return len(x_coords) + len(y_coords) >= 3\n\nprint(1 if can_monitor_all_cows() else 0)\n```", "time_gen": "\ntime generating: 7.535953s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=132": {"code": "Here is the Python code for the problem:\n```\nn = int(input())\nislands = []\nwater_level = 0\nmax_islands = 0\n\nfor i in range(n):\n    h = int(input())\n    while water_level <= h:\n        islands.append(h)\n        max_islands = max(max_islands, len(islands))\n        water_level += 1\n    islands.pop()\n\nprint(max_islands + 1)  # add 1 for the last island that will always exist\n```", "time_gen": "\ntime generating: 6.708543s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=133": {"code": "```\n```\n\nThis Python script checks whether three connected shapes can be separated by moving them around. It does this by checking if there is a path from one unit square to another, which means they are not yet separate.\n\n```python\ndef check_unlockable(n1, n2, n3, obj1, obj2, obj3):\n    for i in range(n1):\n        for j in range(n2):\n            for k in range(n3):\n                if all((abs(x1 - x2) + abs(y1 - y2)) <= 1\n                       for x1, y1 in zip(obj1[i], obj1[0])\n                       for x2, y2 in zip(obj2[j], obj2[0])\n                       for x3, y3 in zip(obj3[k], obj3[0])):\n                    return 0\n    return 1\n\nn1, n2, n3 = map(int, input().split())\nobj1 = [list(map(int, input().split())) for _ in range(n1)]\nobj2 = [list(map(int, input().split())) for _ in range(n2)]\nobj3 = [list(map(int, input().split())) for _ in range(n3)]\n\nprint(check_unlockable(n1, n2, n3, obj1, obj2, obj3))\n```", "time_gen": "\ntime generating: 15.422198s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=134": {"code": "```\ndef unlock():\n    N1, N2, N3 = [int(x) for x in input().split()]\n    object1 = []\n    object2 = []\n    object3 = []\n    \n    for _ in range(N1):\n        x, y = map(int, input().split())\n        object1.append((x, y))\n        \n    for _ in range(N2):\n        x, y = map(int, input().split())\n        object2.append((x, y))\n        \n    for _ in range(N3):\n        x, y = map(int, input().split())\n        object3.append((x, y))\n    \n    min_moves = float('inf')\n    \n    def get_manhattan_distance(obj1, obj2):\n        return sum(abs(a - b) for a, b in zip(obj1, obj2))\n    \n    def get_minimum_moves(obj1, obj2, obj3):\n        nonlocal min_moves\n        min_moves = min(min_moves, get_manhattan_distance(obj1[0], obj3[-1]) + \n                         get_manhattan_distance(obj2[0], obj3[0]) + \n                         get_manhattan_distance(obj3[-1], obj2[-1]))\n    \n    def is_separated():\n        for a in object1:\n            if any(abs(a[0] - b) <= 1 and abs(a[1] - b) <= 1 for b in object2 + object3):\n                return False\n        return True\n    \n    if not is_separated():\n        print(-1)\n    else:\n        get_minimum_moves(object1, object2, object3)\n        print(min_moves)\n\nunlock()\n```", "time_gen": "\ntime generating: 18.591598s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=135": {"code": "```\npython\nimport heapq\n\nN, L = map(int, input().split())\nbooks = []\nfor _ in range(N):\n    h, w = map(int, input().split())\n    books.append((-h, -w))\n\nshelves = []\ntotal_height = 0\nfor book in sorted(books):\n    while shelves and shelf_width(shelves[-1]) + book[1] > L:\n        total_height -= shelves.pop()[0]\n    if shelves:\n        height = max(height for _, height in shelves) + book[0]\n    else:\n        height = book[0]\n    shelves.append((height, book[1]))\n    total_height += height\n\nprint(total_height)\n```\n\nThis code reads the input and builds a priority queue of books. Then it iterates over the books, adding them to the shelves one by one. If a shelf is full, it removes the top shelf and adds a new one with the current book. The height of each shelf is updated accordingly.", "time_gen": "\ntime generating: 11.303984s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=136": {"code": "```\nfrom collections import Counter\n\nN, L, C = map(int, input().split())\nspeeds = list(map(int, [input() for _ in range(N)]))\n\nevent_times = [(C*i/L) for i in speeds]\nevent_times.sort()\n\ncount = 0\nlast_event_time = 0\nfor time in event_times:\n    count += (time - last_event_time)\n    last_event_time = time\n\nprint(count + sum(Counter(event_times).values()) - len(event_times))\n```", "time_gen": "\ntime generating: 6.742723s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=137": {"code": "Here is a Python solution for this problem:\n\n```markdown\n```\n```python\nimport sys\n\nn, m, bx, by = map(int, sys.stdin.readline().split())\nfence_posts = []\nfor _ in range(n):\n    x, y = map(int, sys.stdin.readline().split())\n    fence_posts.append((x, y))\n\nrope_segments = []\nfor _ in range(m):\n    x1, y1 = map(int, sys.stdin.readline().split())\n    x2, y2 = map(int, sys.stdin.readline().split())\n    rope_segments.append(((min(x1, x2), min(y1, y2)), (max(x1, x2), max(y1, y2))))\n\ndef intersect(p1, p2):\n    x1, y1 = p1\n    x2, y2 = p2\n    if y1 > y2:\n        return True, False\n    if y1 < y2:\n        return False, True\n    if x1 > x2:\n        return True, True\n    if x1 < x2:\n        return False, False\n    return (x1 <= y1 and x2 >= y2), (x1 >= y1 and x2 <= y2)\n\ndef solve():\n    rope = []\n    for segment in rope_segments:\n        p1, p2 = segment\n        if p1 == p2:\n            continue\n        if intersect(p1, p2):\n            if p1[0] < p2[0]:\n                rope.append(p1)\n                rope.append(p2)\n            else:\n                rope.append(p2)\n                rope.append(p1)\n\n    posts = []\n    for post in fence_posts:\n        found = False\n        for segment in rope:\n            if intersect(post, segment):\n                found = True\n                break\n        if not found:\n            posts.append(post)\n\n    return len(posts) - 1\n\nprint(solve())\n```", "time_gen": "\ntime generating: 21.232557s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=138": {"code": "Here is the Python solution for the problem:\n```\nn, l = map(int, input().split())\nshelf_heights = []\ntotal_width = 0\nfor _ in range(n):\n    h, w = map(int, input().split())\n    if total_width + w > l:\n        shelf_heights.append(h)\n        total_width = w\n    else:\n        total_width += w\nprint(max(shelf_heights) + sum(shelf_heights))\n```", "time_gen": "\ntime generating: 6.606089s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=139": {"code": "```\ndef subsets():\n    n = int(input())\n    total_milk = sum(int(input()) for _ in range(n))\n    balanced_subsets = 0\n    for i in range(2**n):\n        left_milk = sum(int(input()) for j in bin(i)[2:].zfill(n))\n        if left_milk == (total_milk - left_milk):\n            balanced_subsets += 1\n    print(balanced_subsets)\n```\n\nPlease note that this code assumes the input is in the format provided in the problem description.", "time_gen": "\ntime generating: 6.946564s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=187": {"code": "Here is the solution:\n```\nn = int(input())\npairs = 0\nleft = 0\nfor i in range(n):\n    if input()[i] == '(':\n        left += 1\n    elif input()[i] == ')':\n        if left > 0:\n            pairs += 1\n            left -= 1\n\nprint(pairs)\n```", "time_gen": "\ntime generating: 5.305858s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=188": {"code": "Here is the Python code for the problem:\n```markdown\ndef typo(s):\n    count = 0\n    bal = 0\n    for i, c in enumerate(s):\n        if c == '(':\n            bal += 1\n        else:\n            bal -= 1\n        if bal < 0:\n            count += 1\n    return count\n```\nYou can run this code with the input string `()(())))` to get the output `4`.", "time_gen": "\ntime generating: 6.397023s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=189": {"code": "```\ndef hshoe(n):\n    grid = [list(input().strip()) for _ in range(n)]\n    \n    def dfs(i, j, count):\n        if i < 0 or i >= n or j < 0 or j >= n:\n            return 0\n        \n        val = 1 if grid[i][j] == '(' else -1\n        new_count = count + val\n        \n        if new_count > 0:\n            return dfs(i, j+1, new_count) + 1\n        elif new_count < 0:\n            return dfs(i+1, j, new_count) + 1\n        else:\n            return val\n    \n    max_len = 0\n    \n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == '(':\n                count = dfs(i, j, 1)\n                if count > 0:\n                    max_len = max(max_len, count*2)\n    \n    return max_len\n\nn = int(input())\nprint(hshoe(n))\n```", "time_gen": "\ntime generating: 11.958433s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=190": {"code": "Here is a Python solution for the problem:\n```\ndef clumsy(s):\n    stack = []\n    toggles = 0\n    for c in s:\n        if c == '(':\n            stack.append(c)\n        else:\n            if not stack or stack.pop() != '(':\n                toggles += 1\n    return toggles + len(stack)\n\nif __name__ == '__main__':\n    with open('clumsy.in', 'r') as f:\n        s = f.readline().strip()\n    print(clumsy(s))\n```\nThis code uses a stack to keep track of the opening parentheses. For each closing parenthesis, it checks if the stack is empty or the top element is not an opening parenthesis. If either condition is true, it increments the `toggles` counter. Finally, it adds the number of remaining opening parentheses in the stack to the `toggles` count and returns the result.", "time_gen": "\ntime generating: 9.495335s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=191": {"code": "Here is the Python solution for the problem:\n```\nA, B = map(int, input().split())\nN = int(input())\n\ngrid = [list(input()) for _ in range(N)]\n\ndef dfs(i, j):\n    if i < 0 or i >= N or j < 0 or j >= N:\n        return float('inf')\n    if grid[i][j] == '(':\n        return B\n    left = dfs(i - 1, j)\n    right = dfs(i + 1, j)\n    up = dfs(i, j - 1)\n    down = dfs(i, j + 1)\n    return min(left, right, up, down) + A\n\nprint(dfs(0, 0))\n```", "time_gen": "\ntime generating: 8.734847s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=192": {"code": "Here is the Python code for the problem:\n```\nn = int(input())\ndp = [[0, 0] for _ in range(n + 1)]\n\nfor i in range(1, n + 1):\n    if input()[0] == '(':\n        dp[i][0] = dp[i - 1][0] + 1\n        dp[i][1] = dp[i - 1][1]\n    else:\n        dp[i][0] = dp[i - 1][0]\n        dp[i][1] = dp[i - 1][1] + 1\n\nans = (dp[n][0] * (dp[n][1] + 1)) % 2012\nprint(ans)\n```", "time_gen": "\ntime generating: 9.305568s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=193": {"code": "Here is the Python code to solve the problem:\n```\nn = int(input())\nans = 0\nfor i in range(n // 2 + 1):\n    for j in range(i, n - i):\n        if (i == 0 and j == 0) or (j == 0 and i == j) or ((i > 0) and (j < n - i) and (str.count(input(), '(') - str.count(input(), ')') == i)) and ((i > 0) and (j < n - i) and (str.count(input().rjust(n-j), '(') - str.count(input().rjust(n-j), ')') == i)):\n            ans += 1\nprint(ans % 2012)\n```", "time_gen": "\ntime generating: 9.6031s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=194": {"code": "Here is the solution in Python:\n```\nn, k = map(int, input().split())\ns = [input() for _ in range(k)]\nans = 0\nfor i in range(1, n):\n    if all(s[j][i:].count('(') >= s[j][i:].count(')') for j in range(k)):\n        ans += 1\n\nprint(ans)\n```", "time_gen": "\ntime generating: 6.543783s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=195": {"code": "```\ndef btree(n, edges, labels):\n    tree = [0] * (n + 1)\n    for p in range(2, n + 1):\n        parent = int(edges[p - 1])\n        if parent > 0:\n            tree[parent] += 1\n    max_depth = 0\n    stack = [(i, 0) for i in range(1, n + 1)]\n    while stack:\n        node, depth = stack.pop()\n        max_depth = max(max_depth, depth)\n        if tree[node]:\n            for child in range(tree[node]):\n                stack.append((tree.index(labels), depth + 1))\n    return max_depth\n```", "time_gen": "\ntime generating: 10.045713s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=205": {"code": "```\ndef greet(bessie_movements, elsie_movements):\n    bessie_position = 0\n    elsie_position = 0\n    total_moos = 0\n    \n    for i in range(len(bessie_movements)):\n        if bessie_movements[i][1] == \"L\":\n            bessie_position -= bessie_movements[i][0]\n        else:\n            bessie_position += bessie_movements[i][0]\n        \n        for j in range(len(elsie_movements)):\n            if elsie_movements[j][1] == \"L\":\n                elsie_position -= elsie_movements[j][0]\n            else:\n                elsie_position += elsie_movements[j][0]\n            \n            if abs(bessie_position - elsie_position) <= 1:\n                total_moos += 1\n    \n    return total_moos\n\nb, e = map(int, input().split())\nbessie_movements = [list(map(int, input().split())) for _ in range(b)]\nelsie_movements = [list(map(int, input().split())) for _ in range(e)]\n\nprint(greet(bessie_movements, elsie_movements))\n```", "time_gen": "\ntime generating: 13.882517s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=206": {"code": "```\nn = int(input())\nans = []\nfor _ in range(n):\n    s = input()\n    sorted_s = \"\".join(sorted(s))\n    start, end = 1, n\n    for c in sorted_s:\n        i = 0\n        while True:\n            if s[i] == c:\n                if i + 1 < len(s) and s[i+1] < c:\n                    start = max(start, i + 2)\n                else:\n                    end = min(end, i + 1)\n                break\n            i += 1\n    ans.append((start, end))\nprint(*ans, sep='\\n')\n```", "time_gen": "\ntime generating: 7.895282s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=207": {"code": "Here is the Python code for this problem:\n```\nimport heapq\nfrom collections import defaultdict\n\ndef crazy():\n    N, C = map(int, input().split())\n    fences = []\n    cows = []\n    for _ in range(N):\n        x1, y1, x2, y2 = map(int, input().split())\n        if x1 == x2:\n            fences.append(((x1, min(y1, y2)), (x1, max(y1, y2))) for y in range(min(y1, y2), max(y1, y2) + 1))\n        else:\n            fences.append(((min(x1, x2), y1), (max(x1, x2), y1)) for x in range(min(x1, x2), max(x1, x2) + 1))\n    for _ in range(C):\n        x, y = map(int, input().split())\n        cows.append((x, y))\n\n    communities = defaultdict(set)\n    for cow in cows:\n        community = None\n        heap = [(0, (cow[0], cow[1]))]\n        while heap and not community:\n            dist, pos = heapq.heappop(heap)\n            if any(0 <= x - p_x <= 1e-6 and 0 <= y - p_y <= 1e-6 for p_x, p_y in fences):\n                continue\n            community = {pos}\n            for fence in fences:\n                for p in fence:\n                    if abs(pos[0] - p[0]) + abs(pos[1] - p[1]) < dist:\n                        break\n                else:\n                    heap.append((dist + 1, p))\n        communities[community].add(tuple(cow))\n\n    max_community = max(communities.values(), key=len)\n    return len(max_community)\n\nprint(crazy())\n```", "time_gen": "\ntime generating: 19.536499s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=208": {"code": "```\ndef find_largest_community():\n    n, c = map(int, input().split())\n    \n    fences = []\n    for _ in range(n):\n        x1, y1, x2, y2 = map(int, input().split())\n        fences.append((x1, y1, x2, y2))\n    \n    cows = []\n    for _ in range(c):\n        x, y = map(int, input().split())\n        cows.append((x, y))\n    \n    largest_community = 0\n    \n    for i in range(len(cows)):\n        visited = [False] * len(cows)\n        visited[i] = True\n        stack = [(cows[i][0], cows[i][1])]\n        while stack:\n            x, y = stack.pop()\n            for j, (x2, y2) in enumerate(fences):\n                if x == x2 or y == y2:\n                    x3, y3 = ((x1 + x2) // 2, (y1 + y2) // 2) if x == x2 else ((x1 + x) // 2, (y1 + y) // 2)\n                    for k in range(len(cows)):\n                        if cows[k][0] == x3 and cows[k][1] == y3:\n                            visited[k] = True\n                            stack.append((cows[k][0], cows[k][1]))\n        largest_community = max(largest_community, sum(visited))\n\n    print(largest_community)\n```", "time_gen": "\ntime generating: 16.26199s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=209": {"code": "Here is the Python code for the problem:\n```\nA, B = map(int, input().split())\ncows = list(map(int, [input() for _ in range(N)]))\ncow_positions = sorted(cows)\nmin_cost = float('inf')\nfor i in range(1, len(cow_positions)):\n    r = (cow_positions[i] - cow_positions[i-1]) / 2\n    cost = A + B * r\n    if cost < min_cost:\n        min_cost = cost\n\nprint(min_cost)\n```\nNote that this code assumes the input is in the format specified in the problem statement, with three integers on the first line (`N`, `A`, and `B`), followed by `N` lines each containing an integer representing a cow's position.", "time_gen": "\ntime generating: 9.396125s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=210": {"code": "```\nimport heapq\nn, m, x = map(int, input().split())\npipes = []\nfor _ in range(m):\n    i, j, l, c = map(int, input().split())\n    pipes.append((l, 1/c, (i, j)))\n\nheap = [(0, float('inf'), (1, n))] # (latency, capacity, path)\nwhile heap:\n    latency, capacity, path = heapq.heappop(heap)\n    if path[0] == n:  # reached the tank\n        x -= capacity * (path[1] - 1)\n        if x <= 0:\n            print(latency + sum(1/c for l, c, _ in pipes))\n            break\n    for i, j, l, c in pipes:\n        if path[1] == i or path[1] == j:  # only consider adjacent pipes\n            new_capacity = min(capacity * (path[1] - i) / l, capacity)\n            heapq.heappush(heap, (latency + l, new_capacity, (i, j)))\n```", "time_gen": "\ntime generating: 13.761137s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=211": {"code": "Here is the Python solution:\n```markdown\n```\n```python\nimport sys\n\ndef read_input():\n    n, m = map(int, input().split())\n    gangs = [0] * (m + 1)\n    for i in range(1, m + 1):\n        gangs[i] = int(input())\n    return n, m, gangs\n\ndef solve(n, m, gangs):\n    total_cows = sum(gangs)\n    bessie_gang = gangs[1]\n    max_bessie_on_field = min(bessie_gang, (n + 1) // 2)\n    if max_bessie_on_field == 0:\n        return \"NO\\n0\"\n    else:\n        return \"YES\\n\" + str(max_bessie_on_field) + \"\\n\"\n        for i in range(1, n + 1):\n            gang = min(range(1, m + 1), key=lambda x: gangs[x])\n            if bessie_gang <= i // 2:\n                print(1)\n            else:\n                print(gang)\n\nif __name__ == \"__main__\":\n    n, m, gangs = read_input()\n    solve(n, m, gangs)\n```\nPlease note that this code assumes that the input is correct and does not include any error handling.", "time_gen": "\ntime generating: 16.140063s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=212": {"code": "```\nimport fileinput\n\ndef get_first_strings(filename):\n    with open(filename, 'r') as f:\n        n = int(f.readline())\n        first_strings = []\n        for _ in range(n):\n            s = f.readline().strip()\n            is_first = True\n            for t in first_strings:\n                if t < s and can_be_before(t, s):\n                    is_first = False\n                    break\n            if is_first:\n                first_strings.append(s)\n    return len(first_strings), first_strings\n\ndef can_be_before(s1, s2):\n    for c1, c2 in zip(s1, s2):\n        if c1 < c2:\n            return True\n        elif c1 > c2:\n            return False\n    return len(s1) < len(s2)\n\n_, first_strings = get_first_strings('first.in')\nprint(len(first_strings))\nfor s in first_strings:\n    print(s)\n```", "time_gen": "\ntime generating: 10.637027s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=213": {"code": "```\ndef runaway(N, L):\n    graph = {}\n    for i in range(1, N+1):\n        graph[i] = []\n        for j in range(i-1, 0, -1):\n            if (i-j) <= L:\n                graph[i].append(j)\n                break\n    count = [0]*(N+1)\n    for i in range(N, 0, -1):\n        for to in graph[i]:\n            count[to] += 1\n    return ' '.join(map(str, count[1:]))\n\n\nN, L = map(int, input().split())\nprint(runaway(N, L))\n```", "time_gen": "\ntime generating: 8.311524s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=223": {"code": "Here is the Python solution for the problem:\n```\nimport math\n\ndef orientation(x, y):\n    if x == 0 and y > 0:\n        return '/'\n    elif x == 0 and y < 0:\n        return '\\'\n    else:\n        return '/' if math.atan2(y, -x) > math.pi / 4 else '\\\\'\n\ndef can_see(a, b, fences):\n    for i in range(len(fences)):\n        x, y = int(fences[i].split()[0]), int(fences[i].split()[1])\n        orientation_ = fences[i].split()[-1]\n        if (a >= x and a <= x + 1) or (b >= y and b <= y + 1):\n            if orientation_ == '/':\n                return False\n            else:\n                a = min(a, x + 1)\n                b = min(b, y + 1)\n    return True\n\nn, a, b = map(int, input().split())\nfences = [input() for _ in range(n)]\nfor i in range(n):\n    x, y, direction = int(fences[i].split()[0]), int(fences[i].split()[1]), fences[i].split()[-1]\n    if can_see(a, b, fences[:i+1]):\n        print(i)\n        break\nelse:\n    print(-1)\n```", "time_gen": "\ntime generating: 17.088728s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=224": {"code": "```\n```python\npaint_moves = []\nfor _ in range(int(input())):\n    direction, distance = input().split()\n    distance = int(distance)\n    if direction == 'L':\n        paint_moves.append(-distance)\n    else:\n        paint_moves.append(distance)\n\ncurrent_position = 0\nprevious_positions = set()\n\npainted_area = 0\n\nfor move in paint_moves:\n    current_position += move\n    previous_positions.add(current_position)\n    if len(previous_positions) > 1:\n        painted_area += abs(min(previous_positions)) + abs(max(previous_positions))\n\nprint(painted_area)\n```", "time_gen": "\ntime generating: 7.611887s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=225": {"code": "Here is the Python code for Problem 3:\n```\nn, m = map(int, input().split())\ntruthful_cows = set()\nliars = set()\n\nfor _ in range(m):\n    x, y, t = input().split()\n    x, y = int(x), int(y)\n    \n    if t == 'T':\n        truthful_cows.add(y)\n    else:\n        liars.add(y)\n\nmax_a = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        if (i in truthful_cows and j not in truthful_cows) or (i not in truthful_cows and j in truthful_cows):\n            max_a += 1\n            break\n\nprint(max_a)\n```", "time_gen": "\ntime generating: 9.250247s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=226": {"code": "```\n```\n\n```python\ndef solve():\n    N, K = map(int, input().split())\n    moves = [list(map(int, input().split())) for _ in range(N)]\n    \n    intervals = []\n    for move in moves:\n        if move[0] > 0:\n            intervals.append((move[1], 'R'))\n        else:\n            intervals.append((-move[1], 'L'))\n\n    intervals.sort()\n    painted = set()\n\n    for i in range(len(intervals) - 1):\n        start, dir = intervals[i]\n        end, _ = intervals[i + 1]\n\n        if dir == 'R' and end < start:\n            continue\n\n        segment = (min(start, 0), max(end, 0))\n        if segment[0] <= 0 and segment[1] >= 0:\n            painted.add(segment)\n        elif segment[0] > 0:\n            for p in list(painted):\n                if p[1] < segment[0]:\n                    painted.remove(p)\n\n    area = sum((p[1] - p[0]) for p in painted) + 1\n    print(min(area, K * (K - 1)))\n\nif __name__ == \"__main__\":\n    solve()\n```\n**Problem**: Painting the Fence", "time_gen": "\ntime generating: 13.744201s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=227": {"code": "```\ndef find_overlap_area(pastures):\n    overlaps = set()\n    for i in range(len(pastures)):\n        for j in range(i+1, len(pastures)):\n            x1, y1 = pastures[i]\n            x2, y2 = pastures[j]\n\n            if abs(x1-x2) > K or abs(y1-y2) > K:\n                continue\n\n            overlap_area = 0\n            for dx in range(-K, K+1):\n                for dy in range(-K, K+1):\n                    x = x1 + dx\n                    y = y1 + dy\n\n                    if (x-K)**2 + (y-K)**2 <= K**2:\n                        if min(x1-K, x2-K) <= x <= max(x1-K, x2-K) and min(y1-K, y2-K) <= y <= max(y1-K, y2-K):\n                            overlap_area += 1\n\n            if overlap_area > 0:\n                overlaps.add((i, j))\n    return -1 if len(overlaps) > 1 else sum(((K- abs(x1-x2)) * (K-abs(y1-y2))) for x1, y1 in pastures for x2, y2 in pastures if (x1, y1) in overlaps and (x2, y2) in overlaps)\n```", "time_gen": "\ntime generating: 14.474197s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=228": {"code": "Here is the Python code for the problem:\n```\nimport heapq\n\nN, G = map(int, input().split())\ninvited = set([1])\npq = [(G, 0)]  # priority queue (group size, group index)\n\nwhile pq:\n    g, i = heapq.heappop(pq)\n    while i < len(groups[i]):\n        x = groups[i].pop()\n        if x not in invited:\n            invited.add(x)\n            for j in range(len(groups)):\n                if set(groups[j]).issubset(set([x])):\n                    s = len(groups.pop(j))\n                    heapq.heappush(pq, (s, j))\n            break\n    if i == G - 1:\n        break\n\nprint(len(invited) - 1)\n```", "time_gen": "\ntime generating: 9.434334s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=229": {"code": "```\ndef solve(N, K):\n    seen = set()\n    max_length = 0\n    current_length = 1\n    for i in range(1, N+1):\n        breed_id = int(input())\n        if breed_id not in seen:\n            seen.add(breed_id)\n            if current_length > max_length:\n                max_length = current_length\n            current_length = 1\n        else:\n            current_length += 1\n\n    if K == 0:\n        return N\n\n    to_remove = set()\n    for i in range(1, N+1):\n        breed_id = int(input())\n        if breed_id not in seen:\n            continue\n        seen.add(breed_id)\n        if breed_id not in to_remove:\n            to_remove.add(breed_id)\n            current_length -= 1\n        else:\n            if current_length > max_length:\n                max_length = current_length\n            current_length = 1\n\n    return max(max_length, N - len(to_remove))\n\nN, K = map(int, input().split())\nprint(solve(N, K))\n```", "time_gen": "\ntime generating: 11.76379s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=230": {"code": "```\ndef find_distance(grid):\n    R, C = len(grid), len(grid[0])\n    visited = [[False]*C for _ in range(R)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    min_distance = float('inf')\n\n    def dfs(x, y):\n        if visited[x][y]:\n            return\n        visited[x][y] = True\n        for dx, dy in directions:\n            nx, ny = x+dx, y+dy\n            if (0 <= nx < R and 0 <= ny < C and \n                grid[nx][ny] == 'X' and not visited[nx][ny]):\n                queue.append((nx, ny))\n        return len(queue)\n\n    for r in range(R):\n        for c in range(C):\n            if grid[r][c] == 'X':\n                min_distance = min(min_distance, dfs(r, c))\n\n    return min_distance\n\nR, C = map(int, input().split())\ngrid = [list(input()) for _ in range(R)]\nprint(find_distance(grid))\n```", "time_gen": "\ntime generating: 13.192462s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=231": {"code": "```\ndef seating():\n    N, M = map(int, input().split())\n    seats = [0] * (N + 1)\n    turned_away = 0\n    \n    for _ in range(M):\n        event = input()\n        \n        if 'A' in event:\n            p = int(event.split()[1])\n            \n            if sum(seats[i:i+p]) > 0 or i + p > N:\n                turned_away += 1\n            else:\n                seats[i:i+p] = [p] * p\n                \n        elif 'L' in event:\n            a, b = map(int, event.split()[1:])\n            \n            for i in range(a-1, b):\n                seats[i] = 0\n                \n    print(turned_away)\n```", "time_gen": "\ntime generating: 9.102961s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=241": {"code": "```\ndef count_non_loopy_cows():\n    N = int(input())\n    F = [0] * (N + 1)\n    for i in range(1, N + 1):\n        F[i] = int(input())\n\n    visited = [False] * (N + 1)\n\n    def dfs(i):\n        if visited[i]:\n            return False\n        visited[i] = True\n\n        next_i = F[i]\n        while next_i != i and not visited[next_i]:\n            next_i = F[next_i]\n        if next_i == i:\n            return True\n        return False\n\n    count = 0\n    for i in range(1, N + 1):\n        if dfs(i):\n            count += 1\n\n    print(count)\n\ncount_non_loopy_cows()\n```", "time_gen": "\ntime generating: 9.10355s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=242": {"code": "```\ndef cow_crossings():\n    n = int(input())\n    intersections = 0\n    for _ in range(n):\n        a, b = map(int, input().split())\n        if a > b:\n            a, b = b, a\n        intersections += len([i for i in range(a+1, b) if (i*(i+1))%2==0])\n    print(n-intersections)\n\ncow_crossings()\n```", "time_gen": "\ntime generating: 5.933575s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=243": {"code": "Here is the Python code for the problem:\n```\nimport sys\n\ndef perimeter(hay_bales):\n    max_x = max(x for x, _ in hay_bales)\n    min_x = min(x for x, _ in hay_bales)\n    max_y = max(y for _, y in hay_bales)\n    min_y = min(y for _, y in hay_bales)\n\n    perimeter = 2 * (max_x - min_x + max_y - min_y)\n\n    return perimeter\n\nif __name__ == \"__main__\":\n    N = int(sys.stdin.readline())\n    hay_bales = []\n    for _ in range(N):\n        x, y = map(int, sys.stdin.readline().split())\n        hay_bales.append((x, y))\n\n    print(perimeter(hay_bales))\n```", "time_gen": "\ntime generating: 9.414731s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=244": {"code": "Here is the Python code for the problem:\n```\nfrom collections import deque\n\ndef perimeter(hay_bales):\n    # Find all connected bales\n    visited = set()\n    queue = deque([(x, y) for x, y in hay_bales])\n    while queue:\n        x, y = queue.popleft()\n        if (x, y) not in visited:\n            visited.add((x, y))\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if (nx, ny) in hay_bales and (nx, ny) not in visited:\n                    queue.append((nx, ny))\n\n    # Find the perimeter\n    max_x = max(x for x, _ in hay_bales)\n    min_x = min(x for x, _ in hay_bales)\n    max_y = max(y for _, y in hay_bales)\n    min_y = min(y for _, y in hay_bales)\n\n    return 2 * ((max_x - min_x) + (max_y - min_y))\n\n# Read the input\nN = int(input())\nhay_bales = []\nfor _ in range(N):\n    x, y = map(int, input().split())\n    hay_bales.append((x, y))\n\nprint(perimeter(hay_bales))\n```\nThis code uses a breadth-first search (BFS) algorithm to find all connected bales, and then calculates the perimeter by finding the minimum and maximum coordinates of the bales.", "time_gen": "\ntime generating: 16.678748s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=245": {"code": "```python\nimport sys\nfrom collections import deque\n\ndef bfs(grid, start):\n    visited = [[False] * len(grid[0]) for _ in range(len(grid))]\n    queue = deque([(start, 0)])\n    max_height_diff = 0\n\n    while queue:\n        (x, y), height_diff = queue.popleft()\n        if visited[x][y]:\n            continue\n        visited[x][y] = True\n\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and\n                    not visited[nx][ny] and abs(grid[nx][ny] - grid[x][y]) <= height_diff):\n                queue.append(((nx, ny), height_diff))\n                max_height_diff = max(max_height_diff, abs(grid[nx][ny] - grid[x][y]))\n\n    return max_height_diff\n\n\ndef solve():\n    N = int(input())\n    elevations = [list(map(int, input().split())) for _ in range(N)]\n    total_cells = N * N\n    visited_cells = sum(1 for row in elevations if any(cell > 0 for cell in row))\n\n    half_visited_cells = (visited_cells + 1) // 2\n    remaining_cells = total_cells - visited_cells\n\n    min_cost = float('inf')\n\n    for _ in range(N):\n        start = (0, 0)\n        while True:\n            height_diff = bfs(elevations, start)\n            if len(list(filter(lambda x: abs(x[1] - elevations[x[0]][x[2]]) <= height_diff, enumerate(elevations)))) >= half_visited_cells + remaining_cells // 2:\n                min_cost = min(min_cost, height_diff)\n                break\n            start = (min(i for i in range(N) if any(abs(elevations[i][j] - elevations[x[0]][x[2]]) <= height_diff for j in range(len(elevations[0])))), 0)\n\n    print(min_cost)\n\n\nif __name__ == \"__main__\":\n    solve()\n```", "time_gen": "\ntime generating: 22.754318s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=246": {"code": "```\ndef milk_scheduling():\n    N, M = [int(x) for x in input().split()]\n    times = list(map(int, input().split()))\n    constraints = []\n    for _ in range(M):\n        A, B = map(int, input().split())\n        constraints.append((A - 1, B - 1))\n\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    for i in range(1, N + 1):\n        dp[i][i] = times[i - 1]\n\n    for A, B in constraints:\n        for i in range(A, B):\n            dp[A][B] = max(dp[A][i], dp[i][B])\n\n    return sum(max(dp[i][j] for j in range(i + 1, N + 1)) for i in range(N))\n\nprint(milk_scheduling())\n```", "time_gen": "\ntime generating: 10.689404s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=247": {"code": "```\nimport heapq\n\ndef partition(n, k, pastures):\n    # Initialize a priority queue to store the number of cows\n    pq = [(pasture[0], 1) for pasture in pastures]\n    heapq.heapify(pq)\n\n    while k > 0:\n        # Extract the largest group from the priority queue\n        total_cows, group_size = heapq.heappop(pq)\n        if group_size * (n - 1) + total_cows > n ** 2 / 4:  # Check if it's possible to split the group into two groups\n            new_group_size = (group_size * (n - 1) + total_cows) // (n - 1)\n            heapq.heappush(pq, (new_group_size * (n - 1), new_group_size))\n        k -= 1\n\n    # The maximum possible size of the largest group is stored in the priority queue\n    return -heapq.heappop(pq)[0] + 1\n\n\n# Read input\nwith open(\"partition.in\", \"r\") as f:\n    n, k = map(int, f.readline().split())\n    pastures = [list(map(int, line.split())) for line in f.readlines()]\n\nprint(partition(n, k, pastures))\n```", "time_gen": "\ntime generating: 13.339201s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=248": {"code": "Here is the Python solution for Problem 2: Taxi:\n```\nM, N = map(int, input().split())\nstart_pos = [0] * N\nend_pos = [0] * N\n\nfor i in range(N):\n    start_pos[i], end_pos[i] = map(int, input().split())\n\npos = list(range(M))\npos.sort()\n\ntotal_distance = 0\ncurrent_pos = 0\n\nfor i in range(N):\n    while current_pos < start_pos[i]:\n        total_distance += pos[0]\n        current_pos = pos[0]\n    while current_pos > end_pos[i]:\n        total_distance -= pos[-1]\n        current_pos = pos[-1]\n    total_distance += abs(start_pos[i] - end_pos[i])\n\nprint(total_distance)\n```", "time_gen": "\ntime generating: 9.612112s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=249": {"code": "```\n```\n\n```python\nfrom heapq import *\n\ndef read_data():\n    n, m, r = map(int, input().split())\n    left_sites = [int(input()) for _ in range(n)]\n    right_sites = [int(input()) for _ in range(m)]\n    routes = []\n    for _ in range(r):\n        i, j = map(int, input().split())\n        routes.append((i-1, j-1))  # subtract 1 because indexing starts at 0\n    return left_sites, right_sites, routes\n\ndef solve():\n    left_sites, right_sites, routes = read_data()\n    graph = [[] for _ in range(len(left_sites) + len(right_sites))]\n    for i, j in routes:\n        graph[i].append((j, -left_sites[i]))  # negative because we want to minimize\n        graph[j+len(left_sites)].append((i, left_sites[i]))\n    dp = [float('inf')] * (len(left_sites) + len(right_sites))\n    dp[0] = 0\n    pq = [(0, 0)]  # priority queue\n    while pq:\n        val, node = heappop(pq)\n        for neighbor, edge_val in graph[node]:\n            new_val = val + edge_val\n            if new_val > dp[neighbor]:\n                dp[neighbor] = new_val\n                heappush(pq, (new_val, neighbor))\n    return -dp[-1]\n\nprint(solve())\n```", "time_gen": "\ntime generating: 17.531507s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=259": {"code": "```\n```python\nN, M = map(int, input().split())\nbessie_segments = []\nfor _ in range(N):\n    speed, time = map(int, input().split())\n    bessie_segments.append((speed, time))\n\nelsie_segments = []\nfor _ in range(M):\n    speed, time = map(int, input().split())\n    elsie_segments.append((speed, time))\n\ntotal_distance = sum(s * t for s, t in zip(*[s + (0,) for s in [bessie_segments, elsie_segments]]))\ndistance_so_far = 0\n\nleadership_changes = 0\nfor bessie_speed, bessie_time in bessie_segments:\n    distance_bessie_runs = bessie_speed * min(bessie_time, total_distance - distance_so_far)\n    distance_so_far += distance_bessie_runs\n    for elsie_speed, elsie_time in elsie_segments:\n        if total_distance - distance_so_far < elsie_time:\n            break\n        distance_elsie_runs = elsie_speed * min(elsie_time, total_distance - distance_so_far)\n        distance_so_far += distance_elsie_runs\n        if distance_bessie_runs + distance_elsie_runs > 0 and (distance_bessie_runs - distance_elsie_runs) % (bessie_speed + elsie_speed) == 0:\n            leadership_changes += 1\n\nprint(leadership_changes)\n```", "time_gen": "\ntime generating: 16.919994s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=260": {"code": "```\nfrom collections import defaultdict\n\nN, K = map(int, input().split())\nbreads = [int(input()) for _ in range(N)]\n\nmax_breed_id = -1\nseen_breeds = set()\nfor i in range(N):\n    if breeds[i] in seen_breeds:\n        max_breed_id = max(max_breed_id, breeds[i])\n    else:\n        seen_breeds.add(breads[i])\n\nprint(max_breed_id)\n```", "time_gen": "\ntime generating: 5.867695s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=261": {"code": "Here is the Python code:\n```\nn, k = map(int, input().split())\ngraph = [[] for _ in range(n)]\nfor _ in range(k):\n    x, y = input().split()\n    if x == 'S':\n        graph[x-1].append(y-1)\n        graph[y-1].append(x-1)\n    elif x == 'D':\n        graph[x-1].append(str(-y))\n        graph[y-1].append(str(-x))\n\ndef dfs(node, color):\n    visited.add(node)\n    for neighbor in graph[node]:\n        if neighbor < 0:\n            return True\n        if neighbor not in visited and dfs(int(neighbor), -color):\n            return True\n\ntotal = 0\nfor i in range(n):\n    if i not in visited:\n        total += 1 if dfs(i, 1) else 0\n\nprint(total)\n```", "time_gen": "\ntime generating: 10.061331s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=262": {"code": "```python\nn = int(input())\na = [int(x) for x in input().split()]\ns, e = 1, n\nans = 0\nfor i in range(len(a)):\n    if a[i] < s:\n        s = a[i]\n    elif a[i] > e:\n        e = a[i]\n    else:\n        ans += (e - s + 1)\n        s = a[i]\n        e = a[i]\nprint(ans+1)```", "time_gen": "\ntime generating: 6.044435s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=263": {"code": "```\nimport sys\ndef main():\n    N = int(sys.stdin.readline().strip())\n    count = 0\n    for _ in range(N):\n        x1, y1, x2, y2 = map(int, sys.stdin.readline().split())\n        for i in range(x1, x2+1):\n            for j in range(y1, y2+1):\n                if (i < x1 or i > x2) and (j < y1 or j > y2): \n                    count += 1\n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n```", "time_gen": "\ntime generating: 6.537482s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=264": {"code": "```\nimport heapq\nn = int(input())\ncows = [(int(line), i) for i, line in enumerate(map(int, input().split()))]\ncows.sort()\nheap = []\ntotal_damage = 0\nfor i, (damage, pos) in enumerate(cows):\n    while len(heap) > i:\n        prev_damage, _ = heapq.heappop(heap)\n        total_damage += damage - prev_damage\n    heapq.heappush(heap, (pos, damage))\nprint(total_damage)\n```", "time_gen": "\ntime generating: 3.307438s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=265": {"code": "```\ndef cowrun(input_file):\n    with open(input_file, 'r') as file:\n        N = int(file.readline())\n        cows = [int(line.strip()) for line in file.readlines()]\n    \n    cows.sort()\n    total_damage = 0\n    for i in range(N-1):\n        distance = abs(cows[i] - cows[i+1])\n        damage = distance * (i + 2)\n        total_damage += damage\n    \n    print(total_damage)\n\ncowrun('cowrun.in')\n```", "time_gen": "\ntime generating: 5.827819s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=266": {"code": "```\n```\n\n```python\nn = int(input())\nhills = []\nfor _ in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    hills.append((x1, y1, x2, y2))\n\ncount = 0\nx, y = 0, 0\n\nwhile True:\n    for hill in hills:\n        if x >= hill[0] and x <= hill[2]:\n            if y < hill[1] or y > hill[3]:\n                break\n    else:\n        count += 1\n    if y == -float('inf'):\n        break\n    x = min(hill[2] for hill in hills)\n    y -= 1\n\nprint(count)\n```\n\nNote: This code assumes that the input is correct and does not contain any invalid or inconsistent data.", "time_gen": "\ntime generating: 5.47816s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=267": {"code": "```\n```\ndef find_min_stones_to_remove(necklace, name):\n    m = len(name)\n    n = len(necklace)\n\n    stones_to_remove = 0\n    for i in range(n - m + 1):\n        if necklace[i:i+m] == name:\n            stones_to_remove += m\n\n    return stones_to_remove\n\nif __name__ == \"__main__\":\n    with open(\"necklace.in\", \"r\") as f:\n        necklace = f.readline().strip()\n        name = f.readline().strip()\n\n    print(find_min_stones_to_remove(necklace, name))\n```", "time_gen": "\ntime generating: 5.314247s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=278": {"code": "```python\ndef ballet(dance):\n    x, y = 0, 0\n    for i in dance:\n        if i[0] == 'F':\n            dx, dy = {'R': 1, 'L': -1}.get(i[1], 0), {'B': -1, 'F': 1}.get(i[2], 0)\n        else:\n            dx, dy = 0, 0\n            if i[0] == 'F':\n                x, y = y, -x\n            elif i[0] == 'R':\n                x, y = -y, x\n            elif i[0] == 'L':\n                x, y = y, -x\n        x += dx\n        y += dy\n        if abs(x) + abs(y) > 1000:\n            return -1\n    min_x, max_x = min(0, x), max(0, x)\n    min_y, max_y = min(0, y), max(0, y)\n    return (max_x + 1) * (max_y + 1)\n```", "time_gen": "\ntime generating: 18.615467s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=279": {"code": "```\npython\nN, B = [int(x) for x in input().split()]\nlights = list(map(int, input().split()))\nfor _ in range(B):\n    new_lights = [(lights[i-1] + lights[(i+1)%N]) % 2 for i in range(N)]\n    lights = new_lights\nprint(*lights, sep='\\n')\n```", "time_gen": "\ntime generating: 7.366463s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=280": {"code": "```markdown\n```python\nimport sys\n\ndef photo(N, K):\n    pairs = []\n    for _ in range(K):\n        a, b = map(int, sys.stdin.readline().split())\n        pairs.append((min(a, b), max(a, b)))\n\n    pairs.sort()\n\n    photos = 0\n    last_pair_end = -1\n    for pair in pairs:\n        if pair[0] > last_pair_end + 1:\n            photos += 1\n            last_pair_end = pair[1]\n        else:\n            last_pair_end = max(last_pair_end, pair[1])\n\n    if last_pair_end < N:\n        photos += 1\n\n    print(photos)\n\nphoto(*map(int, sys.stdin.readline().split()))\n```\n```", "time_gen": "\ntime generating: 9.373626s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=281": {"code": "Here is a Python solution for the Haywire problem:\n\n```\ndef count_hay(cow_friends):\n    cow_friends.sort()\n    hay_count = 0\n    i = 0\n    while i < len(cow_friends) - 1:\n        j = i + 1\n        while j < len(cow_friends):\n            if cow_friends[j] > cow_friends[i]:\n                break\n            j += 1\n        hay_count += (j - i) * (j - i - 1) // 2\n        i = j\n    return hay_count\n\ndef main():\n    N = int(input())\n    cow_friends = [list(map(int, input().split())) for _ in range(N)]\n    \n    min_hay = float('inf')\n    for perm in itertools.permutations(range(1, N+1)):\n        this_perm_hay = count_hay([i-1 for i in perm])\n        min_hay = min(min_hay, this_perm_hay)\n\n    print(min_hay)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis code uses the itertools.permutations function to generate all possible orderings of the cows. It then calculates the total amount of hay required for each ordering and keeps track of the minimum.", "time_gen": "\ntime generating: 15.473619s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=282": {"code": "```\nimport sys\n\ndef read_input():\n    N, M = map(int, input().split())\n    world = [input() for _ in range(N)]\n    start_captain = None\n    doctor_location = None\n    for i in range(N):\n        for j in range(M):\n            if world[i][j] == 'C':\n                start_captain = (i, j)\n            elif world[i][j] == 'D':\n                doctor_location = (i, j)\n    return N, M, world, start_captain, doctor_location\n\ndef is_valid_position(world, position):\n    row, col = position\n    if row < 0 or row >= len(world) or col < 0 or col >= len(world[0]):\n        return False\n    return world[row][col] != '#'\n\ndef calculate_distance(world, start, end):\n    queue = [(start, 0)]\n    visited = set([start])\n    while queue:\n        position, distance = queue.pop(0)\n        if position == end:\n            return distance\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_position = (position[0] + dx, position[1] + dy)\n            if is_valid_position(world, new_position) and new_position not in visited:\n                queue.append((new_position, distance + 1))\n                visited.add(new_position)\n    return -1\n\ndef solve():\n    N, M, world, start_captain, doctor_location = read_input()\n    gravity_flips = calculate_distance(world, start_captain, doctor_location)\n    if gravity_flips == -1:\n        print(-1)\n    else:\n        print(gravity_flips)\n\nif __name__ == \"__main__\":\n    solve()\n```", "time_gen": "\ntime generating: 22.777423s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=283": {"code": "```\npython\n```\n\n```markdown\ndef solve():\n    N, G, B, D = map(int, input().split())\n    stations = [list(map(int, input().split())) for _ in range(N)]\n    dp = [[float('inf')] * (G + 1) for _ in range(D + 1)]\n\n    dp[0][B] = 0\n    for i in range(D):\n        for j in range(min(G, D - i), -1, -1):\n            if dp[i][j] != float('inf'):\n                x, y = stations[i]\n                if j + y <= G:\n                    dp[i + 1][min(j + y, G)] = min(dp[i + 1][min(j + y, G)], dp[i][j] + y)\n                if i >= x and j >= y:\n                    dp[x][j - y] = min(dp[x][j - y], dp[i][j] + y)\n\n    return dp[D][G] if dp[D][G] != float('inf') else -1\n\nprint(solve())\n```", "time_gen": "\ntime generating: 15.760772s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=284": {"code": "```\npython\nN, M, K = [int(x) for x in input().split()]\nport_directions = [input().split() for _ in range(N)]\ndirection_sequence = list(input())\n\ncurrent_port = 1\nfor _ in range(K):\n    if direction_sequence.pop(0) == 'L':\n        next_port = int(port_directions[current_port-1][0])\n    else:\n        next_port = int(port_directions[current_port-1][1])\n    current_port = next_port\n\nprint(current_port)\n```", "time_gen": "\ntime generating: 8.780866s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=285": {"code": "```\n```\n\n```\nn, m = [int(x) for x in input().split()]\nspots = set()\nfor _ in range(m):\n    a, b = [int(x) for x in input().split()]\n    if a == 1:\n        spots.add(b)\n    elif b == n:\n        spots.add(a - 1)\n    else:\n        if (a + b) % 2 == 0:\n            if a < b:\n                spots.add(b)\n            else:\n                spots.add(a - 1)\n        else:\n            if a < b:\n                spots.add(a - 1)\n            else:\n                spots.add(b)\nprint(min(spots) if len(spots) > 0 else -1)\n```", "time_gen": "\ntime generating: 10.279394s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=286": {"code": "```\n```python\ndef read_input():\n    N = int(input())\n    edges = []\n    for _ in range(N-1):\n        a, b, t = map(int, input().split())\n        edges.append((a, b, t))\n    return N, edges\n\n\ndef find_paths(N, edges):\n    paths = set()\n    for i in range(N-1):\n        for j in range(i+1, N):\n            path = [i+1]\n            while True:\n                for edge in edges:\n                    if len(path) == 0 or (path[-1] == edge[0] and edge[1] not in path) or (path[-1] == edge[1] and edge[0] not in path):\n                        path.append(edge[0] if edge[1] == j else edge[1])\n                        break\n                else:\n                    continue\n                break\n            if len(path) > 2 and path.count(path[0]) == 1 and path.count(path[-1]) == 1:\n                paths.add(tuple(sorted(map(int, path))))\n    return paths\n\n\ndef main():\n    N, edges = read_input()\n    paths = find_paths(N, edges)\n    print(len(paths))\n\n\nif __name__ == \"__main__\":\n    main()```", "time_gen": "\ntime generating: 16.448615s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=287": {"code": "```python\ndef find_max_score(marble):\n    N = len(marble)\n    max_score = -1\n    \n    for top_left_x in range(N):\n        for top_left_y in range(N):\n            if marble[top_left_y][top_left_x] == '*':\n                continue\n            \n            for bottom_right_x in range(top_left_x, N):\n                for bottom_right_y in range(N-1, top_left_y, -1):\n                    if marble[bottom_right_y][bottom_right_x] == '*':\n                        break\n                    if marble[top_left_y][top_left_x] != '.':\n                        continue\n                    \n                    top_width = 0\n                    while top_left_x + top_width < bottom_right_x and marble[top_left_y][top_left_x+top_width] == '.':\n                        top_width += 1\n                        \n                    bottom_width = 0\n                    while bottom_right_y - bottom_width > top_left_y and marble[bottom_right_y-bottom_width][bottom_right_x] == '.':\n                        bottom_width += 1\n                        \n                    if top_width * bottom_width > max_score:\n                        max_score = top_width * bottom_width\n    \n    return max_score\n\n# Read input\nN = int(input())\nmarble = [list(line) for line in [input() for _ in range(N)]]\n\nprint(find_max_score(marble))\n```", "time_gen": "\ntime generating: 17.176296s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=340": {"code": "```\ndef count_combinations(N, farmer, master):\n    total = 0\n    for i1 in range(N + 1):\n        for i2 in range(N + 1):\n            for i3 in range(N + 1):\n                diff_farmer = abs(i1 - farmer[0]) + abs(i2 - farmer[1]) + abs(i3 - farmer[2])\n                diff_master = abs(i1 - master[0]) + abs(i2 - master[1]) + abs(i3 - master[2])\n                if min(diff_farmer, diff_master) <= 2:\n                    total += 1\n    return total\n\nN = int(input())\nfarmer = list(map(int, input().split()))\nmaster = list(map(int, input().split()))\n\nprint(count_combinations(N, farmer, master))\n```", "time_gen": "\ntime generating: 10.910419s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=341": {"code": "Here is the Python solution for the problem:\n```\nn, x, y, z = map(int, input().split())\ntotal_milk = 0\nfor _ in range(n):\n    a, b = map(int, input().split())\n    if a <= x:\n        total_milk += x\n    elif b >= y:\n        total_milk += y\n    else:\n        for t in range(a, b+1):\n            if t < x:\n                total_milk += x\n            elif t > y:\n                total_milk += z\n            else:\n                total_milk += y\nprint(total_milk)\n```\nThis code first reads the input values `n`, `x`, `y`, and `z`. Then, it iterates over each cow, reading its temperature range `[a, b]`. For each cow, it checks if the optimal temperature is below `x` (in which case all milk produced is `x`), above `y` (in which case all milk produced is `z`), or within the comfortable range `[a, b]` (in which case the maximum milk produced is `y`). The total milk produced by all cows is then printed.", "time_gen": "\ntime generating: 6.964444s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=342": {"code": "```\npython\nN, K = map(int, input().split())\nadjectives = set()\nfor _ in range(N):\n    adjectives.update(adjs.strip(\"no the \").lower().split() for adjs in input().strip().replace(\"has no \", \"have not \").split(\".\")[0].split())\n\ncombinations = set()\nfor adjective in adjectives:\n    combinations.add(adjective)\n    if len(combinations) == 2 ** (adjectives.index(adjective) + 1):\n        break\n\ncombinations = sorted(list(combinations))\nprint(f\"large {' '.join(['brown' if i & 1 else 'white' for i in range(3)])} {combinations[K-1]} cow.\")\n```", "time_gen": "\ntime generating: 5.484686s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=343": {"code": "```\nN, K = map(int, input().split())\nadjectives = []\nfor _ in range(N):\n    line = input().strip()\n    words = line.split()\n    adjectives.append([word for word in words[6:-1] if word != 'no'])\n\nresult = ''\nfor adjective_set in set(tuple(sorted(adjective)) for adjective in product(*adjectives)):\n    result += (' ' + ' '.join(adjective) for adjective in zip(*adjective_set))[0]\n\nprint(result.split()[K-1])\n```", "time_gen": "\ntime generating: 4.476325s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=344": {"code": "```\nimport sys\n\nN, D = map(int, sys.stdin.readline().split())\n\ncows = []\nfor _ in range(N):\n    x, h = map(int, sys.stdin.readline().split())\n    cows.append((x, h))\n\ncrowded_cows = 0\nfor i in range(N):\n    left_count = right_count = 0\n    for j in range(i-1, -1, -1):\n        if abs(cows[j][0] - cows[i][0]) <= D and cows[j][1] >= cows[i][1]/2:\n            left_count += 1\n            break\n    for k in range(i+1, N):\n        if abs(cows[k][0] - cows[i][0]) <= D and cows[k][1] >= cows[i][1]/2:\n            right_count += 1\n            break\n    if left_count > 0 and right_count > 0:\n        crowded_cows += 1\n\nprint(crowded_cows)\n```", "time_gen": "\ntime generating: 5.939611s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=345": {"code": "Here is the Python solution for Problem 3: Pogo-Cow:\n```\ndef solve():\n    n = int(input())\n    targets = []\n    for _ in range(n):\n        x, p = map(int, input().split())\n        targets.append((x, p))\n    targets.sort()\n    dp = [0] * (targets[-1][0] + 2)\n    for i in range(1, len(dp)):\n        max_points = 0\n        for j in range(len(targets) - 1):\n            if targets[j][0] <= i:\n                max_points = max(max_points, dp[targets[j][0]] + targets[j][1])\n                break\n        dp[i] = max_points\n    return max(dp)\n\nprint(solve())\n```\nThis code reads in the target positions and values, sorts them by position, and then uses dynamic programming to calculate the maximum points that Bessie can receive.", "time_gen": "\ntime generating: 6.025504s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=346": {"code": "Here is the solution to the problem:\n\n```markdown\n```\n```python\ndef empty_stalls(N, K):\n    stalls = [0] * N\n    for _ in range(K):\n        x, y, a, b = map(int, input().split())\n        for i in range(x, y+1):\n            stalls[(a+i+b)%N] += 1\n    return min(i for i in range(N) if stalls[i] == 0)\n\nN, K = map(int, input().split())\nprint(empty_stalls(N, K))\n```", "time_gen": "\ntime generating: 5.896535s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=347": {"code": "```\n```\ndef line_of_sight():\n    n, r = [int(x) for x in input().split()]\n    cows = []\n    for _ in range(n):\n        x, y = [int(x) for x in input().split()]\n        cows.append((x, y))\n\n    count = 0\n    for i in range(len(cows)):\n        for j in range(i+1, len(cows)):\n            dx = abs(cows[i][0] - cows[j][0])\n            dy = abs(cows[i][1] - cows[j][1])\n            if (dx == 0 and dy > r) or (dy == 0 and dx > r):\n                continue\n            if (cows[i][0]**2 + cows[i][1]**2)**0.5 + (cows[j][0]**2 + cows[j][1]**2)**0.5 <= 2*r:\n                count += 1\n\n    print(count)\n```\n```\n\nNote: This code is written in Python and solves the problem as described.", "time_gen": "\ntime generating: 7.824611s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=348": {"code": "```\nimport heapq\n\ndef no_change(k, n, c, p):\n    # Initialize priority queue for coins\n    heap = [(v, i) for i, v in enumerate(c)]\n    heapq.heapify(heap)\n\n    # Initialize maximum amount of money FJ can end up with\n    max_amount = 0\n\n    for x in p:\n        while True:\n            # Get the largest coin that is greater than or equal to the purchase cost\n            while heap and -heap[0][0] < x:\n                v, i = heapq.heappop(heap)\n                if v >= x:\n                    max_amount += v - x\n                    break\n                else:\n                    max_amount -= (v + 1) - x\n            # If no such coin is found, FJ cannot make the purchase\n            if not heap:\n                return -1\n    return max_amount\n\nk = int(input())\nn = int(input())\nc = [int(input()) for _ in range(k)]\np = [int(input()) for _ in range(n)]\n\nprint(no_change(k, n, c, p))", "time_gen": "\ntime generating: 7.33172s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=358": {"code": "```\nfrom collections import Counter\n\nn = int(input())\ncow_lists = [input().split() for _ in range(n)]\n\ndef record_group(cow_lists):\n    groups = [tuple(sorted(group)) for group in cow_lists]\n    return max(Counter(groups).values())\n\nprint(record_group(cow_lists))\n```", "time_gen": "\ntime generating: 2.863831s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=359": {"code": "Here is the Python code for the problem:\n```\nn = int(input())\ncows = list(map(int, input().split()))\ncounts = [0] * 1001\nfor i in range(2, n):\n    counts[cows[i-1]] += 1\n    for j in range(i+1, n):\n        if cows[j-1] - cows[i-1] <= 200000000 and cows[j-1] - cows[i-1] >= 1:\n            print(counts[i-1])\n```\nThis code reads the input file line by line. It first reads the number of cows `n`, then reads the positions of all cows. Then it counts the number of possible triples (X, Y, Z) for each cow i, considering only cows with positions between `i-1` and 200000000.", "time_gen": "\ntime generating: 5.554441s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=360": {"code": "```\ndef count_wormhole_pairs(wormholes):\n    x_coords = [int(x) for x, _ in wormholes]\n    y_coords = [int(y) for _, y in wormholes]\n\n    min_x = min(x_coords)\n    max_x = max(x_coords)\n    min_y = min(y_coords)\n    max_y = max(y_coords)\n\n    pairs = 0\n    for i in range(0, len(wormholes), 2):\n        x1, y1 = wormholes[i]\n        x2, y2 = wormholes[i + 1]\n\n        if (x1 == min_x or x1 == max_x) and (y1 == min_y or y1 == max_y):\n            pairs += 1\n\n    return pairs\n\n\nif __name__ == \"__main__\":\n    N = int(input())\n    wormholes = []\n    for _ in range(N):\n        wormhole = input().split()\n        wormhole = [int(x) for x in wormhole]\n        wormholes.append(wormhole)\n\n    print(count_wormhole_pairs(wormholes))\n```", "time_gen": "\ntime generating: 8.413615s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=361": {"code": "Here is a Python solution for the problem:\n```\nn = int(input())\nmilk_gallons = []\ndeadlines = []\nfor i in range(n):\n    g, d = map(int, input().split())\n    milk_gallons.append(g)\n    deadlines.append(d)\n\nmilk_gallons.sort()\ndeadlines.sort()\n\ni = j = 0\nmax_milk = 0\n\nwhile i < n and j < n:\n    if deadlines[j] >= i + 1:\n        max_milk += milk_gallons[i]\n        i += 1\n    else:\n        j += 1\n\nprint(max_milk)\n```", "time_gen": "\ntime generating: 4.798133s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=362": {"code": "```\npython\n```vacation.py\nN, M, K, Q = map(int, input().split())\ngraph = {}\nfor i in range(M):\n    u, v, d = map(int, input().split())\n    if u not in graph:\n        graph[u] = []\n    if v not in graph:\n        graph[v] = []\n    graph[u].append((v, d))\n    graph[v].append((u, d))\n\ndef dfs(farm, visited, path_cost):\n    for neighbor, cost in graph[farm]:\n        if neighbor == K:  # we've reached a hub\n            return min(dfs(hub, set(visited + [hub]), path_cost + cost) for hub in graph[neighbor] if hub not in visited)\n        elif neighbor not in visited:\n            new_path_cost = path_cost + cost\n            result = dfs(neighbor, visited + [neighbor], new_path_cost)\n            if result is not None:\n                return min(result, new_path_cost)\n    return None\n\ntotal_trips = 0\ntotal_route_cost = 0\nfor i in range(Q):\n    start, end = map(int, input().split())\n    route_cost = dfs(start, [start], 0) if end != K else dfs(end, [end], 0)\n    if route_cost is not None:\n        total_trips += 1\n        total_route_cost += route_cost\n\nprint(total_trips)\nprint(total_route_cost)\n```", "time_gen": "\ntime generating: 11.676163s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=363": {"code": "```\ndef shuffle(N, M, Q):\n    cards = list(range(1, N+1))\n    top_cards = []\n    for _ in range(M):\n        for i in range(len(cards)-1, -1, -1):\n            if i >= len(cards) // 2:\n                cards[i], cards[len(cards) - 1] = cards[len(cards) - 1], cards[i]\n                top_cards.append(cards.pop())\n            else:\n                cards[0], cards[i] = cards[i], cards[0]\n                cards.pop(0)\n        if len(top_cards):\n            top_cards[-1].pop(0)\n\n    result = []\n    for _ in range(Q):\n        query_pos = int(input())\n        result.append(cards[query_pos-1])\n\n    return '\\n'.join(map(str, result))\n\nN, M, Q = map(int, input().split())\nprint(shuffle(N, M, Q))\n```", "time_gen": "\ntime generating: 8.067687s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=364": {"code": "```\npython\nN, M, K, Q = map(int, input().split())\ngraph = [[] for _ in range(N+1)]\nfor i in range(M):\n    u, v, d = map(int, input().split())\n    graph[u].append((v, d))\n    graph[v].append((u, d))\n\nhubs = set()\nfor i in range(K):\n    hubs.add(int(input()))\n\ndp = [[float('inf')] * (N+1) for _ in range(N+1)]\nfor a in range(1, N+1):\n    dp[a][a] = 0\nfor a in range(1, N+1):\n    for b, d in graph[a]:\n        if a != b:\n            for c in range(b+1, N+1):\n                if (c, d) not in graph[b]:\n                    dp[a][c] = min(dp[a][c], dp[a][b] + d)\n\nrequests = []\nfor i in range(Q):\n    a, b = map(int, input().split())\n    requests.append((a, b))\n\npossible_requests = 0\nmin_cost = float('inf')\nfor a, b in requests:\n    if (dp[a][b] != float('inf')):\n        possible_requests += 1\n        min_cost = min(min_cost, dp[a][b])\n\nprint(possible_requests)\nprint(min_cost)\n```", "time_gen": "\ntime generating: 9.934894s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=365": {"code": "```\n```\n```python\nn, d = map(int, input().split())\nmilk = list(map(int, input().split()))\nfor _ in range(d):\n    i, m = map(int, input().split())\n    milk[i-1] = m\n\ndp = [[0, 0]] * (d + 1)\nfor day in range(1, d + 1):\n    for j in range(min(day+1, n+1)):\n        if j == 0:\n            dp[day][j] = max(dp[day-1][j], sum(milk[:i]))\n        elif j < i:\n            dp[day][j] = dp[day-1][j]\n        else:\n            dp[day][j] = max(dp[day-1][j], dp[day-1][j-2] + milk[i-1])\nprint(int(max(dp[-1])))\n```\n```", "time_gen": "\ntime generating: 7.330855s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=366": {"code": "```\n```\n```\n```", "time_gen": "\ntime generating: 3.167971s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=376": {"code": "Here is the Python code for the problem:\n```\nn = int(input())\nhills = list(map(int, input().split() for _ in range(n)))\n\n# Calculate the maximum and minimum heights\nmax_height = max(hills)\nmin_height = min(hills)\n\ndiff = max_height - min_height\n\ncost = 0\nwhile diff > 17:\n    if diff % 2 == 1:\n        cost += (diff // 2 + 1) ** 2\n        diff -= (diff // 2 + 1) * 2\n    else:\n        cost += (diff // 2) ** 2\n        diff -= diff // 2 * 2\n\nprint(cost)\n```", "time_gen": "\ntime generating: 5.630964s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=377": {"code": "```\npython\nN = int(input())\ntime = 0\nspeed = 1\nfor _ in range(N):\n    event = input().split()\n    if event[0] == 'T':\n        time += int(event[1])\n    elif event[0] == 'D':\n        time += (int(event[1]) * speed) / sum(range(1, speed+1))\n        speed //= sum(range(1, speed+1))\nprint(time)\n```", "time_gen": "\ntime generating: 4.874844s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=378": {"code": "Here is the solution:\n```\ntotal_skill = sum(map(int, open('input.txt', 'r').read().strip().split('\\n')))\nmin_diff = total_skill // 4\nmax_diff = (total_skill - min_diff) // 3\nwhile max_diff > min_diff:\n    max_diff -= 1\nprint(min_diff)\n```", "time_gen": "\ntime generating: 3.353463s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=379": {"code": "```\npython\nimport sys\n\ndef slowdown(events):\n    distance = 0\n    speed = 1\n    time = 0\n    for event in events:\n        if 'T' in event:\n            time += int(event.split()[1])\n        elif 'D' in event:\n            distance += int(event.split()[1]) * speed\n            speed /= 2\n        if distance >= 1000:\n            break\n    return round(time + (distance - 1000) * speed)\n\nN = int(sys.stdin.readline())\nevents = []\nfor _ in range(N):\n    events.append(sys.stdin.readline().strip())\n\nprint(slowdown(events))\n```", "time_gen": "\ntime generating: 6.375377s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=380": {"code": "```\n```\n```\n```\n\n```python\nfrom collections import deque\n\ndef ccski():\n    M, N = map(int, input().split())\n    grid_elevations = [list(map(int, input().split())) for _ in range(M)]\n    grid_waypoints = [[int(x) for x in input().split()] for _ in range(M)]\n\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n\ndef bfs(row, col, D):\n    visited = [[False] * N for _ in range(M)]\n    queue = deque([(row, col)])\n\n    while queue:\n        r, c = queue.popleft()\n        if visited[r][c]:\n            continue\n        visited[r][c] = True\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < M and 0 <= nc < N and grid_elevations[nr][nc] - grid_elevations[r][c] <= D:\n                if grid_waypoints[nr][nc]:\n                    return True\n                queue.append((nr, nc))\n\n    return False\n\n\ndef solve():\n    min_D = float('inf')\n    for r in range(M):\n        for c in range(N):\n            if grid_waypoints[r][c]:\n                for d in range(1, 1000001):  # D <= M x N\n                    if bfs(r, c, d):\n                        min_D = min(min_D, d)\n                        break\n\n    return min_D\n\n\nprint(solve())\n```", "time_gen": "\ntime generating: 11.135766s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=381": {"code": "Here is the Python solution for the problem:\n```\nimport sys\n\nn = int(sys.stdin.readline())\ntimes = []\nfor i in range(n):\n    start, end = map(int, sys.stdin.readline().split())\n    times.append((start, 1))  # mark as program 1\n    times.append((end, -1))   # mark as program end\n\ntimes.sort()\nlast_start = 0\nrecording_count = 0\nfor time, delta in times:\n    if delta == 1:\n        last_start = time\n        recording_count += 1\n    elif delta == -1:\n        recording_count -= 1\n\nprint(recording_count)\n```", "time_gen": "\ntime generating: 4.761105s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=382": {"code": "Here is the Python code for the problem:\n```\nn = int(input())\nteam_a_stones = []\nteam_b_stones = []\n\nfor i in range(n):\n    a_x, a_y = map(int, input().split())\n    team_a_stones.append((a_x, a_y))\n\nfor i in range(n, 2*n):\n    b_x, b_y = map(int, input().split())\n    team_b_stones.append((b_x, b_y))\n\ndef is_point_inside_triangle(p1, p2, p3, x, y):\n    v1 = (x - p1[0], y - p1[1])\n    v2 = (p2[0] - p1[0], p2[1] - p1[1])\n    v3 = (p3[0] - p1[0], p3[1] - p1[1])\n\n    if ((v1[0]*v2[1] - v1[1]*v2[0]) + (v2[0]*v3[1] - v2[1]*v3[0]) + (v3[0]*v1[1] - v3[1]*v1[0])) % 4 == 0:\n        return True\n    else:\n        return False\n\nscore_a = 0\nscore_b = 0\n\nfor stone in team_b_stones:\n    if is_point_inside_triangle(min(team_a_stones, key=lambda p: (p[0]**2 + p[1]**2)), \n                                  max(team_a_stones, key=lambda p: (p[0]**2 + p[1]**2)), \n                                  (min(team_a_stones, key=lambda p: p[0]), min(team_a_stones, key=lambda p: p[1])), \n                                  stone[0], stone[1]):\n        score_b += 1\n    if is_point_inside_triangle(min(team_b_stones, key=lambda p: (p[0]**2 + p[1]**2)), \n                                  max(team_b_stones, key=lambda p: (p[0]**2 + p[1]**2)), \n                                  (min(team_b_stones, key=lambda p: p[0]), min(team_b_stones, key=lambda p: p[1])), \n                                  stone[0], stone[1]):\n        score_a += 1\n\nprint(f\"{score_a} {score_b}\")\n```", "time_gen": "\ntime generating: 15.501134s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=383": {"code": "Here is the Python code for the problem:\n```\nM, N = [int(x) for x in input().split()]\ndesired_course = [list(input()) for _ in range(M)]\n\ndef find_max_b(desired_course):\n    max_b = 0\n    for i in range(len(desired_course)):\n        for j in range(len(desired_course[i])):\n            rough_neighbors = 0\n            smooth_neighbors = 0\n            if i > 0 and desired_course[i-1][j] == 'R':\n                rough_neighbors += 1\n            if i < len(desired_course) - 1 and desired_course[i+1][j] == 'R':\n                rough_neighbors += 1\n            if j > 0 and desired_course[i][j-1] == 'R':\n                rough_neighbors += 1\n            if j < len(desired_course[i]) - 1 and desired_course[i][j+1] == 'R':\n                rough_neighbors += 1\n            if i > 0 and desired_course[i-1][j] == 'S':\n                smooth_neighbors += 1\n            if i < len(desired_course) - 1 and desired_course[i+1][j] == 'S':\n                smooth_neighbors += 1\n            if j > 0 and desired_course[i][j-1] == 'S':\n                smooth_neighbors += 1\n            if j < len(desired_course[i]) - 1 and desired_course[i][j+1] == 'S':\n                smooth_neighbors += 1\n            if rough_neighbors > 0 and smooth_neighbors > 0:\n                max_b = max(max_b, min(rough_neighbors, smooth_neighbors))\n    return max_b\n\nprint(find_max_b(desired_course))\n```\nThis code reads in the desired course design from input, then uses a brute force approach to find the maximum value of B that can be used to create the desired course. The maximum value is determined by finding the minimum number of rough or smooth patches that are needed to create the desired course.", "time_gen": "\ntime generating: 13.57328s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=384": {"code": "Here is the solution to the problem:\n```\nM = int(input())\nN = int(input())\nT = int(input())\n\ngrid_elevations = [list(map(int, input().split())) for _ in range(M)]\nstart_points = [[int(x) for x in input().split()] for _ in range(M)]\n\ndef dfs(i, j, D):\n    if i < 0 or i >= M or j < 0 or j >= N:\n        return float('inf')\n    if start_points[i][j] == 1:\n        return 0\n    if grid_elevations[i][j] > 100000000:\n        return float('inf')\n    return min(dfs(i-1, j, D), dfs(i+1, j, D), dfs(i, j-1, D), dfs(i, j+1, D)) + (abs(grid_elevations[i][j]) - abs(D))\n\ndifficulty_ratings = [dfs(i, j, 0) for i in range(M) for j in range(N) if start_points[i][j] == 1]\nprint(sum(difficulty_ratings))\n```\nNote: This code assumes that the input is a Python file named `skilevel.in` and the output should be written to a file named `skilevel.out`.", "time_gen": "\ntime generating: 8.824847s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=394": {"code": "```\n```python\nn, m = map(int, input().split())\nmirrors = []\nfor _ in range(n):\n    mirrors.append(list(input()))\n\nmax_mirrors = 0\nfor i in range(n):\n    for j in range(m):\n        if mirrors[i][j] == '/':\n            max_mirrors += 1\n        else:\n            max_mirrors -= 1\n\nprint(max_mirrors)\n```", "time_gen": "\ntime generating: 3.962784s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=395": {"code": "```\ndef auto_complete():\n    W, N = map(int, input().split())\n    words = set()\n    \n    for _ in range(W):\n        word = input()\n        words.add(word)\n        \n    for _ in range(N):\n        K, partial_word = input().split()\n        K = int(K)\n        \n        completions = [word for word in words if word.startswith(partial_word)]\n        completions.sort()\n        \n        if len(completions) < K:\n            print(-1)\n        else:\n            print(completions[K-1].index(partial_word)+1)\n\nauto_complete()", "time_gen": "\ntime generating: 5.187134s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=396": {"code": "Here is the Python code for Problem 3: Secret Code:\n```\ndef scode(input_string):\n    n = len(input_string)\n    if n == 0 or n % 2 != 0:\n        return 0\n    res = 1\n    for i in range(1, n // 2 + 1):\n        if input_string[i:] + input_string[:i] == input_string:\n            res *= (n - i) * i\n    return res\n\nwith open(\"scode.in\", \"r\") as f:\n    s = f.readline().strip()\n\nprint(scode(s))\n```\nNote: This code assumes that the input file `scode.in` contains the secret message in a single line, and the output should be written to the console.", "time_gen": "\ntime generating: 5.690209s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=397": {"code": "Here is the Python solution for the problem:\n```\nimport sys\n\nW, N = map(int, input().split())\nwords = set()\nfor _ in range(W):\n    words.add(input())\n\nfor _ in range(N):\n    k, partial = input().split()\n    k = int(k)\n    completions = [word for word in words if word.startswith(partial)]\n    completions.sort()\n    try:\n        print(completions[k-1].index(partial) + 1)\n    except IndexError:\n        print(-1)\n```", "time_gen": "\ntime generating: 4.722228s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=398": {"code": "```\n```\n\n```python\nimport sys\n\ndef find_max_increase(n, m):\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    parent = [[-1] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        dp[i][i] = 0\n\n    for j in range(m):\n        a, b, length = map(int, sys.stdin.readline().split())\n        if dp[a][b] == 0:\n            for k in range(a + 1, b):\n                if parent[k][a] == -1:\n                    parent[k][a] = k\n                dp[b][k] = max(dp[b][k], dp[a][b] + length)\n        else:\n            for k in range(b + 1, a, -1):\n                if parent[k][b] == -1:\n                    parent[k][b] = k\n                dp[k][a] = min(dp[k][a], dp[b][k] + length)\n\n    max_increase = 0\n    for i in range(1, n):\n        for j in range(i + 1, n + 1):\n            max_increase = max(max_increase, dp[i][j])\n\n    return max_increase\n\n\nn, m = map(int, sys.stdin.readline().split())\nprint(find_max_increase(n, m))\n```", "time_gen": "\ntime generating: 11.091003s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=399": {"code": "Here is the Python solution for the problem:\n```markdown\n```\npython\ndef scode():\n    s = input()\n    n = len(s)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dp[i][i] = 1\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 1\n            else:\n                dp[i][j] = dp[i][j - 1] + dp[i + 1][j]\n    print(dp[0][n - 1] % 2014)\n```\n```", "time_gen": "\ntime generating: 7.475731s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=400": {"code": "```\n```python\ndef roadblock():\n    N, M = map(int, input().split())\n    paths = []\n    for _ in range(M):\n        a, b, length = map(int, input().split())\n        paths.append((a, b, length))\n\n    graph = [[] for _ in range(N+1)]\n    for path in paths:\n        a, b, length = path\n        graph[a].append((b, length))\n        graph[b].append((a, length))\n\n    visited = set()\n    dp = [float('inf')] * (N + 1)\n    dp[0] = 0\n\n    def dfs(node):\n        if node in visited:\n            return dp[node]\n        visited.add(node)\n        for neighbor, length in graph[node]:\n            dp[node] = min(dp[node], dfs(neighbor) + length)\n        return dp[node]\n\n    max_increase = 0\n    for i in range(N - 1):\n        increase = float('inf')\n        for path in paths:\n            a, b, original_length = path\n            if a == i + 1 and b == i + 2:  # This is the current edge\n                new_length = original_length * 2\n                new_path_length = dfs(i + 2) - length + new_length\n                increase = min(increase, new_path_length)\n        max_increase = max(max_increase, increase)\n\n    print(max_increase)\n```\n```", "time_gen": "\ntime generating: 11.450938s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=401": {"code": "Here is the Python solution for the problem:\n```markdown\n```\n```python\nimport sys\n\ndef solve():\n    N, B = map(int, input().split())\n    bonuses = []\n    for _ in range(B):\n        K, P, A = map(int, input().split())\n        bonuses.append((K, P, A))\n\n    cows = []\n    for _ in range(N):\n        skills = list(map(int, input().split()))\n        cows.append(skills)\n\n    dp = [[0] * (B + 1) for _ in range(2**N)]\n    for i in range(B + 1):\n        if i == 0:\n            continue\n        K, P, A = bonuses[i - 1]\n        for j in range(N):\n            for k in range(B):\n                dp[2**j][i] = max(dp[2**(j-1)][k] + cows[j][k], dp[2**j][k] + A)\n\n    return max(max(row) for row in dp)\n\nprint(solve())\n```\nThis code uses dynamic programming to find the maximum score that the cows can achieve. It iterates over each bonus and each possible combination of events, keeping track of the maximum score achieved so far. The final answer is the maximum score obtained from all possible combinations.", "time_gen": "\ntime generating: 11.113539s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=402": {"code": "```\npython\nN = int(input())\nseats = list(map(int, input().split()))\ntime_taken = 0\nseat_taken = [False] * N\n\nfor i in range(N):\n    while seats[i] < 1:\n        time_taken += 1\n        for j in range(i+1, N):\n            if not seat_taken[j]:\n                seats[j] -= 1\n        seats[i] += 1\n    time_taken += sum(seats[:i])\n    for i in range(N):\n        seat_taken[seats[i]-1] = True\n\nprint(time_taken)\n```", "time_gen": "\ntime generating: 5.692745s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=412": {"code": "Here is a Python solution for the problem:\n```\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nshifts = 0\nmax_shift_length = 0\n\ni = 0\nwhile i < n:\n    if a[i] == b[i]:\n        i += 1\n    else:\n        j = i + 1\n        while j < n and a[j] != b[i]:\n            j += 1\n        if j < n:\n            shifts += 1\n            max_shift_length = max(max_shift_length, j - i)\n        i = j\n\nprint(shifts, max_shift_length if shifts > 0 else -1)\n```", "time_gen": "\ntime generating: 6.375239s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=413": {"code": "```\nfrom bisect import bisect_left\n\nn, k = map(int, input().split())\npatches = []\nfor _ in range(n):\n    g, x = map(int, input().split())\n    patches.append((x, -g))\npatches.sort()\n\nans = 0\ntotal = 0\nleft = 0\nfor right in range(len(patches)):\n    while total + patches[right][1] > k and left < right:\n        total -= patches[left][1]\n        left += 1\n    if left <= right:\n        ans = max(ans, total + patches[right][1])\nprint(ans)\n```", "time_gen": "\ntime generating: 5.034979s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=414": {"code": "```\ndef cow_art(n):\n    regions_human = 0\n    regions_cow = 0\n    \n    for i in range(n):\n        prev_color = None\n        current_regions_human = 1\n        current_regions_cow = 1\n        \n        for j in range(n):\n            if (j > 0 and ((prev_color == 'R' and grid[i][j] in ['G', 'B']) or \n                           (prev_color == 'G' and grid[i][j] in ['R', 'B']) or\n                           (prev_color == 'B' and grid[i][j] in ['R', 'G']))):\n                if prev_color == 'R':\n                    current_regions_human -= 1\n                elif prev_color == 'G':\n                    current_regions_cow -= 1\n                else:\n                    current_regions_cow -= 1\n            elif (j < n - 1 and ((grid[i][j] in ['R', 'B'] and grid[i][j+1] in ['G']) or \n                                  (grid[i][j] in ['G'] and grid[i][j+1] in ['R']))):\n                if grid[i][j] == 'R':\n                    current_regions_human += 1\n                elif grid[i][j] == 'G':\n                    current_regions_cow += 1\n            \n            prev_color = grid[i][j]\n        \n        regions_human += current_regions_human\n        regions_cow += current_regions_cow\n    \n    return f\"{regions_human} {regions_cow}\"\n\n\nn = int(input())\ngrid = [input() for _ in range(n)]\n\nprint(cow_art(n))\n```", "time_gen": "\ntime generating: 10.639996s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=415": {"code": "```\nimport sys\n\ndef read_input():\n    N, C = map(int, raw_input().split())\n    fields = []\n    for _ in range(N):\n        x, y = map(int, raw_input().split())\n        fields.append((x, y))\n    return N, C, fields\n\ndef distance(p1, p2):\n    return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n\ndef kruskal(N, C, fields):\n    edges = []\n    for i in range(N):\n        for j in range(i+1, N):\n            edge = ((fields[i][0]-fields[j][0])**2 + (fields[i][1]-fields[j][1])**2, i, j)\n            if edge[0] >= C:\n                edges.append(edge)\n    edges.sort()\n\n    parent = dict((i, i) for i in range(N))\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    mst_cost = 0\n    for edge in edges:\n        u, v = edge[1], edge[2]\n        if find(u) != find(v):\n            parent[find(v)] = find(u)\n            mst_cost += edge[0]\n    if any(find(i) != find(0) for i in range(N)):\n        return -1\n    else:\n        return mst_cost\n\nN, C, fields = read_input()\nprint(kruskal(N, C, fields))\n```", "time_gen": "\ntime generating: 10.561557s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=416": {"code": "```\ndef lazy_cow():\n    N, K = map(int, input().split())\n    G = [list(map(int, input().split())) for _ in range(N)]\n    \n    dp = [[0]*N for _ in range(N)]\n    max_grass = 0\n    \n    for r in range(N):\n        for c in range(N):\n            if K > 0:\n                for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nr, nc = r+dr, c+dc\n                    if 0 <= nr < N and 0 <= nc < N and K > abs(dr)+abs(dc):\n                        dp[r][c] = max(dp[r][c], G[nr][nc]+dp[nr][nc])\n            else:\n                dp[r][c] = G[r][c]\n            \n            max_grass = max(max_grass, dp[r][c])\n    \n    print(max_grass)\n```\nTo run this code, you can save it in a file named `lazy.py`, then execute it using Python: `python lazy.py`. You can also input the sample data and see the output.", "time_gen": "\ntime generating: 8.550396s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=417": {"code": "```\n```\n```\n```python\ndef mooomoo():\n    N, B = map(int, input().split())\n    V = list(map(int, input() for _ in range(B)))\n    A = list(map(int, input() for _ in range(N)))\n    \n    dp = [0] * (N + 1)\n    for i in range(1, N + 1):\n        for j in range(B):\n            if V[j] <= A[i - 1]:\n                dp[i] = max(dp[i], dp[i - 1])\n            else:\n                dp[i] = max(dp[i], dp[i - 1] + 1)\n    \n    return min(N, min(dp)) if any(dp) else -1\n\nprint(mooomoo())\n```", "time_gen": "\ntime generating: 6.476373s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=418": {"code": "```\nimport math\n\ndef lazy_cow(n, k):\n    grasses = []\n    for _ in range(n):\n        g, x, y = map(int, input().split())\n        grasses.append((g, x, y))\n\n    max_grass = 0\n    for i in range(2000001):  # brute force search\n        for j in range(2000001):\n            total_grass = sum(g if math.hypot(i-x, j-y) <= k else 0 for g, x, y in grasses)\n            max_grass = max(max_grass, total_grass)\n\n    return max_grass\n\nn, k = map(int, input().split())\nprint(lazy_cow(n, k))\n```", "time_gen": "\ntime generating: 6.315081s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=419": {"code": "```python\ndef sabotage():\n    N = int(input())\n    milk_production = [0] * (N + 1)\n    for i in range(1, N + 1):\n        milk_production[i] = int(input())\n\n    total_milk = sum(milk_production[1:N-1])\n    min_avg = float('inf')\n    \n    left = right = 0\n    curr_sum = 0\n    for i in range(1, N - 1):\n        curr_sum += milk_production[i]\n        if i >= right:\n            right = i\n            while right + 1 <= N and curr_sum / (right - left + 1) < min_avg:\n                curr_sum -= milk_production[left]\n                left += 1\n            if i == right:\n                total_milk -= milk_production[right]\n            else:\n                total_milk -= milk_production[right] - milk_production[left]\n        if i >= N // 2 and (i == right or i < left):\n            min_avg = min(min_avg, curr_sum / (right - left + 1))\n    \n    avg = total_milk / (N - 2)\n    print(f\"{avg:.3f}\")\n```\nNote: The problem name is \"sabotage\" and the input format consists of N followed by a list of milk production for each machine.", "time_gen": "\ntime generating: 8.750474s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=420": {"code": "```\npython\nN = int(input())\nfriends = list(map(int, input().split() for _ in range(N)))\n\ncounts = {}\nfor friend in friends:\n    if friend in counts:\n        counts[friend] += 1\n    else:\n        counts[friend] = 1\n\ntotal_friends = sum(friends)\nodd = False\nfor count in counts.values():\n    if count % 2 != 0:\n        odd = True\n        break\n\nif not odd:\n    K = len([k for k, v in counts.items() if v == 1])\nelse:\n    K = total_friends - N*(N-1)//2\n\nprint(K)\npossible_friends = [i+1 for i in range(N) if friends[i] in counts and counts[friends[i]] == 1]\nprint(*possible_friends, sep='\\n')\n```", "time_gen": "\ntime generating: 6.739923s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=430": {"code": "Here is the Python solution for the problem:\n```\ndef odometer():\n    x, y = map(int, input().split())\n    count = 0\n    for i in range(x+1, y):\n        str_i = str(i)\n        if len(set(str_i.lstrip('0'))) == 1:\n            count += 1\n    print(count)\n\nodometer()\n```\nThis code reads the input values of `x` and `y`, then iterates over all numbers in the range from `x+1` to `y`. For each number, it converts the integer to a string, strips off leading zeros using the `lstrip('0')` method, and then uses the `set` data structure to get the unique digits. If there is only one unique digit (i.e., all digits are the same except for one), it increments the count. Finally, it prints out the total count of mooing events.", "time_gen": "\ntime generating: 6.44194s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=431": {"code": "```\n*problem_name: fairphoto*\n\n**input**\nN = int(input())\n\ncows = []\nfor i in range(N):\n    x, b = map(str, input().split())\n    cows.append((int(x), b))\n\n**solution**\nmax_size = 0\nleft = 0\ncount_guernsey = count_holstein = 0\n\nfor right in range(len(cows)):\n    if cows[right][1] == 'G':\n        count_guernsey += 1\n    else:\n        count_holstein += 1\n\n    while count_guernsey > count_holstein and left <= right:\n        if cows[left][1] == 'G':\n            count_guernsey -= 1\n        else:\n            count_holstein -= 1\n        left += 1\n\n    max_size = max(max_size, right - left + 1)\n\n**output**\nprint(max_size)\n```", "time_gen": "\ntime generating: 6.816582s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=432": {"code": "```\ndef decorate():\n    n, m = map(int, input().split())\n    graph = [[] for _ in range(n+1)]\n    \n    for _ in range(m):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    visited = [0] * (n + 1)\n    connected_components = 0\n    \n    for i in range(1, n+1):\n        if visited[i] == 0:\n            dfs(graph, visited, i)\n            connected_components += 1\n    \n    return max(0, connected_components - 1)\n\n\ndef dfs(graph, visited, node):\n    visited[node] = 1\n    for neighbor in graph[node]:\n        if visited[neighbor] == 0:\n            dfs(graph, visited, neighbor)\n\n\nif __name__ == \"__main__\":\n    print(decorate())\n```", "time_gen": "\ntime generating: 6.949807s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=433": {"code": "```\npython\nn = int(input())\npositions = []\nfor _ in range(n):\n    x, cow = input().split()\n    positions.append(int(x))\n    cow = cow[0]  # W or S\n    if cow == 'W':\n        is_spotted = False\n    else:\n        is_spotted = True\n\npositions.sort()\n\nwhite_cows = [i for i, (x, c) in enumerate(positions) if x == w and not c]\nspotted_cows = [i for i, (x, c) in enumerate(positions) if x == s]\n\nmin_position = positions[0]\nmax_position = positions[-1]\n\ntotal_spotted = sum(1 for _ in spotted_cows)\ntotal_white = len(white_cows)\n\nmin_spots = min(total_spotted, total_white)\nspots_to_add = max_spots - min_spots\n\nprint(max_position - min_position + 1 + spots_to_add)\n```", "time_gen": "\ntime generating: 7.111515s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=434": {"code": "```\npython\n```\n\n```markdow\nfrom heapq import heappop, heapreplace, heapify\ndef solve():\n    N, M = map(int, input().split())\n    graph = [[] for _ in range(N+1)]\n    times = [list(map(int, input().split())) for _ in range(M)]\n    for i, (A, B, P, Q) in enumerate(times):\n        graph[A].append((B, P))\n        graph[B].append((A, Q))\n\n    def dijkstra(start, end):\n        heap = [(0, start)]  # (time, intersection)\n        distances = [float('inf')] * (N+1)\n        distances[start] = 0\n        while heap:\n            time, node = heappop(heap)\n            if time > distances[node]:\n                continue\n            for neighbor, t in graph[node]:\n                new_time = time + t\n                if new_time < distances[neighbor]:\n                    distances[neighbor] = new_time\n                    heapreplace(heap, (new_time, neighbor))\n        return distances[end]\n\n    total_complaints = 0\n    for i in range(N):\n        start = 1\n        end = N\n        dist1, dist2 = dijkstra(start, i), dijkstra(i, end)\n        if dist1 != float('inf') and dist2 != float('inf'):\n            total_complaints += min(dist1, dist2) - (dist1 + dist2) // 2\n\n    print(total_complaints)\n```", "time_gen": "\ntime generating: 11.543983s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=435": {"code": "Here is the Python code to solve this problem:\n```\nx, y = map(int, input().split())\ncount = 0\nfor i in range(x+1, y):\n    digits = str(i)\n    if len(digits) % 2 == 1:\n        digits = digits[1:]\n    same = set(digits[0])\n    for d in digits:\n        same &= set(d)\n    if len(same) >= len(set(digits)) // 2:\n        count += 1\nprint(count + 2)\n```\nThis code takes the input `x` and `y` as integers, then loops through all numbers from `x+1` to `y`. For each number, it checks if at least half of its digits are the same. If so, it increments a counter. Finally, it prints the total count plus 2 (for the start and end points of the trip).", "time_gen": "\ntime generating: 6.205759s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=436": {"code": "```\ndef solve():\n    n, k = map(int, input().split())\n    breeds = {}\n    for _ in range(n):\n        x, b = map(int, input().split())\n        if b not in breeds:\n            breeds[b] = []\n        breeds[b].append(x)\n\n    max_size = -1\n    for breed, positions in breeds.items():\n        if len(positions) < k:\n            continue\n        positions.sort()\n        max_size = max(max_size, positions[-1] - positions[0])\n\n    print(max_size)\n\n\nif __name__ == \"__main__\":\n    solve()\n```", "time_gen": "\ntime generating: 5.438519s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=437": {"code": "```\nimport math\n\ndef get_possible_locations(n, bx, by, mirrors):\n    possible_locations = set()\n\n    for i in range(1, n + 1):\n        mirror_x, mirror_y, orientation = eval(\"({})\".format(mirrors[i]))\n\n        if orientation == '\\\\':\n            if mirror_y < by:\n                possible_locations.add((bx - (by - mirror_y), by))\n        elif orientation == '/':\n            if mirror_y > by:\n                possible_locations.add((bx + (mirror_y - by), by))\n\n    return len(possible_locations)\n\nn, bx, by = map(int, input().split())\nmirrors = []\nfor i in range(n):\n    mirrors.append(input().split())\n\nprint(get_possible_locations(n, bx, by, mirrors))\n```", "time_gen": "\ntime generating: 6.429132s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=438": {"code": "Here is the Python solution for the problem:\n```\nN, M = map(int, input().split())\nparent = [0] * N\nfor i in range(N-1):\n    parent[i+1] = int(input()) - 1\n\nrouted_out = set()\nfor _ in range(M):\n    v, s = input().split()\n    v, s = int(v), int(s)\n    for i in range(4):\n        routed_out.add(int(s) * (10 ** (3-i)) + parent[v])\n\nprint(len(routed_out) % 1234567)\n```", "time_gen": "\ntime generating: 5.468168s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=487": {"code": "Here is the Python solution:\n```\ndef min_distance(file_name):\n    with open(file_name, 'r') as f:\n        N = int(f.readline())\n        checkpoints = []\n        for _ in range(N):\n            x, y = map(int, f.readline().split())\n            checkpoints.append((x, y))\n\n    min_distance = float('inf')\n    for i in range(1, N - 1):\n        total_distance = 0\n        for j in range(N):\n            if j == i:\n                continue\n            dx = abs(checkpoints[i][0] - checkpoints[j][0])\n            dy = abs(checkpoints[i][1] - checkpoints[j][1])\n            total_distance += dx + dy\n        min_distance = min(min_distance, total_distance)\n\n    print(min_distance)\n```\nYou can run this code by saving it in a file named `marathon.py` and then running it with the command `python marathon.py marathon.in`. This will output the minimum distance that Bessie can run by skipping up to one checkpoint.", "time_gen": "\ntime generating: 7.859258s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=488": {"code": "```\npython\n```python\ndef get_clue_numbers(filename):\n    with open(filename, 'r') as f:\n        n, m = map(int, f.readline().split())\n        grid = [list(line.strip()) for line in f.readlines()]\n\n    clue_count = 0\n    clue_positions = []\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                is_left_blocked = (i > 0 and grid[i-1][j] == '#') or (j < m - 1 and j == 0)\n                is_right_clear = j < m - 1 and grid[i][j+1] == '.'\n                if is_left_blocked and is_right_clear:\n                    clue_count += 1\n                    clue_positions.append((i, j))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[j][i] == '.':\n                is_above_blocked = (i > 0 and grid[j-1][i] == '#') or (j < n - 1 and j == 0)\n                is_below_clear = j < n - 1 and grid[j+1][i] == '.'\n                if is_above_blocked and is_below_clear:\n                    clue_count += 1\n                    clue_positions.append((j, i))\n\n    with open('crosswords.out', 'w') as f:\n        f.write(str(clue_count) + '\\n')\n        for position in sorted(set(clue_positions)):\n            f.write(str(position[0] + 1) + ' ' + str(position[1] + 1) + '\\n')\n\nif __name__ == '__main__':\n    get_clue_numbers('crosswords.in')```", "time_gen": "\ntime generating: 11.841532s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=489": {"code": "```\nimport sys\nn = int(input())\ncows = []\nfor _ in range(n):\n    pos, speed = map(int, input().split())\n    cows.append((pos, speed))\n\ncows.sort()\ngroups = 1\nlast_group = 0\nfor i in range(1, n):\n    if cows[i][0] - cows[i-1][0] > cows[i-1][1]:\n        groups += 1\n        last_group = i\n\nprint(groups)\n```", "time_gen": "\ntime generating: 3.63787s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=490": {"code": "```\nweights = []\nspot_cows = []\n\nwith open('learning.in', 'r') as f:\n    N, A, B = map(int, f.readline().split())\n    for _ in range(N):\n        line = f.readline().strip()\n        if line.startswith('S'):\n            weight, _ = map(int, line.split()[1:])\n            weights.append(weight)\n            spot_cows.append(True)\n        else:\n            weight, _ = map(int, line.split()[1:])\n            weights.append(weight)\n            spot_cows.append(False)\n\nweights.sort()\n\nans = 0\nfor w in range(A, B+1):\n    idx = binary_search(weights, w)\n    if spot_cows[idx]:\n        ans += 1\n\nprint(ans)\n\ndef binary_search(arr, target):\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return low\n```", "time_gen": "\ntime generating: 8.408279s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=491": {"code": "Here is a Python solution for this problem:\n```\nimport sys\nfrom collections import deque\n\ndef read_input():\n    B, E, P, N, M = map(int, sys.stdin.readline().split())\n    connections = [[] for _ in range(N+1)]\n    for _ in range(M):\n        a, b = map(int, sys.stdin.readline().split())\n        connections[a].append(b)\n        connections[b].append(a)\n    return B, E, P, N, M, connections\n\ndef bfs(B, E, P, N, connections):\n    visited = [[False] * N for _ in range(N)]\n    queue = deque([(1, 0), (2, 0)])\n    total_energy = [B, E]\n    for a, b in queue:\n        if a == 2 and b == N-1:\n            break\n        if not visited[a][b]:\n            if a == 2 or b == N-1:\n                total_energy[0] += B\n                total_energy[1] += E\n            else:\n                for c in connections[a][1:]:\n                    if c == b:\n                        continue\n                    if visited[c][b]:\n                        continue\n                    queue.append((c, b))\n            visited[a][b] = True\n    return min(total_energy)\n\nB, E, P, N, M, connections = read_input()\nprint(bfs(B, E, P, N, connections))\n```", "time_gen": "\ntime generating: 10.268461s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=492": {"code": "```\ndef calculate_distance(checkpoints):\n    total_distance = 0\n    x, y = checkpoints[0]\n    for i in range(1, len(checkpoints)):\n        new_x, new_y = checkpoints[i]\n        total_distance += abs(x - new_x) + abs(y - new_y)\n        x, y = new_x, new_y\n    return total_distance\n\n\ndef find_minimum_distance(N, K, checkpoints):\n    all_distances = []\n    for i in range(K + 1):\n        distances = [calculate_distance(checkpoints[:i] + checkpoints[i+1:])]\n        if i > 0:\n            for j in range(i):\n                distances.append(calculate_distance(checkpoints[:j] + checkpoints[j:i] + checkpoints[i+1:]))\n        all_distances.extend(distances)\n    return min(all_distances)\n\n\nN, K = [int(x) for x in open('marathon.in').read().strip().split()]\ncheckpoints = [list(map(int, line.split())) for line in open('marathon.in').readlines()[1:]]\n\nprint(find_minimum_distance(N, K, checkpoints))\n```", "time_gen": "\ntime generating: 7.739326s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=493": {"code": "```\nimport sys\nfrom collections import defaultdict\n\ninput = open('cowjog.in', 'r')\noutput = open('cowjog.out', 'w')\n\nn, t = map(int, input.readline().split())\npositions = []\nfor _ in range(n):\n    pos, speed = map(int, input.readline().split())\n    positions.append((pos, speed))\n\ngroups = defaultdict(list)\nfor i in range(n):\n    group = sum(1 for x in positions if x[0] <= positions[i][0] + positions[i][1]*t) - 1\n    groups[group].append(positions[i])\n\nfinal_groups = {}\nfor key in sorted(groups.keys()):\n    final_groups[key] = len(groups[key])\noutput.write(str(len(final_groups)) + '\\n')\n```", "time_gen": "\ntime generating: 5.3331s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=494": {"code": "```\n```\n\n```python\nN, H = map(int, input().split())\ncows = []\nfor _ in range(N):\n    h, w, s = map(int, input().split())\n    cows.append((h, w, s))\n\ncows.sort(reverse=True)\n\nmax_weight = 0\nmax_strength = 0\nfor cow in cows:\n    if cow[0] + max_weight > H:\n        break\n    max_weight += cow[1]\n    max_strength = min(max_strength, cow[2])\n\nif max_weight < H:\n    print(\"Mark is too tall\")\nelse:\n    print(max_strength)\n```", "time_gen": "\ntime generating: 4.701893s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=495": {"code": "```\n```\n\n```python\ndef calculate_distance(i, j):\n    return abs(checkpoints[i][0] - checkpoints[j][0]) + abs(checkpoints[i][1] - checkpoints[j][1])\n\nwith open('marathon.in', 'r') as f:\n    N, Q = map(int, f.readline().split())\n    global checkpoints\n    checkpoints = []\n    for _ in range(N):\n        x, y = map(int, f.readline().split())\n        checkpoints.append((x, y))\n\nqueries = []\nfor _ in range(Q):\n    query_type = f.readline().strip()\n    if query_type.startswith('U'):\n        i, x, y = map(int, query_type.split()[1:])\n        for j in range(N):\n            if j == i:\n                continue\n            checkpoints[i] = (x, y)\n        queries.append((None, None))\n    elif query_type.startswith('Q'):\n        i, j = map(int, query_type.split()[1:])\n        queries.append((i, j))\n\nwith open('marathon.out', 'w') as f:\n    for query in queries:\n        if query[0] is not None:\n            f.write(str(calculate_distance(query[0], query[1])) + '\\n')\n```", "time_gen": "\ntime generating: 9.048301s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=496": {"code": "```\ndef cow_jog():\n    N, T = [int(x) for x in input().split()]\n    positions = [[0, 0]] + [[*map(int, line.split())] for line in [input().split() for _ in range(N-1)]]\n    positions.sort()\n    lanes = 1\n    max_position = 0\n    for pos, speed in positions:\n        max_position += speed\n        if max_position > T:\n            break\n        while max_position > positions[lanes][0] + positions[lanes][1]:\n            lanes += 1\n    print(lanes)\n```", "time_gen": "\ntime generating: 4.548964s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=507": {"code": "```\ndef read_input():\n    A, B, N = map(int, input().split())\n    routes = []\n    for _ in range(N):\n        cost, length = map(int, input().split())\n        route = list(map(int, input().split()))\n        routes.append((cost, length, route))\n    return A, B, routes\n\ndef find_min_cost(A, B, routes):\n    min_cost = float('inf')\n    for cost, _, route in routes:\n        if route[0] == A and route[-1] == B:\n            min_cost = min(min_cost, cost)\n        elif route[0] == B and route[-1] == A:\n            min_cost = min(min_cost, cost)\n        else:\n            start = 0\n            for end in range(1, len(route)):\n                if route[end] == A or route[end] == B:\n                    break\n                if route[start] == A or route[start] == B:\n                    continue\n                if route[start] < A and route[end] > A:\n                    min_cost = min(min_cost, cost)\n                elif route[start] > A and route[end] < A:\n                    min_cost = min(min_cost, cost)\n    return -1 if min_cost == float('inf') else min_cost\n\nA, B, routes = read_input()\nprint(find_min_cost(A, B, routes))\n```", "time_gen": "\ntime generating: 10.256728s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=508": {"code": "```\ndef cow_routing():\n    N = int(input())\n    routes = []\n    for _ in range(N):\n        cost, cities = map(int, input().split()), list(map(int, input().split()))\n        routes.append((cost, cities))\n\n    A, B, min_cost = map(int, input().split())\n\n    dp = [[float('inf')] * (B + 1) for _ in range(A + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, A + 1):\n        for j in range(1, B + 1):\n            for route in routes:\n                cost, cities = route\n                if len(cities) > 1 and cities[0] == i and cities[-1] <= j:\n                    dp[i][j] = min(dp[i][j], dp[cities[0]][cities[-1]] + cost)\n\n    return -1 if dp[A][B] == float('inf') else dp[A][B]\n\nprint(cow_routing())\n```", "time_gen": "\ntime generating: 7.918434s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=509": {"code": "```\npython\ndef what_base():\n    k = int(open('whatbase.in', 'r').readline())\n    for _ in range(k):\n        n1, n2 = map(int, open('whatbase.in', 'r').readline().strip().split())\n        max_b = 10000\n        for b1 in range(10, max_b+1):\n            for b2 in range(10, max_b+1):\n                if convert_base(n1, b1) == convert_base(n2, b2):\n                    print(b1, b2)\n                    break\n\ndef convert_base(n, base):\n    conv_table = \"0123456789ABCDEF\"\n    if n < base:\n        return conv_table[n]\n    else:\n        return convert_base(n//base, base) + conv_table[n%base]\n\nwhat_base()\n```", "time_gen": "\ntime generating: 7.401804s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=510": {"code": "```\nimport heapq\n\ndef meeting_time():\n    N, M = map(int, input().split())\n    paths = []\n    for _ in range(M):\n        A, B, C, D = map(int, input().split())\n        if A > B:\n            A, B = B, A\n            C, D = D, C\n        paths.append((C, D))\n    \n    pq = [(0, 1)]  # (time, field)\n    visited = set()\n    while pq:\n        time, field = heapq.heappop(pq)\n        if field == N:\n            return time\n        \n        if field in visited:\n            continue\n        visited.add(field)\n        \n        for C, D in paths:\n            next_time = time + min(C, D)  # Bessie travels faster than Elsie\n            next_field = A\n            if field < A:\n                next_time += (A - field) * 2  # travel up to the path\n                next_field = A\n            elif field > B:\n                next_time += (field - B)  # travel down from the path\n                next_field = B\n            else:  # we're on the path\n                if C < D:\n                    next_time += (B - field)\n                    next_field = B\n                else:\n                    next_time += (A - field)\n                    next_field = A\n            \n            heapq.heappush(pq, (next_time, next_field))\n    \n    return \"IMPOSSIBLE\"\n\nprint(meeting_time())\n```", "time_gen": "\ntime generating: 10.567309s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=511": {"code": "```\npython\nfrom bisect import bisect_left\n\nn = int(input())\ncows = []\nfor _ in range(n):\n    x, y, r = map(int, input().split())\n    cows.append((y, x, r))\n\ncows.sort()\nans = 0\nmax_y = -1e9\nfor i in range(n):\n    if cows[i][0] > max_y:\n        ans += 1\n        max_y = cows[i][2] * (i // cows[i][2]) + cows[i][1]\n\nprint(ans)\n```", "time_gen": "\ntime generating: 4.987888s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=512": {"code": "```\ndef cow_routing():\n    A, B, N = map(int, input().split())\n    \n    routes = []\n    for _ in range(N):\n        cost, route_len = map(int, input().split())\n        route = list(map(int, input().split()))\n        \n        for i in range(1, route_len):\n            routes.append((cost, route[0], route[i-1], route[i]))\n    \n    dp = [[float('inf'), float('inf')] for _ in range(B+1)]\n    dp[A][A] = 0\n    \n    for k in range(A+1, B+1):\n        for i in range(k):\n            for j in range(1, len(routes)):\n                if routes[j][2] == i and routes[j][3] == k:\n                    dp[k][k-1] = min(dp[k][k-1], dp[i][i-1] + routes[j][0])\n    \n    if dp[B][A] != float('inf'):\n        return \"{} {}\".format(dp[B][A], (dp[B][A] - 1) // max(routes, key=lambda x: x[0])[0] + 1)\n    else:\n        return \"-1 -1\"\n```", "time_gen": "\ntime generating: 9.102485s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=513": {"code": "```\nimport heapq\n\nN, M = map(int, input().split())\n\ngraph = {}\nfor _ in range(M):\n    a, b, ca, da = map(int, input().split())\n    if a not in graph:\n        graph[a] = []\n    if b not in graph:\n        graph[b] = []\n    graph[a].append((b, ca))\n    graph[b].append((a, da))\n\ndist = {i: float('inf') for i in range(1, N+1)}\npq = [(0, 1)]\nwhile pq:\n    d, node = heapq.heappop(pq)\n    if d > dist[node]:\n        continue\n    for neighbor, ca in graph.get(node, []):\n        c = d + ca\n        if c < dist[neighbor]:\n            dist[neighbor] = c\n            heapq.heappush(pq, (c, neighbor))\n\nif dist[N] == float('inf'):\n    print(\"IMPOSSIBLE\")\nelse:\n    print(dist[N])\n```", "time_gen": "\ntime generating: 7.679869s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=514": {"code": "```markdown\n```\n```\nimport sys\nfrom collections import defaultdict\n\ndef cow_rectangles():\n    N = int(sys.stdin.readline())\n    cows = [defaultdict(int) for _ in range(N)]\n    max_holsteins = 0\n    min_area = float('inf')\n\n    for i in range(N):\n        x, y, breed = map(int, sys.stdin.readline().split())\n        if breed == 'H':\n            cows[i][x] += 1\n            cows[i][y] += 1\n\n    for cow in cows:\n        if (len(cow) > max_holsteins):\n            max_holsteins = len(cow)\n        area = sum((max(row.values()) - min(row.values())) * count for row, count in cow.items())\n        if (area < min_area):\n            min_area = area\n\n    print(max_holsteins, min_area)\n\ncow_rectangles()\n```", "time_gen": "\ntime generating: 6.359298s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=515": {"code": "```\nimport heapq\nN, L = map(int, open(\"movie.in\", \"r\").readline().split())\nmovies = []\nfor _ in range(N):\n    duration, num_showtimes = map(int, open(\"movie.in\", \"r\").readline().split())\n    showtimes = list(map(int, open(\"movie.in\", \"r\").readline().split()))\n    movies.append((showtimes[0], duration, num_showtimes))\nmovies.sort(key=lambda x: x[0])\n\nqueue = [(0, 0)]\nans = 0\ntotal_time = 0\n\nwhile queue and total_time < L:\n    time, idx = heapq.heappop(queue)\n    if time >= L:\n        break\n    movie_time, duration, num_showtimes = movies[idx]\n    if time + movie_time <= L:\n        ans += 1\n        total_time += movie_time\n        if idx < N - 1 and movies[idx+1][0] > time:\n            heapq.heappush(queue, (movies[idx+1][0], idx+1))\n    else:\n        remaining_time = L - time\n        if remaining_time <= duration:\n            ans += 1\n            total_time += duration\n        else:\n            ans += 1\n            total_time += duration - (remaining_time % duration)\n        heapq.heappush(queue, ((time + duration) % movies[idx][0], idx))\nprint(-1 if queue or total_time < L else ans)\n```", "time_gen": "\ntime generating: 9.907817s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=516": {"code": "```\nimport heapq\nfrom collections import defaultdict\n\nn, m = map(int, open('grass.in').readline().split())\ngraph = defaultdict(list)\nfor _ in range(m):\n    a, b = map(int, open('grass.in').readline().split())\n    graph[a].append(b)\n\ndef bfs():\n    visited = set()\n    pq = [(1, 0)] # (node, count of nodes reached)\n    max_count = 0\n    while pq:\n        node, count = heapq.heappop(pq)\n        if node not in visited:\n            visited.add(node)\n            max_count = max(max_count, count + 1)\n            for neighbor in graph[node]:\n                if neighbor == 1: continue\n                heapq.heappush(pq, (neighbor, count + 1))\n    return max_count\n\nprint(bfs())\n```", "time_gen": "\ntime generating: 7.028298s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=526": {"code": "```\ndef censor(S, T):\n    res = S\n    while T in res:\n        pos = res.index(T)\n        res = res[:pos] + res[pos+len(T):]\n    return res\n\nS = input()\nT = input()\n\nprint(censor(S, T))```", "time_gen": "\ntime generating: 2.774164s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=527": {"code": "```\nn = int(input())\ns = input()\ncow_count = 0\nlast_c = -1\nfor i in range(n):\n    if s[i] == 'C':\n        last_c = i\n    elif s[i] == 'O' and i >= last_c:\n        cow_count += (i - last_c) // 3 + 1\n        last_c = i\n    elif s[i] == 'W' and i >= last_c:\n        if i - last_c > 2:\n            cow_count += (i - last_c) // 4 + ((i - last_c) % 4) // 3 * (i - last_c > 6)\nprint(cow_count)\n```", "time_gen": "\ntime generating: 4.953309s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=528": {"code": "```\ndef hopscotch(r, c, grid):\n    dp = [[0] * (c + 1) for _ in range(r + 1)]\n\n    dp[0][0] = 1\n    for i in range(1, r + 1):\n        for j in range(c + 1):\n            if i < r or j < c:\n                if i > 0 and grid[i - 1][j] != grid[i][j]:\n                    dp[i][j] += dp[i - 1][min(j, c)]\n                if j > 0 and grid[i][j - 1] != grid[i][j]:\n                    dp[i][j] += dp[max(0, i), j - 1]\n    return dp[r][c]\n\nr, c = map(int, open('hopscotch.in', 'r').read().strip().split())\ngrid = [list(line) for line in open('hopscotch.in', 'r').read().strip().split('\\n')]\nprint(hopscotch(r, c, grid))\n```", "time_gen": "\ntime generating: 7.067432s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=529": {"code": "```\ndef censor(S, T):\n    S = list(S)\n    while T in S:\n        start = S.index(T)\n        S.pop(start)\n    return ''.join(S)\n\nS = input()\nT = input()\n\nprint(censor(S, T))\n```", "time_gen": "\ntime generating: 2.543422s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=530": {"code": "```\ndef count_jumps(R, C, K):\n    # Initialize a memoization table with all values being -1\n    memo = [[-1 for _ in range(K+1)] for _ in range(R+C)]\n\n    def dfs(i, j, label):\n        if i == R and j == C:\n            return 1\n        if memo[i][label] != -1:\n            return memo[i][label]\n        \n        result = 0\n        for k in range(1, K+1):\n            if (k != label and \n                i+1 <= R and j+1 <= C and \n                int((i+j)/2) < label and \n                label > k):\n                result += dfs(i+1, j+1, k)\n        memo[i][label] = result % 1000000007\n        return result\n\n    total_count = 0\n    for i in range(R):\n        for j in range(C):\n            if (i == 0 and j == 0) or (int((i+j)/2) < K):\n                total_count += dfs(i, j, int((R+C-1)/2))\n    \n    return total_count\n\n# Read input\nR, C, K = map(int, raw_input().split())\n\ngrid = []\nfor i in range(R):\n    grid.append(map(int, raw_input().split()))\n\nprint(count_jumps(R, C, K))\n\n```", "time_gen": "\ntime generating: 9.379271s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=531": {"code": "```\nfrom itertools import permutations\nfrom functools import reduce\nfrom operator import xor\n\nn = int(input())\n\nteam_ids = [int(input()) for _ in range(n)]\n\nmax_points = 0\nfor p in permutations(team_ids, n-1):\n    points = sum([p[i] ^ p[i+1] for i in range(n-1)])\n    max_points = max(max_points, points)\n\nprint(max_points)\n```", "time_gen": "\ntime generating: 4.205557s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=532": {"code": "```\ndef cow_hops(R, C, K):\n    grid = [list(map(int, input().split())) for _ in range(R)]\n    \n    def dfs(r, c, prev_num, dp):\n        if r == R-1 and c == C-1:\n            return 1\n        \n        count = 0\n        for dr, dc in [(-1, 0), (0, -1)]:\n            nr, nc = r + dr, c + dc\n            \n            if 0 <= nr < R and 0 <= nc < C and grid[nr][nc] != prev_num:\n                count += dp(nr, nc, grid[nr][nc])\n        \n        return count % 1000000007\n    \n    return dfs(0, 0, -1, lambda r, c, num: 1 if r == R-1 and c == C-1 else 0)\n```", "time_gen": "\ntime generating: 6.241467s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=533": {"code": "Here is a Python solution for the problem:\n\n```\ndef censor(S, t):\n    while True:\n        found = False\n        start = -1\n        for i in range(len(S)):\n            for j in range(len(t)):\n                if S[i+j] == t[j]:\n                    if start == -1:\n                        start = i\n                    else:\n                        break\n            else:\n                continue\n            break\n        if start != -1:\n            S = S[:start] + S[start+len(t):]\n            found = True\n        if not found:\n            break\n    return S\n\nS = input()\nN = int(input())\nt = []\nfor i in range(N):\n    t.append(input())\n\nprint(censor(S, ''.join(t)))\n```", "time_gen": "\ntime generating: 5.442154s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=534": {"code": "```\nN, Q = map(int, input().split())\npoints = [list(map(int, input().split())) for _ in range(N)]\nqueries = []\nfor _ in range(Q):\n    query = list(map(int, input().split()))\n    if len(query) == 3:\n        a, b, c = query\n        queries.append((a, b, c))\n    else:\n        x, y = query[1:]\n        points.append([x, y])\n\ndef check_fence(a, b, c):\n    left = [point for point in points if (a * point[0] + b * point[1] - c) <= 0]\n    right = [point for point in points if (a * point[0] + b * point[1] - c) > 0]\n    return len(left) == 0 or len(right) == 0\n\nfor query in queries:\n    if len(query) == 3:\n        print(\"YES\" if check_fence(*query) else \"NO\")\n    else:\n        x, y = query[1:]\n        left = [point for point in points if (2 * point[0] + 2 * point[1] - 3) <= 0]\n        right = [point for point in points if (2 * point[0] + 2 * point[1] - 3) > 0]\n        print(\"YES\" if len(left) == 0 or len(right) == 0 else \"NO\")\n```", "time_gen": "\ntime generating: 11.338266s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=545": {"code": "```\n```\n\n```python\ndef max_moons(N, M, puzzle):\n    count = 0\n    for i in range(N):\n        for j in range(M):\n            if puzzle[i][j] == 'M':\n                count += 1\n    return count\n\nN, M = [int(i) for i in open('moocrypt.in').read().split()]\npuzzle = [list(line.strip()) for line in open('moocrypt.in').readlines()[:N]]\nprint(max_moons(N, M, puzzle))\n```", "time_gen": "\ntime generating: 4.546039s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=546": {"code": "```\nimport itertools\n\ndef geteven():\n    N = int(input().strip())\n    variables = {}\n    for _ in range(N):\n        var, value = input().split()\n        variables[var] = [int(x) for x in str(value).split(\",\")]\n    \n    total_count = 0\n    for values in itertools.product(*[v for v in variables.values()]):\n        expression_values = {k: v[0] for k, v in zip(variables.keys(), values)}\n        if eval('({}+{}+{}+{}+{}+{})*({}+{}+{})*(1+{})'.format(*[str(expression_values[v]) for v in 'BESSIEMOG'])) % 2 == 0:\n            total_count += 1\n    \n    print(total_count)\n\ngeteven()\n```", "time_gen": "\ntime generating: 6.611745s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=547": {"code": "Here is the Python solution for the problem:\n\n```\nn = int(input())\ntotal_area = 0\nleftmost = float('inf')\nrightmost = float('-inf')\n\nfor _ in range(n):\n    size, pos = map(int, input().split())\n    leftmost = min(leftmost, pos)\n    rightmost = max(rightmost, pos)\n\n    if size < rightmost - leftmost + 1:\n        total_area += (size - 1) * 2\n    else:\n        total_area += rightmost - leftmost + 1\n\nprint(total_area)\n```", "time_gen": "\ntime generating: 4.854818s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=548": {"code": "```\nn = int(input())\ngrid = []\nfor i in range(n):\n    row = input()\n    grid.append(row)\n\npalindromes = set()\n\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef generate_palindrome(i, j, path):\n    if i >= n or j >= n:\n        palindromes.add(path)\n        return\n    for direction in [(0, 1), (1, 0)]:\n        new_i = i + direction[0]\n        new_j = j + direction[1]\n        if 0 <= new_i < n and 0 <= new_j < n:\n            generate_palindrome(new_i, new_j, path + grid[new_i][new_j])\n\nfor i in range(n):\n    for j in range(n):\n        generate_palindrome(i, j, grid[i][j])\n\nprint(len(palindromes))\n```", "time_gen": "\ntime generating: 6.325015s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=549": {"code": "```\nimport sys\nfrom functools import lru_cache\n\nN = int(input())\nvar_values = {}\nfor _ in range(N):\n    var, val = input().split()\n    if var not in var_values:\n        var_values[var] = []\n    var_values[var].append(int(val))\n\n@lru_cache(None)\ndef solve(var_vals):\n    if len(var_vals) == 7:\n        return int(eval(''.join(str(v) for v in var_vals)) % 7)\n    else:\n        total_ways = 0\n        for val in set(var_values[var]):\n            new_var_vals = var_vals + [val]\n            ways = solve(new_var_vals)\n            if ways is not None:\n                total_ways += ways\n        return total_ways\n\nprint(solve([]))\n```", "time_gen": "\ntime generating: 6.137376s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=550": {"code": "```\nfrom bisect import bisect_left\n\nN = int(input())\nB = int(input())\n\nbales = []\nfor _ in range(N):\n    size, pos = map(int, input().split())\n    bales.append((pos, size))\n\nif len(bales) < 2:\n    print(-1)\nelse:\n    leftmost = bales[0][1]\n    rightmost = bales[-1][1]\n\n    if B > rightmost and B + N > leftmost:\n        idx = bisect_left(bales, (B,))\n        if idx == len(bales):\n            add_to_bale = max(0, rightmost - leftmost + 1)\n        elif idx == 0:\n            add_to_bale = max(0, leftmost - B)\n        else:\n            left_pos, left_size = bales[idx-1]\n            right_pos, right_size = bales[idx]\n            if B > right_pos:\n                add_to_bale = max(0, B - right_pos + 1)\n            elif B < left_pos:\n                add_to_bale = max(0, left_pos - B)\n\n        print(add_to_bale)\n```", "time_gen": "\ntime generating: 9.023579s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=551": {"code": "```\ndef maximum_energy_quality(n, edges, qualities):\n    visited = [False] * (n + 1)\n    max_energy = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            stack = [i]\n            current_quality = qualities[i - 1]\n\n            while stack:\n                node = stack.pop()\n                visited[node] = True\n\n                for neighbor in edges[node]:\n                    if not visited[neighbor]:\n                        stack.append(neighbor)\n                    else:\n                        max_energy[neighbor] = max(max_energy[neighbor], max_energy[node] + (qualities[neighbor - 1] - current_quality))\n\n    return max(max_energy)\n\nn, e = map(int, input().split())\nedges = [[] for _ in range(n + 1)]\nqualities = list(map(int, input() for _ in range(n)))\n\nfor i in range(e):\n    u, v = map(int, input().split())\n    edges[u].append(v)\n    edges[v].append(u)\n\nprint(maximum_energy_quality(n, edges, qualities))\n```", "time_gen": "\ntime generating: 7.871919s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=552": {"code": "```\ndef get_children(employee_id):\n    while True:\n        children = int(input())\n        if children == 0:\n            return None\n        left, right = map(int, input().split())\n        if (left, right) == (-1, -1):  # special case for CEO\n            return (None, None)\n        yield (left, right)\n\ndef find_n():\n    n = 0\n    parent = None\n    for children in get_children(1):\n        parent = n\n        n += 2\n        if children:\n            yield from ((n - 1) * 2 + child[0] for child in children)\n            yield from ((n - 1) * 2 + child[1] for child in children)\n\n    return parent\n\nprint(\"Answer \" + str(next(find_n())))\n```", "time_gen": "\ntime generating: 6.954995s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=553": {"code": "```\nfrom collections import Counter\n\nN = int(input())\ngrid = [input().strip() for _ in range(N)]\nn = N * N\n\n# Initialize the dynamic programming table\ndp = [[0] * (n + 1) for _ in range(n + 1)]\n\n# Base case: a single character is always a palindrome\nfor i in range(1, n + 1):\n    dp[i][i] = 1\n\n# Fill up the table using dynamic programming\nfor length in range(2, n + 1):\n    for i in range(n - length + 1):\n        j = i + length - 1\n        if grid[0][i] == grid[0][j]:\n            dp[i][j] = dp[i + 1][j - 1] + 1\n        else:\n            dp[i][j] = dp[i][j - 1] + dp[i + 1][j]\n\n# Count the number of distinct palindromes\ntotal_palindromes = 0\n\nfor i in range(1, n):\n    for j in range(n - 1, i - 1, -1):\n        if grid[0][i] == grid[0][j]:\n            break\n        total_palindromes += dp[i][j]\n\nprint((total_palindromes + 1) % 1000000007)\n```", "time_gen": "\ntime generating: 9.600633s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=554": {"code": "Here is the Python solution for the problem:\n```\nn = int(input())\ntotal_area = 0\nleftmost = float('inf')\nrightmost = float('-inf')\n\nfor _ in range(n):\n    s, p = map(int, input().split())\n    leftmost = min(leftmost, p)\n    rightmost = max(rightmost, p + s)\n\nif leftmost < rightmost:\n    total_area += (leftmost - 1) * (rightmost - leftmost)\nelse:\n    total_area = 0\n\nprint(total_area)\n```", "time_gen": "\ntime generating: 4.105943s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=567": {"code": "```\nmax_length = max(b, d)\nmin_length = min(a, c)\ntotal_length = (max_length - min_length) + abs(min(c, a) - max(d, b))\nprint(total_length)\n```", "time_gen": "\ntime generating: 2.630479s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=568": {"code": "```\n```\npython\n```\n```python\ndef speeding(input_file):\n    with open(input_file, 'r') as f:\n        N, M = map(int, f.readline().split())\n        road_segments = []\n        for _ in range(N):\n            length, speed_limit = map(int, f.readline().split())\n            road_segments.append((length, speed_limit))\n        \n        bessie_segments = []\n        for _ in range(M):\n            length, speed = map(int, f.readline().split())\n            bessie_segments.append((length, speed))\n\n    total_length = sum(length for length, _ in road_segments)\n    max_speed_over = 0\n\n    current_segment_index = 0\n    current_bessie_index = 0\n    current_time = 0.0\n\n    while True:\n        if current_segment_index >= N or current_bessie_index >= M:\n            break\n        \n        if road_segments[current_segment_index][1] < bessie_segments[current_bessie_index][1]:\n            current_segment_length, _ = road_segments[current_segment_index]\n            current_segment_speed_limit = road_segments[current_segment_index][1]\n\n            while True:\n                if current_time + (current_segment_length / float(current_segment_speed_limit)) > 100.0:\n                    break\n                current_time += (current_segment_length / float(current_segment_speed_limit))\n                current_segment_index += 1\n        else:\n            current_segment_length, speed = bessie_segments[current_bessie_index]\n            while True:\n                if current_time + current_segment_length / float(speed) > 100.0:\n                    break\n                current_time += current_segment_length / float(speed)\n                current_bessie_index += 1\n\n        max_speed_over = max(max_speed_over, abs(current_time - int(current_time)))\n\n    return str(int(max_speed_over))\n```\n\nTo run this code:\n\n```shell\npython speeding.py speeding.in > speeding.out\n```", "time_gen": "\ntime generating: 13.336868s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=569": {"code": "```\npython\n# Read input\nN, M, D, S = map(int, open('badmilk.in', 'r').read().split()[:4])\ndrink_times = []\nsick_times = []\n\n# Read drink times and sick times\nfor _ in range(D):\n    p, m, t = map(int, open('badmilk.in', 'r').read().split()[:3])\n    drink_times.append((p, m, t))\n\nfor _ in range(S):\n    p, t = map(int, open('badmilk.in', 'r').read().split()[:2])\n    sick_times.append((p, t))\n\n# Create a dictionary to store the drinks for each person\ndrinks = {}\nfor p, m, t in drink_times:\n    if p not in drinks:\n        drinks[p] = []\n    drinks[p].append(m)\n\n# Create a set to store the people who got sick and the time they got sick\nsick_people = set()\nfor p, t in sick_times:\n    sick_people.add(p)\n\n# Initialize the minimum medicine dose needed\nmin_dose = 0\n\n# Iterate over each milk type\nfor i in range(1, M + 1):\n    # Count the people who drank this milk and got sick\n    bad_milk_sick = sum([p for p, m in drinks.items() if m.count(i) > 0 and p in sick_people])\n    \n    # If all sick people drank this milk, increment min_dose by 1\n    if bad_milk_sick == len(sick_people):\n        min_dose += 1\n\n# Print the minimum medicine dose needed\nprint(min_dose)\n```", "time_gen": "\ntime generating: 13.957034s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=570": {"code": "```\nfrom collections import deque\n\ndef lightson():\n    N, M = map(int, input().split())\n    graph = [[0]*N for _ in range(N)]\n    for _ in range(M):\n        x, y, a, b = map(int, input().split())\n        if (x,y) != (a,b):\n            graph[x-1][y-1] = [(a-1, b-1)]\n\n    visited = set()\n    queue = deque([(0, 0)])\n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x+dx, y+dy\n            if 0 <= nx < N and 0 <= ny < N and (nx, ny) not in visited:\n                if graph[x][y]:\n                    for i, j in graph[x][y]:\n                        queue.append((i,j))\n                visited.add((nx, ny))\n    return len(visited)\n\nprint(lightson())\n```", "time_gen": "\ntime generating: 7.939653s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=571": {"code": "```\nimport sys\n\nN = int(input())\nElsie_cards = list(map(int, [input() for _ in range(N)]))\nBessie_cards = sorted([i for i in range(1, 2*N+1) if i not in Elsie_cards])\n\nmax_points = 0\ncurrent_card = 0\n\nfor card in sorted(Elsie_cards):\n    while Bessie_cards and Bessie_cards[0] < card:\n        current_card += 1\n    max_points += (Bessie_cards.pop(0) >= card)\n\nprint(max_points)\n```", "time_gen": "\ntime generating: 4.855037s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=572": {"code": "```\nfrom collections import defaultdict\n\nn, q = map(int, input().split())\nbreeds = defaultdict(int)\n\nfor _ in range(n):\n    breeds[int(input())] += 1\n\nfor _ in range(q):\n    a, b = map(int, input().split())\n    print(*[breeds[1], breeds[2]-breeds[1], breeds[3]-breeds[2]])\n```", "time_gen": "\ntime generating: 6.39333s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=573": {"code": "```\nimport sys\n\nn = int(sys.stdin.readline())\nelsie_cards = [int(line) for line in sys.stdin.readlines()]\n\nbessie_cards = sorted(set(elsie_cards))\n\nmax_points = 0\nfor i in range(n // 2):\n    if bessie_cards[i * 2] > elsie_cards[i]:\n        max_points += 1\n    elif bessie_cards[i * 2] < elsie_cards[i]:\n        max_points += -1\n\nprint(max_points)\n```", "time_gen": "\ntime generating: 8.264935s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=574": {"code": "```\nimport sys\ndef feast():\n    T, A, B = map(int, input().split())\n    return min(T, A + (T - B) // (A - B))\nprint(feast())\n```", "time_gen": "\ntime generating: 3.55819s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=575": {"code": "```\nimport sys\n\ndef bfs(maze):\n    N, M = len(maze), len(maze[0])\n    queue = [(0, 0, 0)]  # (row, col, smell)\n    visited = {(0, 0)}\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    smell_map = {(N-1, M-1): True}\n\n    while queue:\n        row, col, smell = queue.pop(0)\n        if (row, col) == (N-1, M-1):\n            return get_moves(maze, visited)\n\n        for dr, dc in directions:\n            nr, nc = row + dr, col + dc\n            if 0 <= nr < N and 0 <= nc < M and (nr, nc) not in visited:\n                if maze[nr][nc] == 1:  # pink tile\n                    queue.append((nr, nc, smell))\n                    visited.add((nr, nc))\n                elif maze[nr][nc] == 2:  # orange tile\n                    if smell:\n                        queue.append((nr, nc, 0))  # reset smell\n                    else:\n                        continue\n                elif maze[nr][nc] == 3:  # blue tile\n                    if smell:\n                        queue.append((nr, nc, smell))\n                        visited.add((nr, nc))\n                    else:\n                        continue\n                elif maze[nr][nc] == 4:  # purple tile\n                    slide = True\n                    while 0 <= nr < N and 0 <= nc < M and maze[nr][nc] == 4:\n                        nr, nc = nr + dr, nc + dc\n                    if (nr, nc) not in visited:\n                        queue.append((nr, nc, 0))  # reset smell\n                        visited.add((nr, nc))\n                    else:\n                        continue\n\n    return -1\n\ndef get_moves(maze, visited):\n    moves = []\n    row, col = N-1, M-1\n    while (row, col) != (0, 0):\n        if maze[row][col] == 1:  # pink tile\n            moves.append((row, col))\n        elif maze[row][col] == 2:  # orange tile\n            moves.extend([(i, j) for i in range(row, -1, -1) if maze[i][j] != 4])\n        elif maze[row][col] == 3:  # blue tile\n            while row > 0 and maze[row-1][col] == 2:\n                row -= 1\n            moves.extend([(i, col) for i in range(row, -1, -1)])\n        elif maze[row][col] == 4:  # purple tile\n            slide = True\n            while 0 <= row < N and 0 <= col < M and maze[row][col] == 4:\n                row += dr\n                col += dc\n            if (row, col) != (N-1, M-1):\n                moves.append((row, col))\n    return len(moves)\n\nif __name__ == \"__main__\":\n    N, M = map(int, sys.stdin.readline().split())\n    maze = [map(int, sys.stdin.readline().split()) for _ in range(N)]\n    print(bfs(maze))\n```", "time_gen": "\ntime generating: 38.210318s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=576": {"code": "```\nfrom collections import defaultdict, deque\n\nN, K = map(int, input().split())\nG = defaultdict(dict)\nfor _ in range(N - 1):\n    u, v = map(int, input().split())\n    G[u][v] = G[v].setdefault(u, 0) + 1\n    G[v][u] = G[u].setdefault(v, 0) + 1\n\nmax_flow = 0\nfor _ in range(K):\n    s, t = map(int, input().split())\n    G[s][t] -= 1\n    G[t][s] += 1\n    max_flow += 1\n\nprint(max_flow)\n```", "time_gen": "\ntime generating: 9.231081s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=577": {"code": "Here is the Python code for this problem:\n```\nN = int(input())\n\nelsie_cards = list(map(int, input().split()[:N]))\n\nmax_points = 0\npoints = 0\n\nfor i in range(N):\n    if elsie_cards[i] > points + 1:\n        points += 1\n    else:\n        if points > max_points:\n            max_points = points\n        points = 0\n\nprint(max_points)\n```", "time_gen": "\ntime generating: 6.818089s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=578": {"code": "Here is the solution to this problem:\n\n```markdown\nimport sys\n\nN, Q = map(int, input().split())\nfields = list(map(int, input().split()))\nfor _ in range(Q):\n    op = input().split()[0]\n    if op == 'M':\n        print(min(fields[A-1:B]))\n    elif op == 'P':\n        for i in range(A-1, B):\n            fields[i] += C\n    elif op == 'S':\n        print(sum(fields[A-1:B]))\n```", "time_gen": "\ntime generating: 8.194189s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=591": {"code": "```\nfrom io import open\n\nbr = int(open('promote.in', 'r').readline().split()[1])\nbs = int(open('promote.in', 'r').readline().split()[1])\nsg = int(open('promote.in', 'r').readline().split()[1])\nsp = int(open('promote.in', 'r').readline().split()[1])\n\nprint(br - bs)\nprint(bs - bg)\nprint(gg - gp)\n```", "time_gen": "\ntime generating: 7.351418s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=592": {"code": "```\nimport heapq\nn = int(input())\nheap = []\nmax_explosions = 0\nfor i in range(n):\n    x = int(input())\n    if len(heap) == 0 or x >= heap[0]:\n        heapq.heappush(heap, x)\n    else:\n        while len(heap) > 1 and heap[0] <= x - (i+1):\n            heapq.heappop(heap)\n        heapq.heappush(heap, x)\n    max_explosions = max(max_explosions, i+1 + len(heap))\nprint(max_explosions)\n```", "time_gen": "\ntime generating: 8.91243s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=593": {"code": "```\ndef mowing(x, directions):\n    x_max = x\n    for direction, steps in directions:\n        if direction == 'N':\n            max_y = 0\n        elif direction == 'S':\n            max_y = 10\n        elif direction == 'E':\n            max_x = 0\n        elif direction == 'W':\n            max_x = 10\n        for _ in range(steps):\n            if direction == 'N' and max_y > 5:\n                return -1\n            elif direction == 'S' and max_y < 5:\n                return -1\n            elif direction == 'E' and max_x > 5:\n                return -1\n            elif direction == 'W' and max_x < 5:\n                return -1\n            if direction == 'N':\n                max_y += 1\n            elif direction == 'S':\n                max_y -= 1\n            elif direction == 'E':\n                max_x += 1\n            elif direction == 'W':\n                max_x -= 1\n    return x_max\n\nn = int(input())\ndirections = []\nfor _ in range(n):\n    d, s = input().split()\n    directions.append((d, int(s)))\nx = mowing(0, directions)\nprint(x)\n```", "time_gen": "\ntime generating: 16.134312s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=594": {"code": "```\nimport sys\nN, K = map(int, sys.stdin.readline().split())\nx = sorted(map(int, (sys.stdin.read().split())))\nr = 0\nwhile len(set((i-x[j]) for i in x for j in range(len(x)))) > K:\n    r += 1\nprint(r)\n```", "time_gen": "\ntime generating: 5.359524s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=595": {"code": "```\nn = int(input())\ns = 0\nmax_len = 0\nfor _ in range(n):\n    s += int(input())\n    if s % 7 == 0:\n        max_len = max(max_len, len(str(s)) - len(str(int(s//7*7))))\n```", "time_gen": "\ntime generating: 4.831065s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=596": {"code": "```\n```\n```\n```\n```\n```python\nn = int(input())\npath = input()\n\nx, y = 0, 0\nparent = {(x, y): (x, y)}\nrank = {(x, y): 0}\n\ndef find(p):\n    if parent[p] != p:\n        parent[p] = find(parent[p])\n    return parent[p]\n\ndef union(uc, vc):\n    uc = find(uc)\n    vc = find(vc)\n    if uc == vc:\n        return\n    if rank[uc] < rank[vc]:\n        parent[uc] = vc\n    elif rank[uc] > rank[vc]:\n        parent[vc] = uc\n    else:\n        parent[vc] = uc\n        rank[uc] += 1\n\nfor step in path:\n    dx, dy = 0, 0\n    if step == 'N':\n        dy = -1\n    elif step == 'S':\n        dy = 1\n    elif step == 'E':\n        dx = 1\n    elif step == 'W':\n        dx = -1\n    x += dx\n    y += dy\n    p = (x, y)\n    if p in parent:\n        union(p, (x, y))\n    else:\n        parent[p] = p\n\nprint(len([p for p in parent if find(p) != p]) - 1)\n```", "time_gen": "\ntime generating: 16.226462s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=597": {"code": "```\nimport heapq\ndef angry_cows():\n    N = int(input())\n    positions = [int(x) for x in input().split()]\n    positions.sort()\n    heap = []\n    for i, pos in enumerate(positions):\n        if i == 0:\n            heapq.heappush(heap, (pos, 1))\n        else:\n            heapq.heappush(heap, (pos - positions[i-1], 1))\n    \n    ans = 0\n    while heap:\n        r, dist = heapq.heappop(heap)\n        ans = max(ans, dist)\n        for i in range(len(heap)):\n            if heap[i][0] >= r and heap[i][0] <= r + ans - 1:\n                heap.pop(i)\n                break\n    print(f\"{ans:.1f}\")\n```", "time_gen": "\ntime generating: 10.8016s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=598": {"code": "```\npython\ndef read_input():\n    with open('radio.in', 'r') as f:\n        N, M = map(int, f.readline().split())\n        fx, fy = map(int, f.readline().split())\n        bx, by = map(int, f.readline().split())\n        path_fj = f.readline().strip()\n        path_bessie = f.readline().strip()\n\n    return N, M, fx, fy, bx, by, path_fj, path_bessie\n\ndef calculate_energy(x1, y1, x2, y2):\n    return (abs(x2-x1) + abs(y2-y1)) ** 2\n\nN, M, fx, fy, bx, by, path_fj, path_bessie = read_input()\n\nmin_energy = float('inf')\n\nfor _ in range(N+1):\n    for move_fj in ['N', 'E', 'S', 'W']:\n        if move_fj == 'N':\n            new_fx, new_fy = fx, fy + 1\n        elif move_fj == 'E':\n            new_fx, new_fy = fx + 1, fy\n        elif move_fj == 'S':\n            new_fx, new_fy = fx, fy - 1\n        else:\n            new_fx, new_fy = fx - 1, fy\n\n        for _ in range(M+1):\n            for move_bessie in ['N', 'E', 'S', 'W']:\n                if move_bessie == 'N':\n                    new_bx, new_by = bx, by + 1\n                elif move_bessie == 'E':\n                    new_bx, new_by = bx + 1, by\n                elif move_bessie == 'S':\n                    new_bx, new_by = bx, by - 1\n                else:\n                    new_bx, new_by = bx - 1, by\n\n                energy = calculate_energy(new_fx, new_fy, new_bx, new_by)\n                if _ == M and move_bessie == path_bessie[-1]:\n                    min_energy = min(min_energy, energy)\n                    break\n            else:\n                continue\n            break\n        else:\n            continue\n        break\n\nprint(min_energy)\n```", "time_gen": "\ntime generating: 25.733863s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=599": {"code": "```\ndef read_barn(filename):\n    barn = []\n    with open(filename, 'r') as f:\n        N = int(f.readline())\n        for _ in range(N):\n            x, y = map(int, f.readline().split())\n            barn.append((x, y))\n    return barn\n\n\ndef calculate_distance(barn, start_idx):\n    angles = [0] * (len(barn) + 1)\n    edges = []\n    prev_angle = None\n    for i in range(len(barn)):\n        x1, y1 = barn[i]\n        x2, y2 = barn[(i + 1) % len(barn)]\n        if abs(x1 - x2) == 10:\n            angles[i] = (y2 - y1) * 1.0\n        else:\n            angles[i] = (x2 - x1) * 1.0\n    for i in range(len(barn)):\n        edges.append(((barn[i][0], barn[i][1]), (barn[(i + 1) % len(barn)][0], barn[(i + 1) % len(barn)][1])))\n\n    distance = 0\n    idx = start_idx - 1\n    while True:\n        if angles[idx] == 90:\n            break\n        direction = 1 if prev_angle is None or angles[idx] > prev_angle else -1\n        distance += edges[idx][1][0] - edges[idx][0][0]\n        idx = (idx + direction) % len(barn)\n    return distance\n\n\ndef solve(filename):\n    barn = read_barn(filename)\n    max_distance = 0\n    for i in range(1, len(barn)):\n        start_idx = i\n        lit_distance = calculate_distance(barn, start_idx)\n        dark_distance = calculate_distance(barn, start_idx) + len(barn)\n        max_distance = max(max_distance, abs(lit_distance - dark_distance))\n    return str(max_distance)\n\n\nprint(solve(\"lightsout.in\"))\n```", "time_gen": "\ntime generating: 26.291113s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=600": {"code": "```\npython\nN, M = map(int, open('fortmoo.in', 'r').readline().split())\nmax_area = 0\nfor i in range(N):\n    line = list(open('fortmoo.in', 'r').readline().strip())\n    for j in range(M):\n        if line[j] == 'X':\n            break\n    else:\n        max_width = M - j\n        max_height = N - i\n        max_area = max(max_area, max_width * max_height)\nprint(max_area)\n```", "time_gen": "\ntime generating: 7.261396s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=601": {"code": "```\nimport bisect\n\nx = []\ny = []\n\nfor _ in range(int(input())):\n    xi, yi = map(int, input().split())\n    if not x:\n        x.append(xi)\n        y.append(yi)\n    elif (x[-1] == xi):\n        y.append(yi)\n    else:\n        left = bisect.bisect_left(x, xi) - 1\n        x.insert(left + 1, xi)\n        y.insert(left + 1, yi)\n\ncrossings = 0\n\nfor i in range(1, len(x)):\n    if abs(x[i] - x[i-1]) > 1:\n        for j in range(i+1):\n            if abs(y[j] - y[i-1]) > 1 and (x[j] == x[i-1]):\n                crossings += 1\n\nprint(crossings)\n```", "time_gen": "\ntime generating: 11.261243s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=602": {"code": "```\ndef lights_out_distance(input_file):\n    with open(input_file, 'r') as f:\n        N = int(f.readline())\n        vertices = []\n        for _ in range(N):\n            x, y = map(int, f.readline().split())\n            vertices.append((x, y))\n\n    max_diff = 0\n    for i in range(1, N+1):\n        x, y = vertices[i-1]\n        start_vertex = (x, y)\n\n        clockwise_distance = counterclockwise_distance = 0\n        for j in range(i):\n            x, y = vertices[j%N]\n            if x == start_vertex[0]:\n                distance = abs(y - start_vertex[1])\n            else:\n                distance = abs(x - start_vertex[0])\n\n            if j % 2 == i % 2:\n                clockwise_distance += distance\n            else:\n                counterclockwise_distance += distance\n\n        max_diff = max(max_diff, abs(clockwise_distance - counterclockwise_distance))\n\n    return str(max_diff)\n\nprint(lights_out_distance('lightsout.in'))\n```", "time_gen": "\ntime generating: 14.199971s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=615": {"code": "```\nx, y, m = map(int, open('pails.in', 'r').read().split())\nmax_milk = min(m, x * (m // x) + min((m % x), y))\n\nprint(max_milk)\n```", "time_gen": "\ntime generating: 4.262947s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=616": {"code": "```\n```\n\n```\nn = int(input())\nrooms = list(map(int, input().split()))\ntotal_distance = 0\nfor i in range(n):\n    if rooms[i] > (i + 1) // 2:\n        total_distance += i * 2 - (i % 2)\n    else:\n        total_distance += n - i - 1\n\nprint(total_distance)\n```", "time_gen": "\ntime generating: 5.418242s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=617": {"code": "```\n**Code**\n```\nB, N = map(int, open('balancing.in', 'r').readline().split())\npoints = [map(int, line.split()) for line in open('balancing.in', 'r').readlines()[1:]]\n\ndef get_m(points):\n    x_coords = [point[0] for point in points]\n    y_coords = [point[1] for point in points]\n\n    max_x = max(x_coords)\n    min_x = min(x_coords)\n\n    max_y = max(y_coords)\n    min_y = min(y_coords)\n\n    x_partition = (max_x + min_x) // 2\n    y_partition = (max_y + min_y) // 2\n\n    a, b = x_partition, y_partition\n\n    x_partitions = [i for i in range(min_x, max_x+1) if i % 2 == a % 2]\n    y_partitions = [i for i in range(min_y, max_y+1) if i % 2 == b % 2]\n\n    count = 0\n    regions = [[], [], [], []]\n\n    for point in points:\n        x, y = point\n        if x < x_partition and y < y_partition:\n            regions[0].append(point)\n        elif x >= x_partition and y < y_partition:\n            regions[1].append(point)\n        elif x < x_partition and y >= y_partition:\n            regions[2].append(point)\n        else:\n            regions[3].append(point)\n\n    for region in regions:\n        count = max(count, len(region))\n\n    return count\n\nprint(get_m(points))\n```\n**Output**\n```\n2\n```", "time_gen": "\ntime generating: 17.667963s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=618": {"code": "```\nfrom math import sqrt\n\nn = int(input())\ncows = list(map(int, input().split() for _ in range(n)))\n\nmin_energy = 0\nfor i in range(1, n):\n    if cows[i] > cows[i-1]:\n        min_energy += (cows[i]-cows[i-1])**2\n    elif cows[i] < cows[i-1]:\n        min_energy += ((n-cows[i])-(n-cows[i-1]))**2\n\nprint(min_energy)\n```", "time_gen": "\ntime generating: 6.499401s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=619": {"code": "```\nimport math\n\ndef min_max_cows(x_coords, y_coords):\n    max_x = max(x_coords)\n    min_x = min(x_coords)\n\n    max_y = max(y_coords)\n    min_y = min(y_coords)\n\n    m1 = len([x for x in x_coords if min_x <= x <= (min_x + max_x) // 2])\n    m2 = len([y for y in y_coords if min_y <= y <= (min_y + max_y) // 2])\n\n    return min(m1, m2)\n\nn = int(input())\nx_coords = [int(x) for x in input().split()]\ny_coords = [int(y) for y in input().split()]\n\nprint(min_max_cows(x_coords, y_coords))\n```", "time_gen": "\ntime generating: 17.393288s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=620": {"code": "```\ndef get_min_error():\n    X, Y, K, M = map(int, input().split())\n    min_error = float('inf')\n\n    for i in range(K+1):\n        for j in range(K+1):\n            total_milk = min(i*X+j*Y, X) + min((K-i)*X+(K-j)*Y-Y, Y)\n            error = abs(M - total_milk)\n            if error < min_error:\n                min_error = error\n\n    return min_error\n\n\nprint(get_min_error())\n```", "time_gen": "\ntime generating: 22.39488s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=621": {"code": "```\n```\n\n```python\nn = int(input())\nenergy = 0\nfor i in range(n):\n    energy += (i + 1) * min(c[i-1], c[(i+1)%n]) + max(0, c[i] - 1)\nprint(energy)\n```", "time_gen": "\ntime generating: 14.111834s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=622": {"code": "```\nn, k = map(int, open('cbarn2.in', 'r').read().split()[0].split())\nroom_cows = [int(x) for x in open('cbarn2.in', 'r').read().split()[1:]]\n\ndef min_distance(n, k, room_cows):\n    total_distance = 0\n    for i in range(k+1):\n        current_room_index = (i+k)%n\n        for j in range(i, n):\n            if j > current_room_index:\n                j = (j-1)%n\n            total_distance += abs(room_cows[j] - room_cows[current_room_index])\n    return total_distance\n\nprint(min_distance(n, k, room_cows))\n```", "time_gen": "\ntime generating: 31.371037s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=623": {"code": "```\ndef min_fence_length():\n    A, B, n, m = map(int, input().split())\n    a = list(map(int, [input() for _ in range(n)]))\n    b = list(map(int, [input() for _ in range(m)]))\n\n    dp = [[0] * (B + 1) for _ in range(A + 1)]\n    \n    for i in range(A + 1):\n        dp[i][0] = i\n    for j in range(B + 1):\n        dp[0][j] = j\n\n    for i in range(1, A + 1):\n        for j in range(1, B + 1):\n            if (i == a[k - 1] or i > a[k - 1]) and (j == b[l - 1] or j > b[l - 1]):\n                dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1)\n            elif i < A and j < B:\n                dp[i][j] = min(dp[i+1][j] + 1, dp[i][j+1] + 1, dp[i-1][j-1] + 2)\n\n    print(dp[A][B])\n```", "time_gen": "\ntime generating: 49.390864s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=624": {"code": "Here is the Python code for the problem:\n```\nx_coords = []\ny_coords = []\n\nwith open('balancing.in', 'r') as f:\n    N = int(f.readline())\n    for _ in range(N):\n        x, y = map(int, f.readline().split())\n        if x % 2 == 1: x = x + 1\n        if y % 2 == 1: y = y + 1\n        x_coords.append(x)\n        y_coords.append(y)\n\nx_coords.sort()\ny_coords.sort()\n\na = x_coords[0]\nb = y_coords[0]\n\nprint(min(len(set([i for i in range(max(x_coords)) if i <= a])) +\n          len(set([i for i in range(max(y_coords)) if i <= b])),\n          4))\n```", "time_gen": "\ntime generating: 29.555545s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=625": {"code": "```\n```\n\n```python\nA, B, n, m = [int(x) for x in input().split()]\na = [int(input()) for _ in range(n)]\nb = [int(input()) for _ in range(m)]\n\ntotal_len = 0\n\nfor i in range(1, n):\n    total_len += A - (a[i] - a[i-1])\n\nfor i in range(1, m):\n    total_len += B - (b[i] - b[i-1])\n```", "time_gen": "\ntime generating: 23.204716s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=626": {"code": "```\nimport heapq\n\nn, k = map(int, input().split())\ndistances = [0] * n\nfor i in range(n):\n    distances[i] = (abs(i - 1) + abs(i - n)) // 2\n\nheap = [(0, i) for i in range(1, n)]\nwhile heap:\n    d, i = heapq.heappop(heap)\n    if i > 1 and distances[i-1] < d:\n        new_dist = (distances[i-1] + abs(i - 1)) // 2\n        if new_dist < d:\n            for j in range(k):\n                if distances[j] >= new_dist:\n                    distances[j] = new_dist\n                    heapq.heappush(heap, (new_dist, j))\n                    break\n\nprint(sum(distances))\n```", "time_gen": "\ntime generating: 40.417733s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=639": {"code": "```\nsorted_sizes = sorted([int(x) for x in open('diamond.in').readlines()][1:])\nn, k = int(open('diamond.in').readline().split()[0]), int(open('diamond.in').readline().split()[1])\ntotal = 0\nfor i in range(len(sorted_sizes)):\n    if i == 0:\n        total += 1\n    elif sorted_sizes[i] - sorted_sizes[i-1] > k:\n        total += 1\nprint(total)\n```", "time_gen": "\ntime generating: 21.401773s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=640": {"code": "```\nN, K = map(int, input().split())\nfig = [list(input()) for _ in range(N)]\npieces = [[list(input()) for _ in range(N)] for _ in range(K)]\n\ndef get_indices(fig, pieces):\n    ans = []\n    for i in range(K):\n        if fig == shift(pieces[i]):\n            return str(i+1)\n        for j in range(K):\n            if i != j:\n                if fig == shift(shift(pieces[i], 0, 0) + pieces[j]):\n                    return str(i+1) + ' ' + str(j+1)\n    return ''\n\ndef shift(piece, x=0, y=0):\n    n = len(piece)\n    res = [['.' for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if piece[i][j] == '#':\n                res[(i+x)%n][(j+y)%n] = '#'\n    return [''.join(row) for row in res]\n\ndef find_match(fig, pieces):\n    for i in range(K):\n        if fig == shift(pieces[i]):\n            return str(i+1)\n        for j in range(K):\n            if i != j:\n                if fig == shift(shift(pieces[i], 0, 0) + pieces[j]):\n                    return str(i+1) + ' ' + str(j+1)\n\nprint(find_match(fig[0], [shift(piece, x=0, y=0) for piece in pieces]))", "time_gen": "\ntime generating: 83.290308s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=641": {"code": "```\nimport math\n\ndef read_input(filename):\n    N = int(next(open(filename)))\n    cows = []\n    for _ in range(N):\n        x, y = map(int, next(open(filename)).split())\n        cows.append((x, y))\n    return cows\n\ndef compute_minimum_area(cows):\n    min_x = min(y[0] for y in cows)\n    max_x = max(y[0] for y in cows)\n    min_y = min(y[1] for y in cows)\n    max_y = max(y[1] for y in cows)\n\n    x_range = max_x - min_x\n    y_range = max_y - min_y\n\n    area_without_fence = x_range * y_range\n\n    # Check for edge cases where all points lie on a line\n    if x_range == 0:\n        return min_y * len(cows)\n    if y_range == 0:\n        return min_x * len(cows)\n\n    return area_without_fence\n\ndef main(filename):\n    cows = read_input(filename)\n    print(compute_minimum_area(cows))\n\nif __name__ == \"__main__\":\n    main(\"reduce.in\")\n```", "time_gen": "\ntime generating: 52.557473s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=642": {"code": "```\nfrom collections import defaultdict\nimport math\n\ndef read_input():\n    N = int(input())\n    cows = []\n    for _ in range(N):\n        x, y = map(int, input().split())\n        cows.append((x, y))\n    return cows\n\ndef find_min_area(cows):\n    min_area = float('inf')\n    for i in range(3**len(cows)):\n        sel_cows = [(c[0], c[1]) for j, c in enumerate(cows) if (i >> j) & 1]\n        min_x = max_x = min_y = max_y = None\n        for cow in sel_cows:\n            x, y = cow\n            if not min_x or x < min_x: min_x = x\n            if not max_x or x > max_x: max_x = x\n            if not min_y or y < min_y: min_y = y\n            if not max_y or y > max_y: max_y = y\n        area = (max_x - min_x) * (max_y - min_y)\n        min_area = min(min_area, area)\n    return min_area\n\ncows = read_input()\nmin_area = find_min_area(cows)\nprint(min_area)\n```", "time_gen": "\ntime generating: 51.112345s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=643": {"code": "```\nfrom collections import defaultdict\n\nN, K = map(int, input().split())\nsize_dict = defaultdict(int)\n\nfor _ in range(N):\n    size_dict[int(input())] += 1\n\nans = 0\nfor size in sorted(size_dict.keys()):\n    ans += min((size + K) // (K + 1), size_dict[size])\n    if ans >= N:\n        break\n\nprint(ans)\n```", "time_gen": "\ntime generating: 18.169767s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=644": {"code": "```\ndef is_connected(graph):\n    visited = set()\n    for node in range(1, len(graph)+1):\n        if node not in visited:\n            stack = [node]\n            while stack:\n                current_node = stack.pop()\n                if current_node not in visited:\n                    visited.add(current_node)\n                    stack.extend(neighbor for neighbor in graph[current_node] if neighbor not in visited)\n\n    return len(visited) == len(graph)\n\ndef main():\n    N, M = map(int, input().split())\n    graph = {}\n    for _ in range(M):\n        a, b = map(int, input().split())\n        if a not in graph:\n            graph[a] = set()\n        if b not in graph:\n            graph[b] = set()\n        graph[a].add(b)\n        graph[b].add(a)\n\n    barns_to_close = list(map(int, input().split()))\n    for i in range(N):\n        if i == 0 or is_connected({k: v - {barns_to_close[i-1]} for k, v in graph.items()}):\n            print('YES')\n        else:\n            print('NO')\n\nif __name__ == '__main__':\n    main()\n```", "time_gen": "\ntime generating: 5.983458s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=645": {"code": "```\ndef find_area():\n    n = int(input())\n    points = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        points.append((x, y))\n\n    min_x = min(x for x, _ in points)\n    max_x = max(x for x, _ in points)\n    min_y = min(y for _, y in points)\n    max_y = max(y for _, y in points)\n\n    area1 = (max_x - min_x) * (max_y - min_y)\n    \n    points.sort()\n    x_coords = [x for x, _ in points]\n    y_coords = [y for _, y in points]\n\n    area2 = 0\n    i, j = 0, len(x_coords)-1\n    while i <= j:\n        if abs(x_coords[i] - x_coords[j]) > max_y - min_y:\n            k = j\n            j -= 1\n            while j >= i and y_coords[k] < y_coords[j]:\n                j -= 1\n            area2 += (x_coords[k+1] - x_coords[i]) * (max_y - min_y)\n        else:\n            area2 += (x_coords[j] - x_coords[i]) * (y_coords[j] - y_coords[i])\n            i, j = j, k=k-1\n    area2 += (max_x - min_x) * max_y\n\n    return str(area1 - area2)\n\nprint(find_area())\n```", "time_gen": "\ntime generating: 8.011354s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=646": {"code": "```\nfrom collections import deque\n\nN, M = map(int, input().split())\nG = [[] for _ in range(N+1)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    G[a].append(b)\n    G[b].append(a)\n\ndef bfs():\n    visited = [False] * (N + 1)\n    queue = deque([1])\n    visited[1] = True\n    while queue:\n        node = queue.popleft()\n        for neighbor in G[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n    return all(visited)\n\norder = [int(x) for x in input().split()]\nresult = ['YES' if bfs() else 'NO']\nfor i, barn in enumerate(order):\n    result.append('YES' if bfs() and G[barn] else 'NO')\nprint('\\n'.join(result))\n```", "time_gen": "\ntime generating: 5.720867s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=647": {"code": "```\nimport sys\nn = int(sys.stdin.readline())\nnumbers = list(map(int, sys.stdin.readlines()))\nwhile len(numbers) > 1:\n    for i in range(len(numbers)-1):\n        if numbers[i] == numbers[i+1]:\n            numbers[i] += 1\n            del numbers[i+1]\n            break\nelse:\n    print(numbers[0])\n```", "time_gen": "\ntime generating: 2.773897s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=648": {"code": "```\ndef solve(filename):\n    with open(filename, 'r') as f:\n        N = int(f.readline())\n        nums = [int(line.strip()) for line in f.readlines()]\n    \n    max_num = 0\n    i = 0\n    while i < N:\n        if i + 1 < N and nums[i] == nums[i+1]:\n            nums[i] += 1\n            del nums[i+1]\n            N -= 1\n        else:\n            i += 1\n    \n    max_num = max(nums)\n    \n    return str(max_num)\n\nprint(solve('262144.in'))\n```", "time_gen": "\ntime generating: 3.915588s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=649": {"code": "```\ndef solution():\n    with open('bcs.in', 'r') as f:\n        K = int(f.readline())\n        cow_pieces = [list(line.strip()) for line in f.readlines()[:K+1][:-1]]\n        original_cow_piece = [[char for char in line.strip()] for line in f.readlines()[K+1:][0].splitlines()]\n        \n    count = 0\n    for i in range(K):\n        for j in range(i+1, K):\n            if can_match(cow_pieces[i], cow_pieces[j], original_cow_piece):\n                for k in range(j+1, K):\n                    if can_match(cow_pieces[i], cow_pieces[k], original_cow_piece) and can_match(cow_pieces[j], cow_pieces[k], original_cow_piece):\n                        count += 1\n    print(count)\n\ndef can_match(piece1, piece2, original_cow):\n    for i in range(len(original_cow)):\n        for j in range(len(original_cow[0])):\n            if original_cow[i][j] == piece1[i][j]:\n                return False\n    return True\n\nsolution()\n```", "time_gen": "\ntime generating: 8.098097s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=650": {"code": "```\n```\nimport sys\n\nN, X, Y, Z = map(int, input().split())\nA = [0] * N\nB = [0] * N\nfor i in range(N):\n    A[i], B[i] = map(int, input().split())\n\ntotal = 0\nfor i in range(N):\n    diff = B[i] - A[i]\n    if diff > 0:\n        total += X * diff\n    elif diff < 0:\n        total += Y * (-diff)\n    else:\n        continue\n\nfor i in range(1, N):\n    diff = B[i] - A[i]\n    if diff > 0:\n        for j in range(i+1, min(N, i+diff+1)):\n            total += Z\n    elif diff < 0:\n        for j in range(max(0, i-diff), i+1):\n            total += Z\n\nprint(total)\n```", "time_gen": "\ntime generating: 5.926413s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=663": {"code": "```\ndef calculate_minimum_area():\n    with open('square.in', 'r') as input_file:\n        x1, y1, x2, y2 = map(int, input_file.readline().split())\n        px1, py1, px2, py2 = map(int, input_file.readline().split())\n\n        # Calculate the minimum area of a square that covers both rectangles\n        min_x = min(x1, px1)\n        max_x = max(x2, px2)\n        min_y = min(y1, py1)\n        max_y = max(y2, py2)\n\n        side_length = (max_x - min_x) + (max_y - min_y)\n        area = side_length ** 2\n\n        with open('square.out', 'w') as output_file:\n            print(area, file=output_file)\n\n\ncalculate_minimum_area()\n```", "time_gen": "\ntime generating: 5.725872s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=664": {"code": "```\nn = int(input())\nwords = [input().split() for _ in range(n)]\nblocks = [0] * 26\nfor w1, w2 in words:\n    for c in set(w1 + w2):\n        blocks[ord(c) - ord('a')] += 1\nfor i, count in enumerate(blocks):\n    print(count)\n```", "time_gen": "\ntime generating: 4.102002s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=665": {"code": "```python\nm, n, k = map(int, input().split())\nsignal = [input() for _ in range(m)]\nwith open('cowsignal.out', 'w') as f:\n    for i in range(k*m):\n        line = ''\n        for j in range(k*n):\n            if i % m < m and j % n < n:\n                line += signal[i // m][j // n]\n            else:\n                line += '.'\n        f.write(line + '\\n')\n```", "time_gen": "\ntime generating: 3.380714s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=666": {"code": "```\nN, Q = map(int, input().split())\npositions = list(map(int, input().split()))\npositions.sort()\n\ndef query(A, B):\n    if A > B:\n        return 0\n    left = bisect_left(positions, A)\n    right = bisect_right(positions, B)\n    return right - left\n\nfor _ in range(Q):\n    A, B = map(int, input().split())\n    print(query(A, B))\n```", "time_gen": "\ntime generating: 3.404753s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=667": {"code": "```\nfrom collections import defaultdict\n\nN = int(input())\ncity_state_map = defaultdict(list)\n\nfor _ in range(N):\n    city, state = input().split()\n    city_state_map[state].append(city)\n\nspecial_pairs = 0\nfor cities in city_state_map.values():\n    for i in range(len(cities)):\n        for j in range(i + 1, len(cities)):\n            if cities[i][2:].upper() == cities[j][:2]:\n                special_pairs += 1\n\nprint(special_pairs)\n```", "time_gen": "\ntime generating: 3.917613s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=668": {"code": "```\nfrom collections import deque\n\nN = int(input())\ngraph = [[] for _ in range(N)]\nmax_reach = 0\n\nfor i in range(N):\n    x, y, p = map(int, input().split())\n    for j in range(N):\n        dx = abs(x - j)\n        dy = abs(y - j)\n        if dx <= p and dy <= p:\n            graph[i].append(j)\n\ndef bfs(s):\n    visited = [False] * N\n    queue = deque([(s, 1)])  # (node, distance)\n    max_distance = 0\n\n    while queue:\n        node, dist = queue.popleft()\n        if not visited[node]:\n            visited[node] = True\n            max_distance = max(max_distance, dist)\n\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    queue.append((neighbor, dist + 1))\n\n    return max_distance\n\nfor i in range(N):\n    max_reach = max(max_reach, bfs(i) + 1)\n\nprint(max_reach)\n```", "time_gen": "\ntime generating: 6.821241s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=669": {"code": "```\nfrom math import sqrt, ceil\nn = int(input())\ncoords = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    coords.append((x, y))\n\ndef distance(c1, c2):\n    return (c2[0] - c1[0])**2 + (c2[1] - c1[1])**2\n\nmax_distance = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        max_distance = max(max_distance, distance(coords[i], coords[j]))\n\nx = ceil(sqrt(max_distance))\nprint(x)\n```", "time_gen": "\ntime generating: 4.188828s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=670": {"code": "```\npython\ndef checklist():\n    H, G = map(int, input().split())\n    holsteins = [list(map(int, input().split())) for _ in range(H)]\n    guernseys = [list(map(int, input().split())) for _ in range(G)]\n\n    energy = 0\n    xholstein = 0\n    yholstein = 0\n\n    for i in range(1, H+1):\n        if i % (H+G) == 0 or i == 1 or i == H:\n            energy += sum([(a - b)**2 for a, b in zip(holsteins[i-1], [xholstein, yholstein])])\n            xholstein = holsteins[i-1][0]\n            yholstein = holsteins[i-1][1]\n\n    energy += sum([(a - b)**2 for a, b in zip(guernseys[0], [xholstein, yholstein])])\n\n    return str(energy)\n\nprint(checklist())\n```", "time_gen": "\ntime generating: 6.978507s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=671": {"code": "```\nimport sys\n\ndef read_input():\n    N = int(sys.stdin.readline().split()[0])\n    x_L, y_L, x_B, y_B = map(int, sys.stdin.readline().split())\n    posts = []\n    for _ in range(N):\n        post = map(int, sys.stdin.readline().split())\n        posts.append(post)\n    return N, (x_L, y_L), (x_B, y_B), posts\n\ndef solve(N, laser, barn, posts):\n    mirrors = 0\n    dx = barn[0] - laser[0]\n    dy = barn[1] - laser[1]\n\n    if dx == 0:\n        return -1\n    elif dy == 0:\n        return min(abs(post[0] - laser[0]) for post in posts) if any(post[0] != laser[0] for post in posts) else 0\n\n    # horizontal beam\n    for x, y in posts:\n        if abs(x - laser[0]) > abs(laser[0] + dx / 2):\n            mirrors += 1\n            if dy * (x - laser[0]) == dx * (y - laser[1]):\n                return -1\n            dx = x - laser[0]\n            break\n\n    for x, y in posts:\n        if abs(x - laser[0] - dx) < abs(post[0] - laser[0]):\n            mirrors += 1\n            dy = y - laser[1]\n            break\n\n    # vertical beam\n    for y, x in posts:\n        if abs(y - laser[1]) > abs(laser[1] + dy / 2):\n            mirrors += 1\n            if dx * (y - laser[1]) == dy * (x - laser[0]):\n                return -1\n            dy = y - laser[1]\n            break\n\n    for y, x in posts:\n        if abs(y - laser[1] - dy) < abs(post[1] - laser[1]):\n            mirrors += 1\n            dx = x - laser[0]\n            break\n\n    return mirrors\n\nN, laser, barn, posts = read_input()\nprint(solve(N, laser, barn, posts))\n```", "time_gen": "\ntime generating: 13.749895s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=672": {"code": "```\ndef generate_combinations(n, r):\n    if n < 0 or r > n:\n        return []\n    elif r == 0:\n        return [[]]\n    else:\n        combinations = []\n        for i in range(len(generate_combinations(n-1, r-1))):\n            combinations.append([n-1] + generate_combinations(n-1, r-1)[i])\n        if r > 1:\n            combinations.append(generate_combinations(n-1, r)[0])\n        return combinations\n\ndef solve():\n    N = int(input())\n    points = []\n    for _ in range(N):\n        x, y = map(int, input().split())\n        points.append((x, y))\n    \n    lots = generate_combinations(N, 3)\n    values = [0] * (N-2)\n    for lot in lots:\n        trees = set()\n        for point1 in lot:\n            for point2 in lot:\n                if point1 != point2:\n                    tree = (min(point1[0], point2[0]), min(point1[1], point2[1]))\n                    while tree in points:\n                        points.remove(tree)\n                        tree = ((tree[0] + 1) % N, (tree[1] + 1) % N)\n        values[len(lot) - 3] += 1\n    \n    for value in values:\n        print(value)\n\nif __name__ == \"__main__\":\n    solve()\n```", "time_gen": "\ntime generating: 8.749649s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=673": {"code": "```\nfrom collections import Counter\n\nN, M, K = map(int, input().split())\nfj_scores = list(map(int, input().split()))\nfp_scores = list(map(int, input().split()))\n\nfj_sorted_scores = sorted(fj_scores)\nfp_sorted_scores = sorted(fp_scores)\n\ncount = 0\nfor i in range(N - K + 1):\n    for j in range(M - K + 1):\n        fj_win_count = 0\n        for k in range(K):\n            if fj_sorted_scores[i + k] > fp_sorted_scores[j + k]:\n                fj_win_count += 1\n        count += fj_win_count\n\nprint(count % 100000009)\n```", "time_gen": "\ntime generating: 5.706137s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=674": {"code": "```\nimport heapq\n\nN, K = map(int, input().split())\ncosts = []\nfor _ in range(N):\n    M = int(input())\n    cost = list(map(int, input().split()))\n    costs.append(sorted(cost))\n\nheap = [(0, [])]\ntotal_cost = 0\nrobots = []\n\nwhile heap and len(robots) < K:\n    current_cost, current_microcontrollers = heapq.heappop(heap)\n    if not robots or any(set(current_microcontrollers) != set(robot[1]) for robot in robots):\n        total_cost += current_cost\n        robots.append((current_cost, current_microcontrollers))\n    else:\n        for i, cost in enumerate(costs):\n            if any(c in cost for c in current_microcontrollers[i]):\n                new_cost = sum(min(c, cost) for c, cost in zip(current_microcontrollers, costs))\n                heapq.heappush(heap, (new_cost, [c for c in current_microcontrollers]))\n        break\n\nprint(total_cost)\n```", "time_gen": "\ntime generating: 6.99088s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=687": {"code": "```\npython\nN = int(input())\ncows_milk = {}\nfor _ in range(N):\n    cow, milk = input().split()\n    if cow not in cows_milk:\n        cows_milk[cow] = 0\n    cows_milk[cow] += int(milk)\n\nmin_milk = min(cows_milk.values())\nif len([cow for cow, milk in cows_milk.items() if milk == min_milk]) > 1:\n    print(\"Tie\")\nelse:\n    second_smallest = sorted([(cow, milk) for cow, milk in cows_milk.items() if milk > min_milk], key=lambda x: x[1])[0]\n    print(second_smallest[0])\n```", "time_gen": "\ntime generating: 5.878845s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=688": {"code": "```\nfrom itertools import permutations\n\nN = int(input())\nwins = 0\nfor p in permutations([1,2,3], 3):\n    cow1_wins = 0\n    for i in range(N):\n        if (p[i-1] == 1 and p[N+i-1] == 2) or (p[i-1] == 2 and p[N+i-1] == 3) or (p[i-1] == 3 and p[N+i-1] == 1):\n            cow1_wins += 1\n    wins = max(wins, cow1_wins)\nprint(wins)\n```", "time_gen": "\ntime generating: 5.259246s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=689": {"code": "```\ndef count_steps(filename):\n    with open(filename, 'r') as f:\n        N = int(f.readline())\n        tips = [list(line.strip()) for line in f.readlines()]\n        \n    steps = 0\n    while True:\n        toggleable = False\n        for i in range(N):\n            for j in range(N):\n                if tips[i][j] == '1':\n                    for k in range(i, N):\n                        for col in range(j, N):\n                            if all(tips[m][col] == '0' for m in range(k+1)):\n                                toggleable = True\n                                steps += 1\n                                for m in range(k+1):\n                                    for p in range(col):\n                                        tips[m][p] = str(int(tips[m][p]) ^ 1)\n                                break\n                        if toggleable:\n                            break\n                    if toggleable:\n                        break\n        if not any('1' in line for line in tips):\n            break\n\n    return steps\n\n\nprint(count_steps('cowtip.in'))\n```", "time_gen": "\ntime generating: 6.845118s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=690": {"code": "```\nimport heapq\n\nN, T_max = map(int, open(\"cowdance.in\", \"r\").readline().strip().split())\ndurations = [int(line.strip()) for line in open(\"cowdance.in\", \"r\")]\n\nheap = []\nK = 0\ntotal_time = 0\nwhile K < N and total_time <= T_max:\n    heapq.heappush(heap, durations[K])\n    total_time += heapq.heappop(heap)\n    K += 1\n\nprint(K)\n```", "time_gen": "\ntime generating: 4.156618s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=691": {"code": "```\nfrom collections import defaultdict\n\nN = int(input())\nFJ_Gestures = input().strip()\n\nlast_switch = 0\nmax_wins = 0\ncurr_wins = 0\n\nfor i, gesture in enumerate(FJ_Gestures):\n    if (i - last_switch) > 1:\n        curr_wins += 1\n        max_wins = max(max_wins, curr_wins)\n    elif (gesture == FJ_Gestures[0]):\n        curr_wins = 1\n    else:\n        curr_wins += 1\n\nprint(max_wins)\n```", "time_gen": "\ntime generating: 4.499099s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=692": {"code": "```\ndef cowcode(s, N):\n    res = s\n    for _ in range(N.bit_length()):\n        if (N >> _) & 1:\n            res = res[1:] + res[0]\n        else:\n            res += res[-1] + res[:-1]\n    return res[N-1]\n\nwith open('cowcode.in', 'r') as f:\n    s, N = f.readline().strip().split()\n    N = int(N)\n\nprint(cowcode(s, N))\n```", "time_gen": "\ntime generating: 3.630711s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=693": {"code": "```\nn = int(input())\nunbalanced = 0\nfor i in range(n):\n    left = sum(1 for j in range(i) if h[j] > h[i])\n    right = sum(1 for j in range(i+1, n) if h[j] > h[i])\n    if abs(left - right) > (2 * min(left, right)):\n        unbalanced += 1\nprint(unbalanced)\n```", "time_gen": "\ntime generating: 3.131745s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=694": {"code": "```\nimport sys\n\nN, K = map(int, input().split())\nFJ_gestures = []\n\nfor _ in range(N):\n    FJ_gestures.append(input())\n\ncurrent_gesture = None\nswitches = 0\nwins = 0\n\nfor gesture in FJ_gestures:\n    if gesture != current_gesture:\n        if switches < K:\n            switches += 1\n        else:\n            wins += 1\n        current_gesture = gesture\n    elif gesture == 'P':\n        wins += 1\n    else:\n        if current_gesture == 'H':\n            wins += 1\n\nprint(wins)\n```", "time_gen": "\ntime generating: 4.665285s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=695": {"code": "```\ndef cow_nav(input_file):\n    with open(input_file, 'r') as f:\n        N = int(f.readline())\n        barn_map = [list(line.strip()) for line in f.readlines()]\n\n    directions = []\n\n    # Start at the bottom left\n    x, y = 1, 1\n\n    # If we're not facing up, we need to turn right\n    if barn_map[0][y] == 'H':\n        directions.append('Right')\n        while barn_map[0][y] == 'H':\n            y += 1\n            if y > N:\n                return -1\n        x = 1\n\n    # Move forward until we hit a haybale or the top of the barn\n    while x < N and barn_map[x][y] != 'H':\n        directions.append('Forward')\n        x += 1\n\n    # Now move left until we hit the edge of the barn\n    while y > 1 and barn_map[x][y - 1] != 'H':\n        directions.append('Left')\n        y -= 1\n\n    # Now move forward until we reach the top right corner\n    while x < N and barn_map[x][y] == 'E':\n        directions.append('Forward')\n        x += 1\n\n    return len(directions)\n\nprint(cow_nav('cownav.in'))\n```", "time_gen": "\ntime generating: 8.237083s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=696": {"code": "```\nn = int(input())\nproficiencies = list(map(int, input().split()))\nparents = [int(x) - 1 for x in input().split()[1:]]\n\ncounts = {}\nfor i in range(1, n):\n    parent = parents[i]\n    if parent not in counts:\n        counts[parent] = 0\n    if proficiencies[i] > proficiencies[parent]:\n        counts[parent] += 1\n\nwith open('promote.out', 'w') as f:\n    for i in range(n):\n        if i == 0 or (i != 0 and i not in counts):\n            print(0, file=f)\n        else:\n            print(counts[i-1], file=f)\n```", "time_gen": "\ntime generating: 4.885105s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=697": {"code": "```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport heapq\n\nN, K = map(int, raw_input().split())\nworkloads = [int(raw_input()) for _ in range(N)]\n\npq = [(a, i) for i, a in enumerate(workloads)]\nheapq.heapify(pq)\n\ntime = 0\nwhile pq:\n    t, f = heapq.heappop(pq)\n    time += t\n    if f > N - K + 1 and pq:\n        time += max((i-f)*c for c, i in pq) // c + (max((i-f)*c for c, i in pq) % c > 0)\n\nprint int(round(time))\n```", "time_gen": "\ntime generating: 4.542199s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=698": {"code": "```\npython\nn = int(input())\narr = [int(x) for x in input().split()]\n\ndp = [[1]*n for _ in range(n)]\nans = 0\n\nfor i in range(50):\n    for j in range(n):\n        if arr[j] <= i:\n            dp[i][j] = max(dp[i-1][k] for k in range(j))\n        else:\n            dp[i][j] = dp[i-1][j]\n\nans = 0\nfor i in range(n-1, -1, -1):\n    if dp[49][i] == n-1-i:\n        ans = n-1-i\n        break\n\nprint(ans)\n```", "time_gen": "\ntime generating: 4.823009s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=711": {"code": "```\ndef count_crossings():\n    N = int(input())\n    crossings = 0\n    last_location = None\n\n    for _ in range(N):\n        cow_id, location = map(int, input().split())\n        \n        if last_location is not None and location != last_location:\n            crossings += 1\n        \n        last_location = location\n    \n    print(crossings)\n\ncount_crossings()\n```", "time_gen": "\ntime generating: 3.115767s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=712": {"code": "```\ndef count_crossing_pairs(s):\n    mapping = {chr(i): i - 64 for i in range(65, 91)}\n    crossing_points = [0] * 52\n    for char in s:\n        index = mapping[char]\n        crossing_points[index] += 1\n\n    total_crossing_pairs = 0\n    for i in range(26):\n        for j in range(i + 1, 26):\n            if abs(mapping[s[i*2]] - mapping[s[j*2]]) == (j - i):\n                total_crossing_pairs += 1\n\n    return total_crossing_pairs\n\nif __name__ == \"__main__\":\n    with open(\"circlecross.in\", \"r\") as f:\n        s = f.read().strip()\n    print(count_crossing_pairs(s))\n```", "time_gen": "\ntime generating: 5.116356s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=713": {"code": "```\nimport heapq\nN = int(input())\nqueue = []\ntime = 0\nfor _ in range(N):\n    arrival, duration = map(int, input().split())\n    time += arrival - (arrival // (time + duration) * (arrival // (time + duration)) + max(0, time + duration - arrival))\n    heapq.heappush(queue, time + duration)\nwhile queue:\n    time = heapq.heappop(queue)\nprint(time)\n```", "time_gen": "\ntime generating: 3.696256s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=714": {"code": "```\npython\nimport heapq\n\nC, N = map(int, input().split())\n\nchickens = [(int(input()), i) for i in range(1, C+1)]\ncows = [(int(i), int(j)) for j in range(N) for i in [int(x) for x in input().split()]]\n\nchickens.sort()\ncows.sort()\n\npairs = 0\nheap = []\nfor cow in cows:\n    while heap and heap[0][0] < cow[1]:\n        heapq.heappop(heap)\n    if heap:\n        pairs += 1\n        heapq.heappush(heap, (cow[0], len(cow)))\n\nprint(pairs)\n```", "time_gen": "\ntime generating: 4.894502s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=715": {"code": "```\ndef maxcross(n, k, b):\n    bad = set()\n    for _ in range(b):\n        x = int(input())\n        bad.add(x)\n\n    min_fix = n\n    curr_len = 0\n    prev_bad = None\n    for i in range(1, n+1):\n        if i in bad:\n            if prev_bad is not None and i - prev_bad > k:\n                min_fix = min(min_fix, i - (prev_bad + k))\n            prev_bad = i\n            curr_len = 0\n        else:\n            curr_len += 1\n\n    return min(min_fix, n - prev_bad)\n\nn, k, b = map(int, input().split())\nprint(maxcross(n, k, b))\n```", "time_gen": "\ntime generating: 4.433364s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=716": {"code": "```\nfrom collections import deque\n\ndef count_cows():\n    n, k, r = map(int, input().split())\n    roads = []\n    cows = [(int(input()), int(input())) for _ in range(k)]\n    graph = [[[] for _ in range(n)] for _ in range(n)]\n\n    for _ in range(r):\n        a, b, c, d = map(int, input().split())\n        graph[a-1][b-1].append((c-1, d-1))\n        graph[c-1][d-1].append((a-1, b-1))\n\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if (i, j) not in cows:\n                continue\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                if 0 <= x < n and 0 <= y < n and ((x, y) not in cows or (graph[i][j] and graph[x][y])):\n                    count += 1\n\n    print(count)\n\ncount_cows()\n```", "time_gen": "\ntime generating: 7.140129s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=717": {"code": "```\ndef visit_fj():\n    N, T = map(int, input().split())\n    grass_times = [list(map(int, input().split())) for _ in range(N)]\n\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # east, south, west, north\n    visited_fields = [[False] * N for _ in range(N)]\n    visited_fields[0][0] = True\n\n    def dfs(x, y):\n        if x < 0 or x >= N or y < 0 or y >= N:\n            return float('inf')\n        if visited_fields[x][y]:\n            return 0\n        visited_fields[x][y] = True\n\n        min_time = float('inf')\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if nx < 0 or nx >= N or ny < 0 or ny >= N:\n                continue\n            time_to_eat = grass_times[nx][ny]\n            time_to_travel = dfs(nx, ny)\n            if time_to_travel == float('inf'):\n                continue\n            min_time = min(min_time, T + time_to_eat + time_to_travel)\n\n        return min_time\n\n    print(dfs(N - 1, N - 1))\n```", "time_gen": "\ntime generating: 8.073198s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=718": {"code": "Here is the Python code for the problem:\n```\nn = int(open('nocross.in', 'r').readline())\nfields1 = [int(x) for x in open('nocross.in', 'r').readlines()[:n]]\nfields2 = [int(x) for x in open('nocross.in', 'r').readlines()[n:]]\ncount = 0\nfor i in range(n):\n    if abs(fields1[i] - fields2[n-i-1]) <= 4:\n        count += 1\nprint(count)\n```", "time_gen": "\ntime generating: 4.066537s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=719": {"code": "```\ndef count_crossing_pairs(crossing_points):\n    n = len(crossing_points) // 2\n    pairs_counted = [0] * (n + 1)\n    total_crossing_pairs = 0\n    \n    for i in range(n):\n        for j in range(i, n):\n            if crossing_points[i*2 + 1] > crossing_points[j*2]:\n                a, b = min(i, j), max(i, j)\n            elif crossing_points[i*2 + 1] < crossing_points[j*2]:\n                a, b = max(i, j), min(i, j)\n            else:\n                continue\n            \n            if (b - a) % 2 == 0:\n                total_crossing_pairs += (b - a) // 2\n            pairs_counted[b] -= (a + 1)\n            pairs_counted[a] += (b - a)\n    \n    for i in range(n):\n        total_crossing_pairs += sum(pairs_counted[:i]) * 2\n    \n    return total_crossing_pairs\n\nN = int(input().strip())\ncrossing_points = [int(x) for x in input().split() for _ in range(2)]\nprint(count_crossing_pairs(crossing_points))\n```", "time_gen": "\ntime generating: 7.307592s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=720": {"code": "```\n```python\ndef min_crossing_pairs(fields):\n    n = len(fields)\n    count = 0\n    for i in range(n):\n        if fields[i] != (i+1) % n:\n            count += 1\n    return count\n\n\nn = int(input())\nfields1 = [int(x) for x in input().split()]\nfields2 = [int(x) for x in input().split()]\n\nprint(min_crossing_pairs(fields1))\n```", "time_gen": "\ntime generating: 4.305204s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=721": {"code": "```\ndef nocross():\n    N = int(input())\n    breeds_left = list(map(int, input().split()))\n    breeds_right = list(map(int, input().split()))\n    \n    left, right = 0, 0\n    count = 0\n    \n    while right < N:\n        if breeds_left[left] - breeds_right[right] <= 4 or breeds_right[right] - breeds_left[left] <= 4:\n            count += 1\n            left += 1\n            right += 1\n        elif breeds_left[left] - breeds_right[right] > 4 and breeds_right[right] - breeds_left[left] > 4:\n            if breeds_left[left] < breeds_right[right]:\n                left += 1\n            else:\n                right += 1\n        else:\n            if breeds_left[left] - breeds_right[right] > 0:\n                left += 1\n            else:\n                right += 1\n    \n    print(count)\n\nnocross()\n```", "time_gen": "\ntime generating: 5.734934s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=722": {"code": "```\nimport sys\n\nN, K = map(int, sys.stdin.readline().split())\nsideA = list(map(int, (sys.stdin.readline().split())[1:] for _ in range(N)))\nsideB = list(map(int, (sys.stdin.readline().split())[1:] for _ in range(N)))\n\ndef count_unfriendly_pairs():\n    unfriendly_pairs = 0\n    for a, b in zip(sideA, sideB):\n        if abs(a - b) > K:\n            unfriendly_pairs += 1\n    return unfriendly_pairs\n\nprint(count_unfriendly_pairs())\n```", "time_gen": "\ntime generating: 3.636628s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=735": {"code": "```\nx, y = map(int, input().split())\ndistance = 0\nwhile True:\n    if x <= y:\n        distance += (2 ** i) - 1\n        x += (2 ** i)\n    else:\n        distance += (2 ** i) - 1\n        x -= (2 ** i)\n    if x == y:\n        break\nprint(distance)\n```", "time_gen": "\ntime generating: 3.395037s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=736": {"code": "```\ndef count_positions(genomes):\n    spotty_genomes = [g for g in genomes if 'A' in g or 'G' in g]\n    plain_genomes = [g for g in genomes if 'C' in g and 'T' not in g]\n\n    positions = []\n    for i in range(len(genomes[0])):\n        if all(g[i] == 'A' or g[i] == 'G' for g in spotty_genomes) and all(g[i] == 'C' for g in plain_genomes):\n            positions.append(i)\n    return len(positions)\n\nN, M = [int(x) for x in open('cownomics.in').read().strip().split()]\ngenomes = [open('cownomics.in').read().strip().replace('\\n', '').[:M]] * N + [[line[:M]] for line in open('cownomics.in').read().strip().split('\\n')[N:]]\n\nprint(count_positions(genomes))\n```", "time_gen": "\ntime generating: 6.567531s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=737": {"code": "```\nN = int(input())\ncanvas = [list(map(int, input().split())) for _ in range(N)]\n\nfirst_colors = set()\nfor i in range(N):\n    for j in range(N):\n        if canvas[i][j] != 0:\n            first_colors.add(canvas[i][j])\n\noutput = str(len(first_colors))\nprint(output)\n```", "time_gen": "\ntime generating: 3.080166s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=738": {"code": "```\nimport heapq\nM = int(input())\nmilkoutputs = [(x, y) for x, y in [map(int, input().split()) for _ in range(M)]]\nmilkoutputs.sort()\npq = []\ntotaltime = 0\nfor i in range(0, M, 2):\n    if i+1 < M:\n        heapq.heappush(pq, milkoutputs[i][1] + milkoutputs[i+1][1])\n    else:\n        break\nwhile pq:\n    totaltime += heapq.heappop(pq)\nprint(totaltime)\n```", "time_gen": "\ntime generating: 4.109956s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=739": {"code": "```\nimport itertools\nn, m = [int(x) for x in open('cownomics.in').read().split()[0:2]]\nspotty_cows = [list(open('cownomics.in').read().split()[i]) for i in range(1, n+1)]\nplain_cows = [list(open('cownomics.in').read().split()[i]) for i in range(n+1, 2*n+1)]\n\ndef check_spottiness(cow_genomes):\n    spotty_cows_set = set()\n    plain_cows_set = set()\n    \n    for i in range(len(cow_genomes)):\n        if i < n:\n            spotty_cows_set.add(tuple([cow_genomes[i][j] for j in [0, 1, 2]]))\n        else:\n            plain_cows_set.add(tuple([cow_genomes[i][j] for j in [0, 1, 2]]))\n\n    return len(spotty_cows_set), len(plain_cows_set)\n\nspotty_cows_sets, plain_cows_sets = check_spottiness(itertools.zip_longest(*spotty_cows, fillvalue=''))\nplain_cow_genomes_sets = check_spottiness(itertools.zip_longest(*plain_cows, fillvalue=''))\n\ntotal_sets = 0\nfor spotty_set in spotty_cows_sets:\n    for plain_set in plain_cow_genomes_sets:\n        if spotty_set != plain_set:\n            total_sets += 1\n\nprint(total_sets)\n```", "time_gen": "\ntime generating: 9.14698s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=740": {"code": "```\ndef count_pcls(image):\n    n = len(image)\n    pcls = 0\n    \n    for i in range(n):\n        for j in range(n):\n            a, b = image[i][j], ''\n            for k in range(i+1, n):\n                if image[k][j] == a:\n                    break\n                else:\n                    b += image[k][j]\n            c, d = '', ''\n            for k in range(j+1, n):\n                if image[i][k] == a:\n                    break\n                else:\n                    c += image[i][k]\n            if len(set(c)) == 1 and (len(b) > 0 or len(d) > 0):\n                pcls += 1\n    \n    return pcls\n\nn = int(input())\nimage = [input() for _ in range(n)]\nprint(count_pcls(image))\n```", "time_gen": "\ntime generating: 5.694313s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=741": {"code": "```\ndef cow_nomics():\n    N, M = map(int, input().split())\n    spotty_genomes = [input() for _ in range(N)]\n    plain_genomes = [input() for _ in range(N)]\n\n    for i in range(1, M+1):\n        subsequence_spotty = []\n        subsequence_plain = []\n        for j in range(N):\n            if 'A' in spotty_genomes[j][i-1:i] or 'C' in spotty_genomes[j][i-1:i] or 'G' in spotty_genomes[j][i-1:i] or 'T' in spotty_genomes[j][i-1:i]:\n                subsequence_spotty.append(spotty_genomes[j][i-1:i])\n            if 'A' in plain_genomes[j][i-1:i] or 'C' in plain_genomes[j][i-1:i] or 'G' in plain_genomes[j][i-1:i] or 'T' in plain_genomes[j][i-1:i]:\n                subsequence_plain.append(plain_genomes[j][i-1:i])\n        if len(set(subsequence_spotty)) == 1 and len(set(subsequence_plain)) > 1:\n            print(i)\n            return\n    print(M)\n\ncow_nomics()\n```", "time_gen": "\ntime generating: 8.13104s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=742": {"code": "```\nimport sys\n\ndef art_rounds():\n    f = open('art.in', 'r')\n    n = int(f.readline())\n    picowso = []\n    for _ in range(n):\n        row = list(map(int, f.readline().split()))\n        picowso.append(row)\n\n    rounds = 0\n    colors_used = set()\n    while True:\n        found = False\n        for i in range(n):\n            for j in range(n):\n                if picowso[i][j] != 0 and picowso[i][j] not in colors_used:\n                    color = picowso[i][j]\n                    colors_used.add(color)\n                    round_colors = set()\n                    for k in range(n):\n                        for l in range(n):\n                            if (k, l) == (i, j):\n                                continue\n                            if picowso[k][l] == color:\n                                round_colors.add(color)\n                                picowso[k][l] = 0\n                    if len(round_colors) > 1:\n                        rounds += 1\n                        found = True\n                        break\n            if found:\n                break\n        if not found:\n            break\n\n    f.close()\n    print(rounds)\n\nart_rounds()\n```", "time_gen": "\ntime generating: 8.321035s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=743": {"code": "```\nn = int(input())\npainting = list(map(int, input().split()))\nrounds = 0\ncolor = None\nfor i in painting:\n    if i != color and i > 0:\n        rounds += 1\n    color = i\nprint(rounds)\n```", "time_gen": "\ntime generating: 2.740221s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=744": {"code": "```\nN = int(input())\ncanvas = [list(map(int, input().split())) for _ in range(N)]\n\ncolors = set()\nfor i in range(N):\n    for j in range(N):\n        if canvas[i][j] != 0:\n            colors.add(canvas[i][j])\n\nprint(len(colors))\n```", "time_gen": "\ntime generating: 3.238709s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=745": {"code": "```\n```\n\n```python\nimport heapq\nfrom collections import defaultdict\n\nN, M, K, Q = map(int, input().split())\ngraph = defaultdict(dict)\nfor _ in range(M):\n    A, B, L = map(int, input().split())\n    graph[A][B] = L\n    graph[B][A] = L\n\ngrass_types = list(map(int, input().split()))\nupdates = []\nfor _ in range(Q):\n    updates.append(list(map(int, input().split())))\n\npq = [(0, 1)]  # (dist, node)\nvisited = set()\nwhile pq:\n    dist, node = heapq.heappop(pq)\n    if node not in visited:\n        visited.add(node)\n        for neighbor, length in graph[node].items():\n            heapq.heappush(pq, (dist + length, neighbor))\n\nupdates_result = []\nfor update in updates:\n    A, B = update\n    grass_types[A-1] = B\n    pq = [(0, 1)]  # (dist, node)\n    visited = set()\n    while pq:\n        dist, node = heapq.heappop(pq)\n        if node not in visited:\n            visited.add(node)\n            for neighbor, length in graph[node].items():\n                heapq.heappush(pq, (dist + length, neighbor))\n    min_dist = float('inf')\n    for i in range(N):\n        for j in range(i+1, N):\n            if grass_types[i] != grass_types[j]:\n                dist = float('inf')\n                pq = [(0, i)]\n                visited = set()\n                while pq:\n                    d, node = heapq.heappop(pq)\n                    if node not in visited:\n                        visited.add(node)\n                        for neighbor, length in graph[node].items():\n                            heapq.heappush(pq, (d + length, neighbor))\n                        dist = min(dist, d + length)\n                min_dist = min(min_dist, dist)\n    updates_result.append(min_dist)\n\nprint('\\n'.join(map(str, updates_result)))\n```", "time_gen": "\ntime generating: 12.086728s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=746": {"code": "```\npython\nimport re\nimport math\n\ndef cowbasic_to_python(input):\n    program = []\n    for line in input.split('\\n'):\n        if line.strip():\n            if '=' in line:\n                var, expr = line.split('=')\n                if 'MOO {' in expr:\n                    loop_lines = [line for line in input.split('\\n') if line.startswith('  ')]\n                    program.append(f'{var} = {expr}')\n                    program.extend(['for _ in range({}):'.format(len(loop_lines)), *loop_lines])\n                else:\n                    program.append(f'{var} = ({expr}) % (10**9 + 7)')\n            elif 'RETURN' in line:\n                return program[-1].replace('(', '').replace(')', '')\n            elif 'MOO {' in line:\n                loop_lines = [line for line in input.split('\\n') if line.startswith('    ')]\n                program.append(f'{line.strip().split('{')[0]} {{')\n                program.extend(['for _ in range({}):'.format(len(loop_lines)), *loop_lines])\n                program.append('}}')\n\n    return eval('{}'.format(program[-1]))\n\nwith open('cowbasic.in', 'r') as f:\n    input = f.read()\n\nprint(cowbasic_to_python(input))\n```", "time_gen": "\ntime generating: 7.926799s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=759": {"code": "```\nx1, y1, x2, y2 = map(int, input().split())\nbx1, by1, bx2, by2 = map(int, input().split())\ntx1, ty1, tx2, ty2 = map(int, input().split())\n\nvisible_area = 0\n\n# Check if the first billboard is fully or partially visible\nif y1 > ty2:\n    # The entire billboard is above the truck\n    visible_area += (x2 - x1) * (y1 - ty2)\nelif y2 < ty1:\n    # The entire billboard is below the truck\n    visible_area += (x2 - x1) * (ty1 - y1)\nelse:\n    # The truck overlaps with part of the first billboard\n    overlap_x1 = max(x1, tx1)\n    overlap_y1 = max(y1, ty1)\n    overlap_x2 = min(x2, tx2)\n    overlap_y2 = min(y2, ty2)\n    visible_area += (overlap_x2 - overlap_x1) * (overlap_y2 - overlap_y1)\n\n# Check if the second billboard is fully or partially visible\nif by1 > ty2:\n    # The entire billboard is above the truck\n    visible_area += (bx2 - bx1) * (by1 - ty2)\nelif by2 < ty1:\n    # The entire billboard is below the truck\n    visible_area += (bx2 - bx1) * (ty1 - by1)\nelse:\n    # The truck overlaps with part of the second billboard\n    overlap_x1 = max(bx1, tx1)\n    overlap_y1 = max(by1, ty1)\n    overlap_x2 = min(bx2, tx2)\n    overlap_y2 = min(by2, ty2)\n    visible_area += (overlap_x2 - overlap_x1) * (overlap_y2 - overlap_y1)\n\nprint(visible_area)\n```", "time_gen": "\ntime generating: 11.010094s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=760": {"code": "```\nn = int(input())\nshuffles = list(map(int, input().split()))\norder = list(map(int, input().split()))\n\nfrom collections import deque\nd = {i: i for i in range(1, n+1)}\nq = deque([(x-1) for x in order])\n\nfor _ in range(n):\n    q.appendleft(q.pop())\n    d[q[0]] -= 1\n\nfor i in range(1, n):\n    if d[i] == 0:\n        d[q[0]], q.popleft(), d[i] = d[i], q[0], i-1\n    else:\n        break\n\nprint(*[k+1 for k in range(n)], sep='\\n')\n```", "time_gen": "\ntime generating: 4.979216s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=761": {"code": "```\ncow_milk = {'Bessie': 7, 'Elsie': 7, 'Mildred': 7}\ndisplay_cows = []\nfor _ in range(100):\n    highest = max(cow_milk.values())\n    if len([cow for cow, milk in cow_milk.items() if milk == highest]) > 1:\n        display_cows.append(sorted([cow for cow, milk in cow_milk.items() if milk == highest]))[0]\n    else:\n        display_cows.append(max(cow_milk, key=cow_milk.get))\n    with open('measurement.in', 'r') as f:\n        measurements = [line.strip().split() for line in f.readlines()]\n    for measurement in measurements:\n        day, cow, change = int(measurement[0]), measurement[1], int(measurement[2])\n        if cow in cow_milk and (cow == display_cows[-1] or change != 0):\n            cow_milk[cow] += change\n    print(len(set(map(int, [measurement[0] for measurement in measurements]))))\n```", "time_gen": "\ntime generating: 7.015835s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=762": {"code": "```\nimport sys\n\nn = int(input())\nscores = list(map(int, input().split()))\nscores.sort()\n\nmax_score = sum(scores) - min(scores)\nfor i in range(n-2):\n    if sum(scores[i+1:]) // (n-i-2) >= max_score:\n        print(i+1)\n```", "time_gen": "\ntime generating: 2.577446s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=763": {"code": "```\nmax_milk = 0\ndisplay_days = set()\nfor _ in range(int(input(\"\"))):\n    day, cow_id, change = map(int, input().split())\n    milk = G - change\n    if milk > max_milk:\n        max_milk = milk\n        display_days = {day}\n    elif milk == max_milk:\n        display_days.add(day)\nprint(len(display_days))\n```", "time_gen": "\ntime generating: 3.511882s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=764": {"code": "```\ndef count_stable_positions():\n    N = int(input())\n    a = list(map(int, input().split()))\n    \n    stable_positions = set()\n    for i in range(N):\n        seen = set()\n        curr_pos = i\n        for _ in range(N):\n            next_pos = (curr_pos + a[curr_pos] - 1) % N\n            if next_pos not in seen:\n                seen.add(next_pos)\n                curr_pos = next_pos\n            else:\n                break\n        stable_positions.add(curr_pos+1)\n\n    return len(stable_positions)\n\nprint(count_stable_positions())\n```", "time_gen": "\ntime generating: 4.100551s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=765": {"code": "```\npython\nN, D = map(int, input().split())\nBessie_values = []\nElsie_values = []\n\nfor _ in range(N):\n    bessie_value, elsie_value = map(int, input().split())\n    Bessie_values.append(bessie_value)\n    Elsie_values.append(elsie_value)\n\nminimum_gifts = [0] * N\n\nfor i in range(N):\n    Bessie_pies = sorted((j for j in range(N) if abs(Bessie_values[i] - Elsie_values[j]) <= D), reverse=True)\n    for pie_index in Bessie_pies:\n        gifts = 1\n        while gifts < N:\n            min_Diff = float('inf')\n            Bessie_pie = pie_index\n            for j in range(N):\n                if abs(Bessie_values[Bessie_pie] - Elsie_values[j]) <= D and j not in [Bessie_pies[k] for k in range(len(Bessie_pies))]:\n                    diff = abs(Elsie_values[pie_index] - Bessie_values[j])\n                    min_Diff = min(min_Diff, diff)\n                    Bessie_pie = j\n            if min_Diff > D:\n                break\n            gifts += 1\n        minimum_gifts[i] = gifts\n        break\n\nwith open('piepie.out', 'w') as f:\n    for i in range(N):\n        f.write(str(minimum_gifts[i]) + '\\n')\n```", "time_gen": "\ntime generating: 9.363909s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=766": {"code": "```\nimport sys\n\nN, K = map(int, input().split())\nG = [[] for _ in range(N + 1)]\nC = [0] * (N + 1)\n\nfor i in range(K):\n    b, c = map(int, input().split())\n    C[b] = c\n\nfor i in range(N - 1):\n    x, y = map(int, input().split())\n    G[x].append(y)\n    G[y].append(x)\n\nans = 1\nfor i in range(1, N + 1):\n    if C[i] == 0:\n        for j in range(1, 4):\n            C[i] = j\n            flag = True\n            for x in G[i]:\n                if C[x] == j:\n                    flag = False\n                    break\n            if flag:\n                ans *= 3\n                break\n\nprint(ans % (10**9 + 7))\n```", "time_gen": "\ntime generating: 5.735385s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=767": {"code": "```\nfrom bisect import *\n\ndef solve():\n    N, M = map(int, input().split())\n    flavors = []\n    for _ in range(N):\n        F, S = map(int, input().split())\n        flavors.append((F, S))\n    \n    low, high = 0, max(S)\n    while high - low > 1:\n        mid = (low + high) // 2\n        total_flavor, spiciness = 0, 0\n        for flavor, s in flavors:\n            if spiciness < mid and total_flavor + flavor <= M:\n                spiciness += s\n                total_flavor += flavor\n            else:\n                break\n        \n        if total_flavor >= M:\n            high = mid\n        else:\n            low = mid\n    \n    return high\n\nprint(solve())\n```", "time_gen": "\ntime generating: 5.137092s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=768": {"code": "```\nfrom collections import defaultdict\n\nn = int(input())\ncow_names = []\nfor _ in range(n):\n    cow_names.append(input())\n\nuniqueness_factors = []\n\nfor name in cow_names:\n    substrings = set()\n    for i in range(len(name)):\n        for j in range(i+1, len(name)+1):\n            substrings.add(name[i:j])\n    uniqueness_factor = 0\n    seen = defaultdict(int)\n    for substring in substrings:\n        if seen[substring] == 0:\n            uniqueness_factor += 1\n        seen[substring] += 1\n    uniqueness_factors.append(uniqueness_factor)\n\nfor factor in uniqueness_factors:\n    print(factor)", "time_gen": "\ntime generating: 4.276691s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=769": {"code": "```\nfrom collections import deque\n\ndef can_pushabox():\n    N, M, Q = [int(x) for x in input().split()]\n    barn = []\n    start_box = None\n    goal_box = None\n    for _ in range(N):\n        row = list(input())\n        if 'A' in row:\n            start_row, start_col = [i for i, c in enumerate(row) if c == 'A']\n            start_box = (start_row, start_col)\n        if 'B' in row:\n            box_row, box_col = [i for i, c in enumerate(row) if c == 'B']\n            goal_box = (box_row, box_col)\n        barn.append(list(row))\n\n    for _ in range(Q):\n        R, C = [int(x) for x in input().split()]\n        visited = set()\n        queue = deque([(start_box, 0)])\n        while queue:\n            (x, y), steps = queue.popleft()\n            if (x, y) == (R, C):\n                print(\"YES\")\n                return\n            if (x, y) in visited or barn[x][y] == '#':\n                continue\n            barn[x][y] = '.'\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < N and 0 <= ny < M and barn[nx][ny] == '.':\n                    queue.append(((nx, ny), steps + 1))\n            visited.add((x, y))\n\n        print(\"NO\")\n\ncan_pushabox()\n```", "time_gen": "\ntime generating: 10.256166s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=770": {"code": "```\nn = int(input())\ngifts_taken = [int(i) for i in input().split()]\nans = 0\nfor i in range(n):\n    if gifts_taken[i] == 0:\n        ans += 1\nprint(ans)\n```", "time_gen": "\ntime generating: 2.431147s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=783": {"code": "```\ndef min_tarp_area(filename):\n    with open(filename, 'r') as f:\n        x1, y1, x2, y2 = map(int, f.readline().split())\n        x3, y3, x4, y4 = map(int, f.readline().split())\n\n    tarp_x1 = max(x1, x3)\n    tarp_y1 = max(y1, y3)\n    tarp_x2 = min(x2, x4)\n    tarp_y2 = min(y2, y4)\n\n    tarp_area = (tarp_x2 - tarp_x1) * (tarp_y2 - tarp_y1)\n\n    return str(tarp_area)\n```", "time_gen": "\ntime generating: 5.153894s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=784": {"code": "```\ndef max_time_covered(lifeguards):\n    lifeguards.sort(key=lambda x: (x[0], -x[1]))\n    max_time = 0\n    end_time = 0\n    for start, end in lifeguards:\n        if start > end_time:\n            max_time += start - end_time\n        max_time += end - start\n        end_time = end\n    return max_time\n\nN = int(input())\nlifeguards = []\nfor _ in range(N):\n    start, end = map(int, input().split())\n    lifeguards.append((start, end))\n\nmax_covered = max_time_covered(lifeguards)\nprint(max_covered - 1)  # subtract 1 because we need to fire one lifeguard\n```", "time_gen": "\ntime generating: 4.873733s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=785": {"code": "```\nimport sys\n\nn = int(input())\nheights = list(map(int, (input() for _ in range(n))))\nheights.sort()\nprint(heights.index(min(heights)) - 1)\n```", "time_gen": "\ntime generating: 2.200899s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=786": {"code": "```\nimport sys\ndef find_max_cover(lifeguards):\n    lifeguards.sort()\n    max_cover = 0\n    for i in range(len(lifeguards) - 1):\n        start = lifeguards[i][0]\n        end = lifeguards[i+1][0]\n        max_cover = max(max_cover, (end-start))\n    return max_cover\n\ndef main():\n    N = int(sys.stdin.readline().strip())\n    lifeguards = []\n    for _ in range(N):\n        start, end = map(int, sys.stdin.readline().strip().split())\n        lifeguards.append((start, end))\n    print(find_max_cover(lifeguards))\n\nif __name__ == \"__main__\":\n    main()\n```", "time_gen": "\ntime generating: 4.664352s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=787": {"code": "```\nn, m, r = map(int, input().split())\ncows_milk = [0] * n\nfor i in range(n):\n    cows_milk[i] = int(input())\n\nstores_buy = []\nfor _ in range(m):\n    q, p = map(int, input().split())\n    stores_buy.append((q, p))\n\nneighbors_rent = []\nfor _ in range(r):\n    r = int(input())\n    neighbors_rent.append(r)\n\nmax_profit = 0\nfor i in range(n):\n    milk = cows_milk[i]\n    for store in stores_buy:\n        q, p = store\n        if milk <= q:\n            max_profit += p * (milk // q) + min(p, q - (milk % q))\n            break\n\nremaining_cows = n - len([i for i, c in enumerate(cows_milk) if c > 0])\nfor i in range(remaining_cows):\n    r = neighbors_rent[i]\n    max_profit += r\n\nprint(max_profit)\n```", "time_gen": "\ntime generating: 7.106354s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=788": {"code": "```\nfrom collections import deque\n\nN, Q = map(int, raw_input().split())\n\ngraph = {i: [] for i in range(1, N+1)}\nfor _ in range(N-1):\n    p, q, r = map(int, raw_input().split())\n    graph[p].append((q, r))\n    graph[q].append((p, r))\n\ndef bfs(start, k):\n    visited = set()\n    queue = deque([(start, start)])\n    while queue:\n        node, parent = queue.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor, relevance in graph[node]:\n                if parent != neighbor and relevance >= k:\n                    queue.append((neighbor, node))\n    return len(visited) - 1\n\nfor _ in range(Q):\n    v, k = map(int, raw_input().split())\n    print bfs(v, k)\n```", "time_gen": "\ntime generating: 7.135178s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=789": {"code": "```markdown\n```\n```python\ndef read_input():\n    n, q = map(int, input().split())\n    connections = []\n    for _ in range(n - 1):\n        p, q, r = map(int, input().split())\n        connections.append((p, q, r))\n    queries = []\n    for _ in range(q):\n        k, v = map(int, input().split())\n        queries.append((k, v))\n    return n, connections, queries\n\n\ndef build_graph(connections):\n    graph = {}\n    for p, q, r in connections:\n        if p not in graph:\n            graph[p] = []\n        if q not in graph:\n            graph[q] = []\n        graph[p].append((q, r))\n        graph[q].append((p, r))\n\n\ndef dfs(graph, node, visited, parent, distance):\n    visited[node] = True\n    for neighbor, dist in graph.get(node, []):\n        if neighbor == parent:\n            continue\n        if not visited[neighbor]:\n            distance = min(distance, dist)\n            dfs(graph, neighbor, visited, node, distance)\n\n\ndef solve_queries(queries, graph):\n    results = []\n    for k, v in queries:\n        visited = {i: False for i in range(1, len(graph) + 1)}\n        parent = None\n        distance = float('inf')\n        dfs(graph, v, visited, None, distance)\n        count = sum(1 for w in range(len(graph)) if visited[w] and graph.get(w, [(None, 0)])[0][1] >= k)\n        results.append(count)\n    return results\n\n\nn, connections, queries = read_input()\nbuild_graph(connections)\nresults = solve_queries(queries, connections)\nfor r in results:\n    print(r)", "time_gen": "\ntime generating: 11.694249s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=790": {"code": "```\nimport sys\n\ndef bfs(graph, source):\n    queue = [source]\n    visited = {source}\n    parent = {}\n    \n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n                parent[neighbor] = node\n    return parent\n\ndef dfs(graph, source):\n    stack = [source]\n    parent = {}\n    \n    while stack:\n        node = stack.pop()\n        for neighbor in graph[node]:\n            if neighbor not in parent:\n                parent[neighbor] = node\n                stack.append(neighbor)\n    return parent\n\ndef find_min_farmers(graph, k):\n    farmers_needed = 0\n    visited = set()\n    \n    while True:\n        bfs_parent = bfs(graph, k)\n        dfs_parent = dfs(graph, k)\n        \n        if len(set(bfs_parent.keys())) + len(set(dfs_parent.keys())) == N - 1:\n            break\n        \n        k = min((bfs_parent.get(node, None) for node in graph), default=None)[0]\n        visited.add(k)\n    \n    return len(visited)\n\nN, K = map(int, sys.stdin.readline().split())\ngraph = {}\nfor i in range(N-1):\n    a, b = map(int, sys.stdin.readline().split())\n    if a not in graph:\n        graph[a] = []\n    if b not in graph:\n        graph[b] = []\n    graph[a].append(b)\n    graph[b].append(a)\n\nprint(find_min_farmers(graph, K))\n```", "time_gen": "\ntime generating: 9.065892s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=791": {"code": "```\ndef spainting(n, m, k):\n    MOD = 10**9 + 7\n    dp = [[0] * (m+1) for _ in range(n+1)]\n    \n    for i in range(k+1):\n        if i > 0:\n            for j in range(m-1):\n                dp[i][j+1] += dp[i][j]\n            for j in range(1, n-k+2):\n                dp[j+k][m] += dp[j+k-1][m-1]\n        else:\n            for j in range(n+1):\n                dp[0][j] = 1\n    \n    return (dp[n][m] - 1 + MOD) % MOD\n\nn, m, k = map(int, input().split())\nprint(spainting(n, m, k))\n```", "time_gen": "\ntime generating: 5.384296s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=792": {"code": "```\nimport heapq\n\nN, K = map(int, input().split())\nlifeguards = []\nfor _ in range(N):\n    start, end = map(int, input().split())\n    lifeguards.append((start, 1))\n    lifeguards.append((end, -1))\n\nlifeguards.sort()\n\nmax_time_covered = 0\ncurrent_time = 0\nlast_start = None\n\nheap = []\nfor event in lifeguards:\n    if event[1] == 1:  # Start of a shift\n        current_time += event[0] - last_start if last_start is not None else 0\n        max_time_covered = max(max_time_covered, current_time)\n        heapq.heappush(heap, -event[0])\n    else:  # End of a shift\n        current_time -= heap[0]\n        heapq.heappop(heap)\n\nprint(max_time_covered)\n```", "time_gen": "\ntime generating: 5.780009s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=793": {"code": "```\nimport sys\nfrom collections import defaultdict\n\nN = int(sys.stdin.readline())\ngraph = defaultdict(list)\nfor i in range(N-1):\n    a, b = map(int, sys.stdin.readline().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\nmin_farmers = [0]*N\n\ndef dfs(u, parent, visited, level):\n    if visited[u]:\n        return\n    visited[u] = True\n    for v in graph[u]:\n        if v == parent:\n            continue\n        if not visited[v]:\n            dfs(v, u, visited, level+1)\n        else:\n            min_farmers[u] += 1\n\nvisited = [False]*N\nfor i in range(N):\n    dfs(i, -1, visited, 0)\n\nprint('\\n'.join(map(str, min_farmers)))\n```", "time_gen": "\ntime generating: 5.639282s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=794": {"code": "```python\nimport math\n\nN = int(input())\n\nsprinklers = []\nfor _ in range(N):\n    x, y = map(int, input().split())\n    sprinklers.append((x, y))\n\n# Initialize a 2D array to keep track of the coordinates that are watered/fertilized.\nwatered_fertilized = [[False for _ in range(N)] for _ in range(N)]\n\nfor x, y in sprinklers:\n    watered_fertilized[x][y] = True\n    if x > 0: watered_fertilized[x-1][y] = True\n    if y > 0: watered_fertilized[0][y] = True\n    if x > 0 and y > 0: watered_fertilized[x-1][y-1] = True\n\n# Function to check if a rectangle is fully watered/fertilized.\ndef is_rectangle_watered_fertilized(x1, y1, x2, y2):\n    for x in range(min(x1, x2), max(x1, x2)+1):\n        for y in range(min(y1, y2), max(y1, y2)+1):\n            if not watered_fertilized[x][y]:\n                return False\n    return True\n\n# Initialize the count of rectangles that are fully watered/fertilized.\ncount = 0\n\n# Iterate over all possible rectangles.\nfor x1 in range(N):\n    for y1 in range(N):\n        for x2 in range(x1+1, N):\n            for y2 in range(y1+1, N):\n                if is_rectangle_watered_fertilized(x1, y1, x2, y2):\n                    count += 1\n\nprint(count % (10**9 + 7))\n```", "time_gen": "\ntime generating: 10.628997s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=807": {"code": "```\n# read input and process it\na, b, x, y = map(int, input().split())\n\n# calculate the minimum distance needed to haul the manure using his tractor\nmin_distance = min(abs(a-x) + abs(y-b), abs(a-y) + abs(x-b))\n\nprint(min_distance)\n```", "time_gen": "\ntime generating: 2.725541s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=808": {"code": "```\nimport heapq\n\nN = int(input())\nx = list(map(int, input().split()))\nballs = []\nfor i in range(N):\n    if i == 0:\n        balls.append((x[i], x[i+1]))\n    elif i == N-1:\n        balls.append((x[i-1], x[i]))\n    else:\n        balls.append((min(x[i-1], x[i]), max(x[i-1], x[i])))\nballs = list(heapq.nsmallest(balls, key=lambda x: abs(x[0]-x[1])))\nprint(len(balls))\n```", "time_gen": "\ntime generating: 4.472927s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=809": {"code": "```\ndef taming(input_file=\"taming.in\", output_file=\"taming.out\"):\n    with open(input_file, \"r\") as f:\n        N = int(f.readline())\n        log_entries = list(map(int, f.readline().split()))\n    \n    last_breakout = 0\n    for i in range(N):\n        if log_entries[i] == -1:\n            continue\n        elif log_entries[i] > 0 and log_entries[i] != 1:\n            last_breakout = log_entries[i]\n        else:\n            last_breakout += 1\n    \n    if last_breakout < 1:\n        with open(output_file, \"w\") as f:\n            print(-1, file=f)\n        return\n\n    min_breakouts = max(last_breakout - (N - log_entries.count(0)), 0)\n    max_breakouts = N - log_entries.count(0)\n\n    with open(output_file, \"w\") as f:\n        print(f\"{min_breakouts} {max_breakouts}\", file=f)", "time_gen": "\ntime generating: 6.504454s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=810": {"code": "```\nfrom bisect import bisect_left\nL, N, r_F, r_B = map(int, input().split())\nrest_stops = []\nfor _ in range(N):\n    rest_stops.append(list(map(int, input().split())))\nrest_stops.sort()\n\ntotal_tastiness = 0\ni = 0\ntime_passed = 0\nwhile i < N:\n    stop_index = bisect_left(rest_stops, [(time_passed + r_F) * (r_B / r_F), i])\n    if stop_index == len(rest_stops):\n        break\n    stop = rest_stops[stop_index]\n    time_at_stop = min(time_passed + r_F - stop[0], r_F)\n    total_tastiness += time_at_stop * stop[1]\n    time_passed += time_at_stop\n    i += 1\n\nprint(total_tastiness)\n```", "time_gen": "\ntime generating: 6.38707s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=811": {"code": "```\n```\n\n```\n```", "time_gen": "\ntime generating: 2.360851s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=812": {"code": "```\nimport heapq\n\nn = int(input())\n\n# Store all coordinates in a list of tuples\ncoords = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    coords.append((x, 1))\n    coords.append((y, -1))\n\n# Sort the coordinates by their value\ncoords.sort()\n\nmin_dist = 0\nmax_dist = sum(abs(x) for x, _ in coords)\nans = max_dist\n\nheap = [0]\n\nfor x, delta in coords:\n    min_dist += delta\n    heapq.heappop(heap)\n    heapq.heappush(heap, min_dist)\n\nwhile heap[0] < ans:\n    ans = heap[0]\n    min_dist -= heapq.heapop(heap)\n\nprint(ans)\n```", "time_gen": "\ntime generating: 5.74847s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=813": {"code": "```\ndef snowboots():\n    N, B = map(int, input().split())\n    fs = list(map(int, input().split()))\n    ss, ds = [], []\n    for _ in range(B):\n        s, d = map(int, input().split())\n        ss.append(s)\n        ds.append(d)\n\n    boots = [1] * B\n    for i in range(1, N-1):\n        for j in range(B):\n            if fs[i] > ss[j]:\n                boots[j] = 0\n                break\n\n    print(*boots, sep='\\n')\n\nsnowboots()\n```", "time_gen": "\ntime generating: 4.782526s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=814": {"code": "```\nimport heapq\nfrom collections import defaultdict\n\nN = int(input())\nparent_directory = {1: ()}\ndirectory_sizes = defaultdict(int)\nfile_positions = {}\n\nfor _ in range(N):\n    name, size, *contents = input().split()\n    size = int(size)\n\n    if contents:\n        children = tuple(map(int, contents))\n        parent_directory[size] = (name,)\n        directory_sizes[name] = size\n        for child in children:\n            file_positions[child] = name\n\nfor file in range(1, N+1):\n    path_length = 0\n    while file != 1:\n        parent = parent_directory[file][0]\n        if parent == 'bessie':\n            break\n        path_length += len(parent) + (2 if parent else 1)\n        file = directory_sizes[parent]\n\n    print(path_length)\n```", "time_gen": "\ntime generating: 5.689218s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=815": {"code": "```\ndef min_entries_to_tamper(log):\n    N = len(log)\n    max_breakouts = sum(1 for i in log if i == 0)\n\n    result = [max_breakouts] + [0] * (N - 1)\n    \n    for i in range(N-1):\n        for j in range(i+1, min(i+4, N)):\n            diff = sum(1 for k in range(i, j) if log[k] != k)\n            result[j] = min(result[j], diff)\n\n    return [str(x) for x in result]\n\nN = int(input())\nlog = list(map(int, input().split()))\nprint('\\n'.join(min_entries_to_tamper(log)))\n```", "time_gen": "\ntime generating: 5.330407s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=816": {"code": "```\nimport heapq\n\nN, M = map(int, input().split())\nslingshots = []\nfor _ in range(N):\n    x, y, t = map(int, input().split())\n    slingshots.append((x, y, t))\n\nmanure_piles = []\nfor _ in range(M):\n    a, b = map(int, input().split())\n    manure_piles.append((a, b))\n\ndef min_time_to_move(a, b, slingshots):\n    heap = [(abs(a - x) + abs(x - y) + t, i) for i, (x, y, t) in enumerate(slingshots)]\n    heapq.heapify(heap)\n    curr_pos = a\n    time = 0\n    while curr_pos != b:\n        dist, idx = heapq.heappop(heap)\n        if curr_pos < x:\n            curr_pos = x\n        else:\n            curr_pos = y\n        time += t\n    return time\n\nfor pile in manure_piles:\n    a, b = pile\n    print(min_time_to_move(a, b, slingshots))\n```", "time_gen": "\ntime generating: 7.553487s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=817": {"code": "```\nfrom collections import deque\n\ndef new_barn(Q):\n    parent = [-1] * (Q + 1)\n    distance = [0] * (Q + 1)\n\n    for i in range(Q):\n        query = input().split()\n        if query[0] == \"B\":\n            if parent[int(query[1])] == -1:\n                parent[int(query[1])] = i\n            else:\n                q = deque([(i, int(query[1]))])\n                while q:\n                    p, c = q.popleft()\n                    if distance[c] < distance[p]:\n                        distance[c] = distance[p]\n                        q.extend((p, x) for x in range(1, len(parent)) if parent[x] == -1))\n            print(distance[int(query[1])])\n        else:\n            print(distance[int(query[0])])\n```\n\nTo run this code, you would execute `new_barn(Q)` where Q is the number of queries.", "time_gen": "\ntime generating: 6.712487s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=818": {"code": "```\ndef gymnasts(N):\n    mod = 10**9 + 7\n    dp = [0] * (N + 1)\n    dp[0] = 1\n    for n in range(1, N + 1):\n        dp[n] = 0\n        for k in range(n):\n            if k % 2 == 0:\n                dp[n] += dp[k]\n            else:\n                dp[n] -= dp[k]\n            dp[n] %= mod\n    return dp[N]\n\nN = int(input())\nprint(gymnasts(N))\n```", "time_gen": "\ntime generating: 4.276204s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=831": {"code": "```\n# Read input from file\nwith open('tttt.in', 'r') as f:\n    rows = [line.strip() for line in f.readlines()]\n\n# Initialize counters\nindividual_cows = 0\nteams = set()\n\n# Check each row, column, and diagonal for a winning condition\nfor i in range(3):\n    # Row checks\n    if rows[i][0] == rows[i][1] == rows[i][2]:\n        individual_cows += 1\n        teams.add((rows[i][0], rows[i][0]))\n    if rows[0][i] == rows[1][i] == rows[2][i]:\n        individual_cows += 1\n        teams.add((rows[0][i], rows[0][i]))\n\n# Diagonal checks\nif rows[0][0] == rows[1][1] == rows[2][2]:\n    individual_cows += 1\n    teams.add((rows[0][0], rows[0][0]))\nif rows[0][2] == rows[1][1] == rows[2][0]:\n    individual_cows += 1\n    teams.add((rows[0][2], rows[0][2]))\n\n# Check for two-cow teams\nfor team in list(teams):\n    if len(team) > 1:\n        teams.remove(team)\n\n# Write output to file\nwith open('tttt.out', 'w') as f:\n    f.write(str(individual_cows) + '\\n')\n    f.write(str(len(teams)) + '\\n')\n```", "time_gen": "\ntime generating: 9.272348s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=832": {"code": "```\nimport sys\n\ndef milk_order():\n    n, m, k = map(int, sys.stdin.readline().split())\n    social_hierarchy = list(map(int, sys.stdin.readline().split()))\n    demand_positions = []\n    \n    for _ in range(k):\n        c, p = map(int, sys.stdin.readline().split())\n        if c == 1:\n            return min(p, m+1) - 1\n        demand_positions.append((c-1, p))\n        \n    # construct the milking order based on social hierarchy and demands\n    order = [i for i in range(n)]\n    for c, p in sorted(demand_positions):\n        if order[c] != p:\n            return \"IMPOSSIBLE\"\n    order.sort()\n    \n    return min([o for o in order if o == 1]) + 1\n\nprint(milk_order())\n```", "time_gen": "\ntime generating: 6.251248s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=833": {"code": "```\nfamily = {}\nfor _ in range(int(input())):\n    x, y = input().split()\n    if y not in family:\n        family[y] = set([x])\n    else:\n        family[y].add(x)\n\ndef get_relation(a, b):\n    queue = [(a, 0)]\n    visited = {a}\n    while queue:\n        parent, depth = queue.pop(0)\n        if parent == b:\n            return f\"{['mother', 'grand-mother', 'great-grand-mother'][depth]} of\" if depth > 1 else \"sister\"\n        for child in family.get(parent, []):\n            if child not in visited:\n                visited.add(child)\n                queue.append((child, depth + 1))\n    return \"cousins\"\n\nprint(get_relation(*input().split()))\n```", "time_gen": "\ntime generating: 5.990063s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=834": {"code": "```\nN = int(input())\nmoo_count = 0\n\nfor _ in range(N):\n    A = list(map(int, input().split()))\n    sorted_ = False\n    while not sorted_:\n        sorted_ = True\n        for i in range(len(A) - 1):\n            if A[i + 1] < A[i]:\n                A[i], A[i + 1] = A[i + 1], A[i]\n                sorted_ = False\n        print(\"moo\")\n    moo_count += 1\n\nprint(moo_count)\n```", "time_gen": "\ntime generating: 3.645354s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=835": {"code": "```\ndef lemonade():\n    n = int(input())\n    w = list(map(int, input().split()))\n    res = 0\n    for i in range(n):\n        if res + w[i] > n:\n            res += w[i]\n        else:\n            res += 1\n    print(res)\n```", "time_gen": "\ntime generating: 2.916996s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=836": {"code": "```\nimport sys\n\ndef find_regions(board):\n    n = len(board)\n    id_region_sizes = {}\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] > 0:\n                id = board[i][j]\n                if id not in id_region_sizes:\n                    id_region_sizes[id] = [(i, j)]\n                else:\n                    regions_id = id_region_sizes[id]\n                    for x, y in regions_id:\n                        if abs(x - i) + abs(y - j) == 1:  # adjacent cell\n                            board[x][y] = 0\n                            break\n                    id_region_sizes[id].append((i, j))\n\n    largest_single_region_size = max(len(regions) for regions in id_region_sizes.values())\n    largest_team_region_size = 0\n    for id, regions in id_region_sizes.items():\n        if len(regions) > 1 and len(regions) == len(set(tuple(region) for region in regions)):\n            largest_team_region_size = max(largest_team_region_size, len(regions))\n\n    return str(largest_single_region_size), str(largest_team_region_size)\n\n\ndef main():\n    n = int(input())\n    board = [list(map(int, input().split())) for _ in range(n)]\n    single_region_size, team_region_size = find_regions(board)\n    print(single_region_size)\n    print(team_region_size)\n\nif __name__ == \"__main__\":\n    main()\n```", "time_gen": "\ntime generating: 8.64027s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=837": {"code": "```\nn = int(input())\nmoo_count = 0\nfor _ in range(n):\n    a = list(map(int, input().split()))\n    sorted = False\n    while not sorted:\n        sorted = True\n        moo_count += 1\n        for i in range(len(a) - 1):\n            if a[i + 1] < a[i]:\n                a[i], a[i + 1] = a[i + 1], a[i]\n                sorted = False\n        for i in range(len(a) - 1, 0, -1):\n            if a[i] < a[i - 1]:\n                a[i], a[i - 1] = a[i - 1], a[i]\n                sorted = False\n\n    print(moo_count)\n```", "time_gen": "\ntime generating: 5.498365s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=838": {"code": "```\nimport sys\nfrom collections import defaultdict\n\nN, M = map(int, open('milkorder.in', 'r').readline().strip().split())\n\nobservations = [map(int, line.strip().split()[1:]) for line in [line.strip() for line in open('milkorder.in', 'r').readlines()][1:]]\n\n# Create a dictionary to store the observations\nobservation_dict = defaultdict(list)\nfor obs in observations:\n    for cow in obs:\n        observation_dict[cow].append(obs)\n\nbest_order = sorted(range(1, N+1))\n\ndef dfs(order):\n    i = 0\n    while i < len(best_order):\n        if best_order[i] not in observation_dict:\n            del best_order[i]\n            i -= 1\n        i += 1\n\n    return best_order\n\nprint(' '.join(map(str, dfs(best_order))))\n```", "time_gen": "\ntime generating: 6.484499s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=839": {"code": "```\nN, W = [int(i) for i in input().split()]\ntotal_weight = 0\ntotal_talent = 0\n\nfor _ in range(N):\n    weight, talent = [int(i) for i in input().split()]\n    total_weight += weight\n    total_talent += talent\n\nif total_weight < W:\n    print(0)\nelse:\n    ratio = (total_talent * 1000) // ((W * 1000) // N)\n    print(ratio)\n```", "time_gen": "\ntime generating: 4.016864s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=840": {"code": "Here is the Python code for this problem:\n\n```markdown\n```\n```\nwork_counter = 0\n\ndef bubble_sort_pass(A):\n    for i in range(len(A)-1):\n        if A[i] > A[i+1]:\n            A[i], A[i+1] = A[i+1], A[i]\n\ndef quickish_sort(A):\n    global work_counter\n    work_counter += len(A)\n    for i in range(len(A)-1):\n        bubble_sort_pass(A)\n        max_left = max(A[:i])\n        min_right = min(A[i:])\n        if max_left <= min_right:\n            break\n\nquickish_sort([int(x) for x in open('sort.in').read().strip().split('\\n')[1:]])\nprint(work_counter)\n```", "time_gen": "\ntime generating: 6.123538s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=841": {"code": "Here is the solution to the problem:\n```markdown\n```\n```python\ndef helpBessie(ID):\n    N = getTrainLength()\n    K = getWindowLength()\n    \n    current_car_index = getCurrentCarIndex()\n    current_pass_index = getCurrentPassIndex()\n    \n    if ID < c[current_car_index]:\n        set(current_car_index, min(get(current_car_index), ID))\n    elif ID >= c[current_car_index+1] and current_car_index < N-K:\n        set(current_car_index+K-1, min(get(current_car_index+K-1), ID))\n    \n    if current_pass_index == 0:  # morning pass\n        if current_car_index + K > N:\n            for i in range(N, current_car_index + K):\n                shoutMinimum(c[i])\n        else:\n            for i in range(current_car_index, current_car_index+K):\n                shoutMinimum(c[i])\n    elif current_pass_index == 1:  # afternoon pass\n        if current_car_index - K < 0:\n            for i in range(0, current_car_index-K):\n                shoutMinimum(c[i])\n        else:\n            for i in range(current_car_index-K, current_car_index):\n                shoutMinimum(c[i])\n```", "time_gen": "\ntime generating: 9.584064s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=842": {"code": "```\nimport sys\nfrom collections import deque\n\ndef shortest_path_length(graph, source):\n    queue = deque([(source, 0)])\n    visited = set()\n    while queue:\n        node, dist = queue.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in graph[node]:\n                queue.append((neighbor, dist + 1))\n    return -1 if len(visited) != len(graph) else sys.maxsize\n\ndef main():\n    N, M = map(int, input().split())\n    graph = [[] for _ in range(N+1)]\n    extra_paths = {}\n    \n    for i in range(N-1):\n        p, q = map(int, input().split())\n        graph[p].append(q)\n        graph[q].append(p)\n    \n    for i in range(M):\n        p, q, r = map(int, input().split())\n        extra_paths[(p, q)] = r\n    \n    with open('disrupt.out', 'w') as f:\n        for i in range(N-1):\n            p, q = graph[i]\n            shortest_path_length_found = False\n            for (node1, node2), length in extra_paths.items():\n                if node1 == p and node2 == q or node1 == q and node2 == p:\n                    f.write(str(length) + '\\n')\n                    shortest_path_length_found = True\n                    break\n            if not shortest_path_length_found:\n                f.write('-1\\n')\n\nif __name__ == \"__main__\":\n    main()\n```", "time_gen": "\ntime generating: 8.976683s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=855": {"code": "```\nc1, m1 = map(int, input().split())\nc2, m2 = map(int, input().split())\nc3, m3 = map(int, input().split())\n\nfor _ in range(100):\n    if m1 > 0:\n        if c2 - m2 < m1:\n            m1 = c2 - m2\n        else:\n            m1 -= c2 - m2\n    elif m2 > 0:\n        if c3 - m3 < m2:\n            m2 = c3 - m3\n        else:\n            m2 -= c3 - m3\n    else:\n        m1 += m3\n        m3 = 0\n\nprint(m3)\nprint(c2 - m2)\nprint(m1)\n```", "time_gen": "\ntime generating: 5.365252s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=856": {"code": "```\nfrom collections import defaultdict\n\nN = int(input())\navailable_buckets = []\n\nbuckets_needed = {}\n\nfor _ in range(N):\n    s, t, b = map(int, input().split())\n    buckets_needed[(s, t)] = b\n    available_buckets.append((t, 0))\n    available_buckets.append((s, b))\n\navailable_buckets.sort()\n\nlast_time = 1\ntotal_buckets = 0\n\nfor time, need in available_buckets:\n    if last_time < time:\n        total_buckets += len(available_buckets) - list(available_buckets).index((last_time, 0)) + 1\n        last_time = time\n    else:\n        total_buckets += need\n        last_time = time\n\nprint(total_buckets)\n```", "time_gen": "\ntime generating: 5.375364s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=857": {"code": "```\nbuckets = [int(x) for x in input().split()]\nbuckets2 = [int(x) for x in input().split()]\n\ntotal_buckets = buckets + buckets2\nfor i in range(100):\n    if sum(min(x, i+1) for x in total_buckets) <= 1000:\n        print(len([x for x in total_buckets if x >= i+1]))\n        break\n```", "time_gen": "\ntime generating: 3.945359s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=858": {"code": "```\nimport heapq\n\nN, M, C = map(int, input().split())\ntimes = list(map(int, input().split()))\nheap = []\n\nfor time in times:\n    heapq.heappush(heap, time)\n\nans = 0\nbus_time = 0\nlast_bus = [0] * (M + 1)\nfor _ in range(N):\n    bus_time += 1\n    last_bus[bus_time % M] = max(last_bus[bus_time % M], heapq.heappop(heap))\n    if bus_time % C == 0:\n        ans = max(ans, last_bus[bus_time % M] - (bus_time // C * C))\n\nprint(ans)\n```", "time_gen": "\ntime generating: 4.609752s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=859": {"code": "```\nn = int(input())\ntimes = []\nfor i in range(n):\n    a, t = map(int, input().split())\n    times.append((a, t))\n\ntimes.sort(key=lambda x: (x[0], -x[1]))\nmax_wait = 0\ncur_time = 0\nfor a, t in times:\n    if cur_time < a:\n        max_wait = max(max_wait, a - cur_time)\n    cur_time += t\n\nprint(max_wait)\n```", "time_gen": "\ntime generating: 4.330624s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=860": {"code": "```\nN, K = map(int, input().split())\nboard = [list(input()) for _ in range(N)]\nwhile True:\n    removed = False\n    to_remove = []\n    for i in range(N):\n        for j in range(10):\n            if board[i][j] == '0':\n                continue\n            color = int(board[i][j])\n            count = 1\n            for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                if 0 <= x < N and 0 <= y < 10 and board[x][y] == str(color):\n                    count += 1\n                else:\n                    break\n            if count >= K:\n                to_remove.append((color, i, j))\n    for color, i, j in set(to_remove):\n        board[i][j] = '0'\n        removed = True\n    if not removed:\n        break\n\nprint('\\n'.join([''.join(row) for row in board]))\n```", "time_gen": "\ntime generating: 7.268822s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=861": {"code": "```\nimport heapq\n\nN, M, K = map(int, input().split())\ntrails = [(int(input()), int(input()), int(input())) for _ in range(M)]\nhaybales = [(int(input()), int(input())) for _ in range(K)]\n\nvisited = [float('inf')] * (N + 1)\nvisited[0] = 0\n\npq = [(0, 0)]  # (time, pasture)\n\nwhile pq:\n    t, pasture = heapq.heappop(pq)\n\n    if t > visited[pasture]:\n        continue\n\n    for a, b, time in trails:\n        if a == pasture and visited[b] + time <= visited[a]:\n            visited[b] = visited[a] + time\n            heapq.heappush(pq, (visited[b], b))\n        elif b == pasture and visited[a] + time <= visited[b]:\n            visited[a] = visited[b] + time\n            heapq.heappush(pq, (visited[a], a))\n\n    for i, (haypasture, yum) in enumerate(haybales):\n        if visited[haypasture] - yum > 0 and visited[haypasture] + yum <= visited[pasture]:\n            print(1)\n            exit()\n\nprint(0)\n```", "time_gen": "\ntime generating: 8.645576s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=862": {"code": "```\nn = int(input())\ncompatible = set()\nfor _ in range(n):\n    a = set(map(int, input().split()))\n    compatible.update(a)\nprint(len(compatible) * (len(compatible) - 1) // 2)\n```", "time_gen": "\ntime generating: 2.031139s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=863": {"code": "```\n```python\nN, K = map(int, input().split())\nskills = list(map(int, (input() for _ in range(N)))))\n\ntotal = 0\nfor i in range(0, N, K):\n    team = min(i + K - 1, N) - i\n    total += max(skills[i:i+team])\n\nprint(total)\n```", "time_gen": "\ntime generating: 3.12781s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=864": {"code": "```\nimport sys\n\nN = int(sys.stdin.readline())\n\ndp = [[0] * 100010 for _ in range(N + 1)]\n\ndef coinFlip(k):\n    if k > N:\n        return 0\n    f = int(sys.stdin.readline())\n    dp[k][0] += f\n    for i in range(1, N - k + 2):\n        dp[k][i] += (dp[k - 1][i - 1] + dp[k - 1][i + 1]) / 2.0\n    return\n\nfor k in range(N + 1):\n    if k > 0:\n        coinFlip(k)\n\nfor i in range(1, N + 1):\n    print(int(dp[i][N] * 100000))\n```", "time_gen": "\ntime generating: 5.35326s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=865": {"code": "```\ndef solve(N, K):\n    a = list(map(int, input().split()))\n    res = []\n    for k in range(1, N+1):\n        b = sorted(a)\n        cnt = 0\n        while True:\n            if a[0] < b[0]:\n                break\n            a.pop(0)\n            cnt += 1\n        if len(res) >= K:\n            res.append(b[0])\n        else:\n            res.append(k)\n    print(len(res))\n    for x in res:\n        print(x)\n```", "time_gen": "\ntime generating: 5.186901s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=866": {"code": "```\ngraph = {}\nfor i in range(2, N+1):\n    graph[i] = []\nfor _ in range(N-1):\n    x, y = map(int, input().split())\n    graph[x].append(y)\n    graph[y].append(x)\n\nordering = [i for i in range(1, N+1)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    ordering.insert(ord(b)-ord('1'), a)\n\nd = [0]*N\nfor p in ordering:\n    if len(graph[p]) == 0:\n        continue\n    for q in graph[p]:\n        d[q] = 1\n    if len([i for i in range(1, N+1) if d[i] and i != p]) > 0:\n        continue\n    d[p] = 1\n\nfor i in range(1, N+1):\n    print(d[i])\n```", "time_gen": "\ntime generating: 6.215979s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=891": {"code": "```\ndef max_score(shells):\n    max_score = 0\n    for i in range(3):\n        if shells[i] == shells[-1]:\n            max_score += 2\n        else:\n            max_score += 1\n    return max_score\n\nN = int(input())\nshells = []\nfor _ in range(N):\n    a, b, g = map(int, input().split())\n    shells.append(a)\n    if a == b:\n        shells.append(b)\n\nprint(max_score(shells))\n```", "time_gen": "\ntime generating: 3.927556s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=892": {"code": "```\nfrom math import inf\n\nn = int(input())\np = list(map(int, input().split()))\nans = 0\ni, j = 1, n-1\nwhile i <= j:\n    if p[i-1] > p[j]:\n        ans += j - (i-1)\n        p[i-1], p[j] = p[j], p[i-1]\n    else:\n        i += 1\nprint(ans)```", "time_gen": "\ntime generating: 3.657444s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=893": {"code": "```\nn = int(input())\nmax_yes_answers = 0\nfor _ in range(n):\n    characteristics = input().split()\n    animal_name, k = characteristics[0], int(characteristics[1])\n    characteristics = set(characteristics[2:])\n    \n    feasible_set = set()\n    for i in range(2**k):\n        temp_set = set()\n        for j in range(k):\n            if (i >> j) & 1:\n                temp_set.add(characteristics[j])\n        feasible_set.add(frozenset(temp_set))\n    \n    max_yes_answers = max(max_yes_answers, len(feasible_set) - 1)\n\nprint(max_yes_answers)\n```", "time_gen": "\ntime generating: 5.00722s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=894": {"code": "```\ngraph = {}\nfor i in range(1, N+1):\n    graph[i] = set()\n\nfor edge in edges:\n    a, b = edge\n    graph[a].add(b)\n    graph[b].add(a)\n\ncolor = {}\ndef dfs(node):\n    for neighbor in graph[node]:\n        if neighbor not in color:\n            color[neighbor] = 1 - color.get(node, 0)\n        else:\n            if color[neighbor] == color.get(node, 0):\n                return False\n    return True\n\nfor node in range(1, N+1):\n    if node not in color:\n        if not dfs(node):\n            print(-1)  # No solution exists.\n        break\n\nprint(len(set(color.values())))  # The minimum number of colors used.\n```", "time_gen": "\ntime generating: 4.911854s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=895": {"code": "```\ndef find_largest_blob():\n    N = int(input())\n    grid = [list(line) for line in input().split(\"\\n\")]\n    \n    def dfs(x, y):\n        if 0 <= x < N and 0 <= y < N and grid[x][y] == '#':\n            grid[x][y] = '.'\n            return 1 + dfs(x-1, y) + dfs(x+1, y) + dfs(x, y-1) + dfs(x, y+1)\n        return 0\n    \n    max_area = 0\n    min_perimeter = float('inf')\n    \n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == '#':\n                area = dfs(i, j)\n                perimeter = 2 * (N - area)\n                if area > max_area or (area == max_area and perimeter < min_perimeter):\n                    max_area = area\n                    min_perimeter = perimeter\n    \n    return \"{} {}\".format(max_area, min_perimeter)\n\nprint(find_largest_blob())\n```", "time_gen": "\ntime generating: 7.005009s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=896": {"code": "```\ndef solve(input):\n    N = int(input.readline())\n    peaks = []\n    for _ in range(N):\n        x, y = map(int, input.readline().split())\n        peaks.append((x, y))\n    \n    peaks.sort()\n    seen = set()\n    count = 0\n    for peak in peaks:\n        if peak[1] > max(seen):\n            count += 1\n            seen.add(peak)\n    return str(count)\n\nwith open(\"mountains.in\", \"r\") as input, open(\"mountains.out\", \"w\") as output:\n    output.write(solve(input))\n```", "time_gen": "\ntime generating: 4.045873s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=897": {"code": "```\nimport math\n\nN, M, K = map(int, input().split())\nword_lengths = {}\nrhyme_classes = {}\n\nfor _ in range(N):\n    s, c = map(int, input().split())\n    word_lengths[c] = max(word_lengths.get(c, 0), s)\n    rhyme_classes.setdefault(c, set()).add(s)\n\nmod = 10**9 + 7\ndp = [[[[[0 for _ in range(K+1)] for _ in range(N+1)] for _ in range(M+1)] for _ in range(26)]] for _ in range(M+1)]\n\nfor i in range(M):\n    e = ord(input()) - ord('A')\n    for j in range(N, 0, -1):\n        if rhyme_classes[j]:\n            dp[i][j][min(word_lengths[j], K)][e] += 1\n        word_lengths[j] -= min(word_lengths[j], K)\n\nans = sum(sum(sum(dp[i][j][:, e])) for i in range(M)) % mod\n\nprint(ans)\n```", "time_gen": "\ntime generating: 6.934428s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=898": {"code": "```\ndef sleepy_cows():\n    N = int(input())\n    p = list(map(int, input().split()))\n    instructions = []\n    i, j = 0, N - 1\n    while i <= j:\n        if p[i] > p[j]:\n            instructions.append(j)\n            p[i], p[j] = p[j], p[i]\n            j -= 1\n        else:\n            i += 1\n    print(len(instructions))\n    for x in instructions:\n        print(x, end=' ')\n```", "time_gen": "\ntime generating: 4.410052s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=899": {"code": "```\ndef shortcut(trails):\n    n, m, t = map(int, input().split())\n    cows = list(map(int, input().split()))\n    trails = [(map(int, line.split()), int(line.split()[-1])) for line in [input() for _ in range(m)]]\n    \n    parent = list(range(n))\n    rank = [0] * n\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        root_x = find(x)\n        root_y = find(y)\n        if root_x != root_y:\n            if rank[root_x] > rank[root_y]:\n                parent[root_y] = root_x\n            else:\n                parent[root_x] = root_y\n                if rank[root_x] == rank[root_y]: \n                    rank[root_y] += 1\n    \n    for trail in trails:\n        a, b, _ = trail[0]\n        union(a - 1, b - 1)\n    \n    ans = sum(sum(trail) * c for (c, trail), i in zip(cows, enumerate(trails)))\n    return max(0, ans - t)\n\nprint(shortcut(input()))\n```", "time_gen": "\ntime generating: 8.092931s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=900": {"code": "```\ndef redistricting():\n    N, K = map(int, input().split())\n    cows = list(input())\n\n    min_tied_districts = 0\n    for i in range(K):\n        tied_cows = 0\n        for j in range(i*N//K + (i < N % K), min((i+1)*N//K + (i+1) < N, N)):\n            if cows[j] == 'G':\n                tied_cows += 1\n            else:\n                if tied_cows > 0:\n                    min_tied_districts += 1\n                    tied_cows = 0\n        if tied_cows > 0:\n            min_tied_districts += 1\n\n    print(min_tied_districts)\n```", "time_gen": "\ntime generating: 4.846197s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=901": {"code": "```\nimport itertools\n\nN, M = map(int, open(\"exercise.in\", \"r\").readline().strip().split())\nstandard_trails = []\nnon_standard_trails = []\n\nfor _ in range(N-1):\n    a, b = map(int, open(\"exercise.in\", \"r\").readline().strip().split())\n    standard_trails.append((a, b))\n\nfor _ in range(M-N+1):\n    a, b = map(int, open(\"exercise.in\", \"r\").readline().strip().split())\n    non_standard_trails.append((a, b))\n\ntotal_routes = 0\n\nfor route in itertools.permutations(standard_trails, N-2):\n    for nst in itertools.combinations(non_standard_trails, 2):\n        total_routes += 1\n\nprint(total_routes)\n```", "time_gen": "\ntime generating: 5.367685s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=902": {"code": "```\nfrom collections import defaultdict\n\nn, k = map(int, input().split())\nc = [int(input()) for _ in range(n - k + 1)]\n\ndp = defaultdict(int)\ndp[0] = 1\nans = 0\n\nfor i in range(1, n + 1):\n    dp[i] += dp[max(i - k, 0)]\n    if c[i - 1] == dp[i]:\n        ans += dp[i]\n    for j in range(c[i], 10**9 + 1):\n        dp[j] += dp[min(j - 1, i - 1)]\n\nprint(ans % (10**9 + 7))\n```", "time_gen": "\ntime generating: 4.589976s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=915": {"code": "```\ndef herding():\n    bessie, elsie, mildred = map(int, input().split())\n    min_moves = 0\n    max_moves = 0\n\n    def min_max_moves(cows):\n        nonlocal min_moves, max_moves\n\n        cows.sort()\n        prev_pos = cows[0]\n        for cow in cows:\n            if cow != prev_pos and cow - prev_pos > 1:\n                min_moves += 2\n                max_moves += 3\n                break\n            elif cow - prev_pos > 1:\n                min_moves += 1\n                max_moves += 2\n                prev_pos = cow\n        else:\n            if cows[0] != 1 and cows[-1] != 10**9:\n                min_moves += 1\n                max_moves += 2\n\n    min_max_moves([bessie, elsie, mildred])\n\n    with open('herding.out', 'w') as f:\n        print(min_moves, file=f)\n        print(max_moves, file=f)\n\nif __name__ == \"__main__\":\n    herding()\n```", "time_gen": "\ntime generating: 6.700446s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=916": {"code": "```\nimport itertools\n\nN, M = map(int, open('revegetate.in', 'r').readline().split())\npastures = [0] * N\nfor _ in range(M):\n    f1, f2 = map(int, open('revegetate.in', 'r').readline().split())\n    pastures[f1-1], pastures[f2-1] = pastures[f2-1], pastures[f1-1]\n\nprint min([''.join(map(lambda x: str(x+1), p)) for p in itertools.permutations(pastures, N) if all(abs(p.count(i)-p.count(j))<=3 for i in range(4) for j in range(i+1, 4))], key=int)\n```", "time_gen": "\ntime generating: 4.904194s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=917": {"code": "```\ndef traffic_flow():\n    n = int(input())\n    data = []\n    for _ in range(n):\n        ramp, low, high = input().split()\n        low, high = int(low), int(high)\n        if ramp == \"on\":\n            data.append((low - 1, high))\n        elif ramp == \"off\":\n            data.append((-high + 1, -low + 1))\n        else:\n            data.append((low, high))\n\n    low, high = 0, float('inf')\n    for i in range(n):\n        if i > 0 and data[i-1][1] < data[i][0]:\n            low = data[i-1][1]\n        if i < n - 1 and data[i][1] < data[i+1][0]:\n            high = data[i][1]\n\n    print(low, high)\n\n    low, high = float('inf'), 0\n    for i in range(n):\n        if i > 0 and data[i-1][1] > data[i][0]:\n            high = data[i-1][1]\n        if i < n - 1 and data[i][0] < data[i+1][1]:\n            low = data[i][0]\n\n    print(low, high)\n```", "time_gen": "\ntime generating: 8.854116s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=918": {"code": "```\nN = int(input())\nmin_moves = 0\nmax_moves = N - 1\nendpoints = [int(input()) for _ in range(N)]\nendpoints.sort()\n\nif endpoints[0] > 1:\n    min_moves += endpoints[0] - 1\nif endpoints[-1] < 2 * (N - 1) + 1:\n    max_moves = 2 * (N - 1) - endpoints[-1]\n\nprint(min_moves)\nprint(max_moves)\n```", "time_gen": "\ntime generating: 3.791923s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=919": {"code": "```\ndef solution():\n    n, k = map(int, input().split())\n    rectangles = [list(map(int, input().split())) for _ in range(n)]\n\n    total_area = 0\n    coats = 0\n    painted_area = 0\n\n    for rectangle in rectangles:\n        x1, y1, x2, y2 = rectangle\n        area = (x2 - x1) * (y2 - y1)\n        \n        if coats < k:\n            total_area += area\n            painted_area += area\n        else:\n            painted_area -= min((coats - 1) * ((x2 - x1) + (y2 - y1)) / 2, area)\n            \n    return painted_area\n\nprint(solution())\n```", "time_gen": "\ntime generating: 5.014467s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=920": {"code": "```\nimport math\n\nn, m = map(int, open('revegetate.in', 'r').read().split())\ncows_same = [0] * 2**m\ncows_diff = [0] * (2**m)\n\nfor _ in range(m):\n    f = int(open('revegetate.in', 'r').readline().strip().split()[1:])\n    if f[0] == f[1]:\n        cows_same[f[0]] += 1\n    else:\n        cows_diff[f[0]] += 1\n\nfor i in range(m):\n    for j in range(i+1, m):\n        cows_diff[i+j] += cows_same[i]*cows_same[j]\n\nprint(bin(sum([math.comb(m,i) * math.factorial(i) // (i+1) ** m for i in range(m)])))[2:] if m else '0'\n```", "time_gen": "\ntime generating: 5.814269s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=921": {"code": "```\nfrom collections import defaultdict, deque\nread = lambda: map(int, input().split())\n\nN, Q = read()\nenjoyments = list(read())\ngraph = defaultdict(list)\nfor _ in range(N-1):\n    a, b = read(); graph[a].append(b); graph[b].append(a)\n\nenjoyment_changes = []\nfor _ in range(Q):\n    query_type, i, j = read()\n    if query_type == 1:\n        enjoyment_changes.append((i, next(int(input()))))\n    else:\n        print(XOR_pathway_enjoyment(i, j))\n\ndef XOR_pathway_enjoyment(i, j):\n    pathway = deque([(enjoyments[i], i)])\n    visited = {i}\n    while pathway[-1][1] != j:\n        a, b = pathway[-2]\n        if b not in graph[pathway[-1][1]]:\n            break\n        pathway.append((a ^ b, b))\n        visited.add(b)\n    return pathway[0][0]\n\ndef apply_enjoyment_changes():\n    for i, v in enjoyment_changes:\n        enjoyments[i] = v\n\napply_enjoyment_changes()\n```", "time_gen": "\ntime generating: 7.37734s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=922": {"code": "```\npython\nimport sys\n\nN = int(input())\nstack = list(map(int, [input() for _ in range(N)]))\nclean_stack = []\nsoapy_stacks = [[i] for i in stack]\n\nmax_length = 0\nfor i in range(len(stack)):\n    if soapy_stacks[0][0] == min(clean_stack):\n        clean_stack.append(soapy_stacks.pop(0).pop())\n        max_length = max(max_length, len(clean_stack))\n    else:\n        break\n\nprint(max_length)\n```", "time_gen": "\ntime generating: 3.767945s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=923": {"code": "```\nimport sys\n\nN, K = map(int, raw_input().split())\nrects = []\nfor _ in range(N):\n    x1, y1, x2, y2 = map(int, raw_input().split())\n    rects.append((x1, y1, x2, y2))\n\npaint_area = sum(max(0, (x2 - x1) * (y2 - y1)) for x1, y1, x2, y2 in rects)\nans = paint_area\n\nfor _ in range(2):\n    for i in range(201):\n        for j in range(201):\n            new_area = 0\n            for x1, y1, x2, y2 in rects:\n                if (x1 <= i and i < x2) or (x1 == x2 and y1 <= j and j < y2):\n                    continue\n                new_area += max(0, (min(x2, 200) - max(x1, 0)) * (y2 - y1))\n            ans = max(ans, paint_area + new_area)\n\nprint ans\n```", "time_gen": "\ntime generating: 7.106687s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=924": {"code": "```\ndef cow_date():\n    n = int(input())\n    p = [0] * (10**6 + 1)\n    for _ in range(n):\n        p[int(input())] += 1\n    ans = 0\n    for i in range(2, len(p)):\n        if p[i-1] > 0 and p[i] > 0:\n            ans = max(ans, min(p[i], sum(p[:i-1])))\n    return ans\n\nprint(cow_date())\n```", "time_gen": "\ntime generating: 3.810919s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=925": {"code": "```\nimport sys\nfrom collections import defaultdict\n\nN, M, X, Y = map(int, input().split())\nroads = []\nfor _ in range(M):\n    A, B, D = map(int, input().split())\n    roads.append((A, B, D))\n\n# Build graph and find all connected components (farms)\ngraph = defaultdict(list)\nfor a, b, d in roads:\n    graph[a].append((b, d))\n    graph[b].append((a, d))\n\nvisited = [False] * (N + 1)\n\ndef dfs(i):\n    visited[i] = True\n    for j, d in graph[i]:\n        if not visited[j]:\n            dfs(j)\n\nK = 0\nfor i in range(1, N + 1):\n    if not visited[i]:\n        K += 1\n        dfs(i)\n\n# Now we have K farms. Let's calculate the total number of interesting tracks.\ntotal_tracks = 0\n\ndef get_interesting_tracks(K, X, Y):\n    global total_tracks\n    \n    def dfs_farm(farm):\n        nonlocal total_tracks\n        track_length = sum(roads.count((farm[i-1], farm[i])) for i in range(len(farm)))\n        if track_length >= Y:\n            total_tracks += 1\n\n    visited = [False] * K\n\n    def get_farms():\n        farms = []\n        for i in range(K):\n            if not visited[i]:\n                farm = []\n                dfs_farm(farm)\n                farms.append(tuple(sorted(farm)))\n        return tuple(sorted(farms))\n\n    farms = get_farms()\n\n    for i, farm1 in enumerate(farms):\n        for j, farm2 in enumerate(farms):\n            if i != j and set(farm1).issubset(set(farm2)):\n                continue\n            if len(farm1) > 0:\n                track_length = sum(roads.count((farm1[i-1], farm1[i])) for i in range(len(farm1)))\n                if track_length >= Y:\n                    total_tracks += 1\n\n    return total_tracks\n\nprint(get_interesting_tracks(K, X, Y))\n```", "time_gen": "\ntime generating: 13.276762s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=926": {"code": "```\n```\n\n```python\nimport heapq\ndef solve():\n    N, T = map(int, input().split())\n    flowers = []\n    for _ in range(N):\n        x, y = map(int, input().split())\n        if x > T or y > T:\n            return\n        if len(flowers) < 2:\n            heapq.heappush(flowers, (x, y))\n        else:\n            if flowers[0][1] <= y and flowers[1][0] >= x:\n                heapq.heappop(flowers)\n            heapq.heappush(flowers, (x, y))\n\n    T = int(T**0.5) + 1\n    S = set()\n    for _ in range(min(N, (T+1)**2)):\n        if len(S) < 2:\n            x, y = flowers[0]\n            heapq.heappop(flowers)\n            S.add((x, y))\n        else:\n            a, b = sorted(list(S))[1]\n            c, d = flowers[0]\n            if (a <= c and b >= d) or (a >= c and b <= d):\n                S.remove(a)\n                S.remove(b)\n            break\n\n    area = 0\n    for (x, y), (z, w) in zip(list(S), [(T,T)] + list(S)):\n        area += (z-x+1)*(w-y+1)\n\n    print(area)\n```\n\nNote that you need to run the script with an input file `mowing.in` and output to a file named `mowing.out`.", "time_gen": "\ntime generating: 9.865428s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=939": {"code": "```\ndef read_map(filename):\n    with open(filename, 'r') as f:\n        return [list(line.strip()) for line in f.readlines()]\n\ndef find_shortest_path(map, start, end):\n    queue = [(start, [])]\n    visited = set([start])\n    while queue:\n        (vertex, path) = queue.pop(0)\n        if vertex == end:\n            return path\n        for neighbor in [((v[1]-1,v[0]), 'N'), ((v[1]+1,v[0]), 'S'), ((v[1],v[0]-1), 'W'), ((v[1],v[0]+1), 'E')] + [((map[9][i], i-1), 'L') for i in range(10) if map[9][i] == '.'] + [((map[i][9], i+1), 'B') for i in range(10) if map[i][9] == '.']:\n            if 0 <= neighbor[0] < 10 and 0 <= neighbor[1] < 10 and map[neighbor[0]][neighbor[1]] == '.' and neighbor[1] != 8:\n                if neighbor not in visited:\n                    queue.append((neighbor, path + [neighbor]))\n                    visited.add(neighbor)\n    return None\n\ndef main():\n    map = read_map('buckets.in')\n    for i in range(len(map)):\n        for j in range(len(map[i])):\n            if map[i][j] == 'R':\n                rock = (i, j)\n            elif map[i][j] == 'L':\n                lake = (i, 9)\n            elif map[i][j] == 'B':\n                barn = (9, j)\n\n    shortest_path = find_shortest_path(map, rock, barn)\n\n    if shortest_path is None:\n        print(0)\n    else:\n        print(len(shortest_path) - 1)\n\nif __name__ == \"__main__\":\n    main()\n```", "time_gen": "\ntime generating: 11.24489s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=940": {"code": "```\ndef bfs(graph, start):\n    visited = set()\n    queue = [(start, [start])]\n    while queue:\n        (vertex, path) = queue.pop(0)\n        for next in graph[vertex]:\n            if next not in visited:\n                visited.add(next)\n                queue.append((next, path + [next]))\n    return list(visited)\n\ndef is_connected(graph):\n    nodes = set()\n    for node in graph:\n        nodes.add(node[0])\n        nodes.add(node[1])\n    for node in nodes:\n        if node not in bfs(graph, node):\n            return False\n    return True\n\nN = int(input())\ngraph = []\nfor _ in range(N-1):\n    a, b = map(int, input().split())\n    graph.append((a, b))\n\nif is_connected(graph):\n    for i in range(1, N+1):\n        if set(bfs(graph, j)) == set(range(1, N+1)) for j in range(1, N+1)]:\n            print(i)\n            break\nelse:\n    print(-1)\n```", "time_gen": "\ntime generating: 6.60416s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=941": {"code": "```\nimport itertools\n\ndef is_proper_evolution(sub_pops):\n    for k in range(1, len(sub_pops) + 1):\n        for chars in itertools.combinations('abcdefghijklmnopqrstuvwxyz', k):\n            if all(set(sub_pop).issubset(chars) for sub_pop in sub_pops):\n                return \"yes\"\n    return \"no\"\n\nN = int(input())\nsub_pops = [input().split() for _ in range(N)]\nprint(is_proper_evolution(sub_pops))\n```", "time_gen": "\ntime generating: 3.99498s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=942": {"code": "```\nn = int(input())\ngrid = [input().strip() for _ in range(n)]\ncount_l = 0\nfor i in range(n):\n    count_r = sum(c == 'R' for c in grid[i])\n    if count_l != n - count_r:\n        break\n    count_l += count_r\n    for j in range(n):\n        if grid[j][i] == 'L':\n            count_l -= 1\n    if count_l > 0:\n        row, col = i + 1, 0\n        while True:\n            if grid[row][col] != grid[i][j]:\n                break\n            col += 1\n        print(row, col)\n        exit()\nprint(-1)\n```", "time_gen": "\ntime generating: 5.026877s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=943": {"code": "```\ndef find_segment():\n    n = int(input())\n    segments = []\n    for _ in range(n):\n        x1, y1, x2, y2 = map(int, input().split())\n        segments.append(((x1, y1), (x2, y2)))\n    \n    for i in range(n):\n        segment = segments[i]\n        remaining_segments = segments[:i] + segments[i+1:]\n        \n        # Check if the current segment intersects with any other\n        intersects_with = False\n        for j, seg in enumerate(remaining_segments):\n            x1, y1 = seg[0]\n            x2, y2 = seg[1]\n            x3, y3 = segment[0]\n            x4, y4 = segment[1]\n            \n            if (min(x1, x2) <= max(x3, x4) and min(y1, y2) <= max(y3, y4) and \n                min(x3, x4) <= max(x1, x2) and min(y3, y4) <= max(y1, y2)):\n                intersects_with = True\n                break\n        \n        if not intersects_with:\n            return i+1\n\n    return -1\n\nprint(find_segment())\n```", "time_gen": "\ntime generating: 7.544614s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=944": {"code": "```\nimport sys\nfrom collections import defaultdict\n\nn, m = map(int, sys.stdin.readline().split())\ncow_coords = [map(int, sys.stdin.readline().split()) for _ in range(n)]\nmoo_connections = [(int(a), int(b)) for _ in range(m)]\n\n# Create a dictionary to store moo connections by cow\nmoo_networks = defaultdict(list)\nfor a, b in moo_connections:\n    moo_networks[a].append(b)\n    moo_networks[b].append(a)\n\n# Function to find the smallest enclosing rectangle for a moo network\ndef min_enclosing_rectangle(cow_coords, moo_network):\n    x_coords, y_coords = zip(*[coord for coord in cow_coords if coord[0] in moo_network or coord[1] in moo_network])\n    min_x, max_x = min(x_coords), max(x_coords)\n    min_y, max_y = min(y_coords), max(y_coords)\n\n    return (min_x, min_y, max_x - min_x + 1, max_y - min_y + 1)\n\n# Initialize the minimum perimeter\nmin_perimeter = float('inf')\nfor moo_network in set(tuple(moo_network) for moo_network in moo_networks.itervalues()):\n    x, y, w, h = min_enclosing_rectangle(cow_coords, moo_network)\n    min_perimeter = min(min_perimeter, 2 * (w + h))\n\nprint(min_perimeter)\n```", "time_gen": "\ntime generating: 8.229006s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=945": {"code": "```\npython\nK, N = [int(i) for i in open(\"snakes.in\").read().strip().split()]\na = [int(i) for i in open(\"snakes.in\").read().strip().split()[1:]]\ndp = [[0] * 10001 for _ in range(K+1)]\nfor k in range(1, K+1):\n    for s in range(1, min(s for a_i in a for a_j in (a_i,) if a_j <= s) + 1):\n        for i in range(N):\n            if a[i] <= s:\n                dp[k][s] = max(dp[k][s], dp[k-1][a[i]-1]+(s-a[i]) if k > 0 else a[i]*(a_i-s))\nfor i in range(K+1):\n    print(max(dp[i]))\n```", "time_gen": "\ntime generating: 5.832033s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=946": {"code": "```\nimport math\n\ndef read_input():\n    with open('walk.in', 'r') as f:\n        n, k = map(int, f.readline().split())\n    return n, k\n\n\nn, k = read_input()\n\nmax_m = 0\nfor i in range(1, 2**n):\n    bin_i = bin(i)[2:].zfill(n)\n    m = sum((int(d) << (20 * j)) for j, d in enumerate(bin_i))\n    m %= 2019201997\n    if m > max_m:\n        max_m = m\n\nprint(max_m)\n```", "time_gen": "\ntime generating: 4.334635s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=947": {"code": "```\ndef balance_game():\n    N = int(input())\n    A = list(map(int, input().split()))\n    left_inversions = sum(1 for i in range(N) for j in range(i+1, N) if A[i] and not A[j])\n    right_inversions = sum(1 for i in range(N) for j in range(N+i) if A[N+i-1-j] and not A[N+i-1-i])\n    \n    return abs(left_inversions - right_inversions)\n\nprint(balance_game())\n```", "time_gen": "\ntime generating: 3.586628s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=948": {"code": "```\nfrom collections import deque, defaultdict\n\nN = None\nQ = None\n\nroad_graph = defaultdict(list)\n\ndef getN():\n    return N\n\ndef getQ():\n    return Q\n\nfarm_locations = {}\n\ndef setFarmLocation(ID, X, Y):\n    farm_locations[ID] = (X, Y)\n\nboxes = []\n\nbox1_xmin = 0\nbox1_ymin = 0\nbox1_xmax = 0\nbox1_ymax = 0\n\nbox2_xmin = 0\nbox2_ymin = 0\nbox2_xmax = 0\nbox2_ymax = 0\n\ndef addRoad(A, B):\n    road_graph[A].append(B)\n    road_graph[B].append(A)\n\ndef buildFarms():\n    global N, Q\n    N = getN()\n    Q = getQ()\n\n    for i in range(N - 1):\n        addRoad(i, (i + 1) % N)\n\n    farm_locations = {}\n    for ID in range(N):\n        setFarmLocation(ID, int((ID / N**0.5)) * N**0.5 + min(ID % N**0.5, N - ID % N**0.5), 0)\n        if ID % N**0.5 == (N - ID % N**0.5):\n            setFarmLocation(ID, int((ID / N**0.5)) * N**0.5 + min(ID % N**0.5, N - ID % N**0.5), 1)\n        else:\n            setFarmLocation(ID, int((N - 1) / N**0.5) * N**0.5 + min(N - 1 - ID % N**0.5, ID % N**0.5), 1)\n\ndef notifyFJ(A, B):\n    global box1_xmin, box1_ymin, box1_xmax, box1_ymax\n    global box2_xmin, box2_ymin, box2_xmax, box2_ymax\n\n    queue = deque([(A, B)])\n    visited = set((A, B))\n\n    while queue:\n        a, b = queue.popleft()\n        if farm_locations[a][0] < farm_locations[b][0]:\n            x1, y1 = farm_locations[a]\n            x2, y2 = farm_locations[b]\n        else:\n            x1, y1 = farm_locations[b]\n            x2, y2 = farm_locations[a]\n\n        if (x1 - box1_xmin) * (y1 - box1_ymin) + (x2 - box1_xmax) * (y2 - box1_ymax) < 0:\n            if not boxes or (boxes[0][0] <= x1 and boxes[0][1] <= y1 and boxes[0][2] >= x2 and boxes[0][3] >= y2):\n                box1_xmin = min(box1_xmin, x1)\n                box1_ymin = min(box1_ymin, y1)\n                box1_xmax = max(box1_xmax, x2)\n                box1_ymax = max(box1_ymax, y2)\n\n        if (x1 - box2_xmin) * (y1 - box2_ymin) + (x2 - box2_xmax) * (y2 - box2_ymax) < 0:\n            if not boxes or (boxes[0][0] <= x1 and boxes[0][1] <= y1 and boxes[0][2] >= x2 and boxes[0][3] >= y2):\n                box2_xmin = min(box2_xmin, x1)\n                box2_ymin = min(box2_ymin, y1)\n                box2_xmax = max(box2_xmax, x2)\n                box2_ymax = max(box2_ymax, y2)\n\n        for c in road_graph[a]:\n            if (c, b) not in visited:\n                queue.append((c, b))\n                visited.add((c, b))\n\n    boxes.append((box1_xmin, box1_ymin, box1_xmax, box1_ymax))\n    boxes.append((box2_xmin, box2_ymin, box2_xmax, box2_ymax))\n```", "time_gen": "\ntime generating: 27.886571s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=949": {"code": "```\nimport sys\nfrom collections import deque\n\ndef bfs(grid, N, K):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(0, 0, 0)])\n    visited = set((0, 0, 0))\n    min_cost = float('inf')\n    \n    while queue:\n        x, y, cost = queue.popleft()\n        \n        if x == N - 1 and y == K - 1:\n            return cost\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx < N and 0 <= ny < K and (nx, ny, cost) not in visited:\n                if grid[nx][ny] == -1:  # no cost\n                    queue.append((nx, ny, cost))\n                    visited.add((nx, ny, cost))\n                else:\n                    queue.append((nx, ny, cost + grid[nx][dy]))\n                    visited.add((nx, ny, cost + grid[nx][dy]))\n                    \n        if x > 0 and (x - 1, y, cost) not in visited:\n            queue.append((x - 1, y, cost))\n            visited.add((x - 1, y, cost))\n            \n        if y > 0 and (x, y - 1, cost) not in visited:\n            queue.append((x, y - 1, cost))\n            visited.add((x, y - 1, cost))\n\ndef count_plans(N, K):\n    grid = [[0] * K for _ in range(N)]\n    \n    with open('escape.in', 'r') as f:\n        for i in range(N):\n            row = list(map(int, f.readline().split()))\n            for j in range(K - 1):\n                grid[i][j] = row[j]\n                \n        for i in range(K):\n            col = list(map(int, f.readline().split()))\n            for j in range(N - 1):\n                grid[j][i] = col[j]\n                \n    min_cost = bfs(grid, N, K)\n    \n    with open('escape.out', 'w') as f:\n        print(count_plans(N, K))\n        \ndef main():\n    N, K = map(int, sys.stdin.readline().split())\n    count_plans(N, K)\n\nif __name__ == '__main__':\n    main()\n```", "time_gen": "\ntime generating: 27.447419s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=950": {"code": "```\ndef count_valleys(n, heights):\n    valleys = []\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if (heights[i-1][j-1] < min(heights[i-1][:j]) and \n                heights[i-1][j-1] < min(heights[:i][j-1])):  \n                valley = True\n            else:\n                valley = False\n\n            if valley:\n                # Check for holey region\n                for k in range(max(0, i-2), min(n+1, i+2)):\n                    for l in range(max(0, j-2), min(n+1, j+2)):\n                        if heights[k][l] < heights[i-1][j-1]:\n                            valley = False\n                            break\n\n                # Check if border has higher cell\n                for k in range(max(0, i-2), min(n+1, i+2)):\n                    for l in range(max(0, j-2), min(n+1, j+2)):\n                        if (k != i or l != j) and heights[k][l] > heights[i-1][j-1]:\n                            valley = False\n                            break\n\n                if valley:\n                    valleys.append((i, j))\n\n    return sum([heights[i-1][j-1] for i, j in valleys])\n\nn = int(input())\nheights = [list(map(int, input().split())) for _ in range(n)]\n\nprint(count_valleys(n, heights))\n```", "time_gen": "\ntime generating: 21.602825s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=963": {"code": "```\nfrom collections import defaultdict\n\nK, N = map(int, input().split())\nrankings = [list(map(int, input().split())) for _ in range(K)]\n\nconsistent_pairs = 0\nfor i in range(N):\n    for j in range(i+1, N):\n        if all(x > y for x, y in zip(rankings[k][i-1], rankings[k][j-1]) for k in range(K)):\n            consistent_pairs += 1\n\nprint(consistent_pairs)\n```", "time_gen": "\ntime generating: 6.444758s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=964": {"code": "```\ndef solve():\n    N = int(input())\n    sequence = input().upper()\n\n    left, right = 1, N\n    while left <= right:\n        mid = (left + right) // 2\n        if has_unique_subsequence(sequence, mid):\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left\n\n\ndef has_unique_subsequence(sequence, k):\n    for i in range(len(sequence) - k + 1):\n        subsequence = sequence[i:i+k]\n        if len(set(subsequence)) < k:\n            return False\n    return True\n\n\nif __name__ == \"__main__\":\n    print(solve())\n```", "time_gen": "\ntime generating: 8.263807s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=965": {"code": "```\nfrom collections import defaultdict, deque\n\nN = int(input())\ngraph = defaultdict(list)\nfor _ in range(N):\n    x, y = input().split()\n    graph[x].append(y)\n    graph[y].append(x)\n\nqueue = deque([(name, [name]) for name in \"BessieButtercupBelindaBeatriceBellaBlueBetsySue\"])\nwhile queue:\n    cow, path = queue.popleft()\n    if len(path) == 8:\n        print(\"\\n\".join(path))\n        exit(0)\n    for next_cow in graph[cow]:\n        queue.append((next_cow, path + [next_cow]))\n```", "time_gen": "\ntime generating: 8.055577s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=966": {"code": "```\ndef moobuzz(n):\n    result = ''\n    i = 1\n    while len(result) < n:\n        if i % 15 == 0:\n            result += 'Moo\\n'\n        elif i % 5 == 0:\n            result += 'Moo\\n'\n        elif i % 3 == 0:\n            result += 'Moo\\n'\n        else:\n            result += str(i) + '\\n'\n        i += 1\n    return int(result.split('\\n')[n-1])\n```", "time_gen": "\ntime generating: 6.895343s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=967": {"code": "```\nimport heapq\nN, L = map(int, input().split())\n cows = []\nfor _ in range(N):\n    w, x, d = map(int, input().split())\n    heapq.heappush(cows, (x, d, w))\nmeetings = 0\nt = 0\nwhile len(cows) > 1:\n    for _ in range(len(cows)):\n        x, d, w = heapq.heappop(cows)\n        if d == 1:\n            t += 1\n        elif d == -1:\n            t -= 1\n        if x < L/2:\n            heapq.heappush(cows, (x + d, d, w))\n        else:\n            meetings += 1\n            break\n    for _ in range(len(cows)):\n        x, d, w = heapq.heappop(cows)\n        if x > L/2:\n            heapq.heappush(cows, (L - x, -d, w))\nprint(meetings)\n```", "time_gen": "\ntime generating: 12.781807s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=968": {"code": "```\n```\n```\nN, M = [int(x) for x in open('milkvisits.in', 'r').read().split()[:2]]\n\nfarm_types = list(open('milkvisits.in', 'r').read().strip()[1:])\n\nedges = []\nfor _ in range(N - 1):\n    edge = tuple(int(x) for x in open('milkvisits.in', 'r').read().split()[:2])\n    edges.append(edge)\n\nvisits = []\nfor _ in range(M):\n    visit = list(map(int, open('milkvisits.in', 'r').read().split()[1:3]))\n    visit_type = open('milkvisits.in', 'r').read().split()[-1]\n    visits.append((visit[0], visit[1], visit_type == 'G'))\n\nwith open('milkvisits.out', 'w') as f:\n    for visit in visits:\n        visited_farm_types = []\n        current_farm = visit[0]\n        while current_farm != visit[1]:\n            if (current_farm, visit[1]) not in edges and (visit[1], current_farm) not in edges:\n                raise Exception(\"Invalid edge\")\n            current_farm, _ = (edges.index((current_farm, visit[1])) + 1, 0)\n        f.write('1' if all(farm_type == visit[2] for farm_type in visited_farm_types) else '0')\n```\n", "time_gen": "\ntime generating: 17.358855s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=969": {"code": "```\n```\n\n```python\ndef pump(milk_pipes):\n    n, m = map(int, milk_pipes.readline().split())\n    pipes = []\n    for _ in range(m):\n        a, b, c, f = map(int, milk_pipes.readline().split())\n        pipes.append((a-1, b-1, c, f))\n    \n    memo = {}\n    def dfs(i):\n        if i in memo:\n            return memo[i]\n        if i == n-1:\n            return 0\n        max_flow = 0\n        for j, (next_i, cost, flow) in enumerate(pipes):\n            if next_i == i+1 and i != 0:\n                continue\n            if i < next_i:\n                prev_flow = dfs(next_i)\n                if prev_flow + flow > max_flow:\n                    max_flow = prev_flow + flow\n        memo[i] = max_flow\n        return max_flow\n    \n    ans = dfs(0)\n    print(int(ans/sum(p[2] for p in pipes)))\n```\n\nYou can run the code by copying it into a python file and running it with the pump.in as input.", "time_gen": "\ntime generating: 13.28379s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=970": {"code": "```\n# read input from file\nN, M = [int(i) for i in open('milkvisits.in').readline().split()]\nT = [int(i) for i in open('milkvisits.in').readline().split()]\n\npath_nodes = [[] for _ in range(N+1)]\nfor edge in (open('milkvisits.in').readlines()[:-M]):\n    x, y = map(int, edge.split())\n    path_nodes[x].append(y)\n    path_nodes[y].append(x)\n\n# perform dfs\ndef dfs(node):\n    visited.add(node)\n    for neighbor in path_nodes[node]:\n        if neighbor not in visited:\n            dfs(neighbor)\n            if C[neighbor-1] == T[neighbor-1]:\n                return True\n    return False\n\nvisited = set()\nC = [int(i) for i in (open('milkvisits.in').readlines()[-M:]).split()]\n\n# write answer to file\nwith open('milkvisits.out', 'w') as f:\n    for friend in C:\n        if dfs(A[friend-1]):\n            f.write('1\\n')\n        else:\n            f.write('0\\n')\n\nA = [int(i) for i in (open('milkvisits.in').readlines()[-M:]).split()]\n```", "time_gen": "\ntime generating: 16.086775s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=971": {"code": "```\n```\n\n```python\nfrom collections import deque\n\ndef min_days_to_change_combo():\n    N, M, K = map(int, input().split())\n    S = input()\n    A = [list(map(int, input().split())) for _ in range(M)]\n\n    queue = deque([(0, i) for i in range(M)])\n    memo = {(i,) : float('inf') for i in range(M)}\n    memo[(S[0],)] = 0\n\n    while queue:\n        cost, char_index = queue.popleft()\n        if len(memo[memo.keys()[0]]) == N:\n            return cost\n        for next_char_index in range(M):\n            if A[char_index][next_char_index] > K:\n                continue\n            new_cost = memo[(memo.keys()[0]+(next_char_index,))]\n            queue.append((new_cost + (A[char_index][next_char_index]-K) * len(str(next_char_index)), next_char_index))\n        for streak_length in range(K+1):\n            if len(memo[memo.keys()[0]]) < N - streak_length:\n                new_cost = cost + A[char_index][char_index] * streak_length\n                queue.append((new_cost, char_index))\n\nmin_days_to_change_combo()\n```", "time_gen": "\ntime generating: 14.812571s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=972": {"code": "```\n```python\ndef read_data():\n    N, M = map(int, input().split())\n    cows = []\n    for _ in range(M):\n        w, l, r = map(int, input().split())\n        cows.append((w, l, r))\n    return N, M, sorted(cows)\n\nN, M, cows = read_data()\ndp = [[0] * (M + 1) for _ in range(N + 1)]\n\nfor i in range(M):\n    for j in range(i+1, M+1):\n        for k in range(j+1, N+1):\n            if all(l <= l_cow and r_cow <= r for cow in cows[i:j]):\n                dp[k][j] = max(dp[k][j], dp[k-1][i-1] + sum(w for w, _, _ in cows[i:j]))\n\nprint(max(dp[-1]))\n```", "time_gen": "\ntime generating: 11.113121s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=973": {"code": "```\nn, q = map(int, input().split())\ngraph = {}\ncolor = [0] * (n + 1)\nparent = [-1] * (n + 1)\n\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    if not graph.get(a):\n        graph[a] = []\n    if not graph.get(b):\n        graph[b] = []\n    graph[a].append(b)\n    graph[b].append(a)\n    parent[b] = a\n\ndef dfs(x, c):\n    color[x] = c\n    for y in graph.get(x, []):\n        if parent[y] == x:\n            dfs(y, c)\n\nfor i in range(q):\n    query = list(map(int, input().split()))\n    if len(query) == 3: # Color\n        dfs(query[1], query[2])\n    else: # Query\n        res = set()\n        for y in graph.get(query[1], []):\n            while parent[y] != query[1]:\n                y = parent[y]\n            res.add(color[y])\n        print(len(res))\n```", "time_gen": "\ntime generating: 15.837801s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=974": {"code": "```\nimport math\n\nM = int(input())\nN = int(input())\nK = int(input())\n\n# Calculate the number of permutations with K inversions\np = 1\nfor i in range(N):\n    p *= (i + 1)\np %= M\n\nk_permutations = [0] * N\nk_permutations[0] = 1\nfor i in range(1, N):\n    k_permutations[i] = k_permutations[i - 1] * i\nk_permutations[N - 1] %= M\n\n# Calculate the sum of depths for each permutation\ndepth_sum = [0] * (N + 1)\ndepth_sum[0] = 0\nfor i in range(1, N):\n    depth_sum[i] = depth_sum[i - 1] + i\nfor j in range(N, -1, -1):\n    for k in range(j):\n        if K >= math.comb(k, j - k) and K < math.comb(k + 1, j - k - 1):\n            K -= math.comb(k, j - k)\n            break\n    depth_sum[j] %= M\n\n# Print the sum of depths for each permutation\nfor i in range(N):\n    print((depth_sum[i + 1] - depth_sum[i]) % M)\n\n```", "time_gen": "\ntime generating: 17.828249s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=987": {"code": "```\ndef word_processor():\n    N, K = map(int, input().split())\n    words = input().split()\n    \n    lines = []\n    current_line = \"\"\n    \n    for word in words:\n        if len(current_line) + len(word) + 1 <= K:\n            current_line += \" \" + word\n        else:\n            lines.append(current_line.strip())\n            current_line = \" \" + word\n    \n    if current_line:\n        lines.append(current_line.strip())\n    \n    print(\"\\n\".join(lines))\n```", "time_gen": "\ntime generating: 7.342475s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=988": {"code": "```\n```python\ndef photo():\n    N = int(input())\n    b = list(map(int, input().split()))\n    a = [0] * (N + 1)\n    \n    for i in range(N - 1):\n        if a[i + 1] == 0:\n            a[i] += 1\n            a[i + 1] += a[i]\n        else:\n            a[N] = N + 1\n            break\n    \n    a[N] = N\n    print(' '.join(map(str, a[1:])))\n```", "time_gen": "\ntime generating: 7.495611s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=989": {"code": "```\n```\n\n```\nimport sys\n\ndef solve_k(k, x):\n    if k < x:\n        return 0\n    else:\n        time = (k - x) // (x + 1)\n        speed = min(x + 1, k - time * (x + 1))\n        return time + (k - time * (x + 1)) / speed\n\nK, N = map(int, sys.stdin.readline().split())\nfor _ in range(N):\n    X = int(sys.stdin.readline().strip())\n    print(solve_k(K, X))\n```", "time_gen": "\ntime generating: 8.706094s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=990": {"code": "```\npython\nN, K = map(int, input().split())\nBs = list(map(int, input().split()))\nBs.sort(reverse=True)\n\nans = sum([i // 2 + (1 if i % 2 == 0 else 0) for i in range(K)])\nfor i in range(N):\n    ans += min(Bs[i], K // 2)\n    Bs[i] -= min(Bs[i], K // 2)\n    if len(Bs) > 1:\n        Bs.sort(reverse=True)\n\nans += sum(Bs)\nprint(ans)\n```", "time_gen": "\ntime generating: 7.016174s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=991": {"code": "```\nimport math\n\nN, K, M = map(int, input().split())\n\nX = 0\nwhile True:\n    G = (K * M)\n    Y = min(N - G, X) // X\n    if G + Y >= N:\n        break\n    X += 1\n\nprint(X)\n```", "time_gen": "\ntime generating: 5.185385s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=992": {"code": "```\nimport heapq\n\nn, m = map(int, open(\"wormsort.in\").readline().split())\np = list(map(int, open(\"wormsort.in\").readline().split()))\na = [int(x) for x in open(\"wormsort.in\").readlines(2)[1:]]\nb = [int(x) for x in open(\"wormsort.in\").readlines(2)[1:]][::-1]\nw = [int(x) for x in open(\"wormsort.in\").readlines(2)[1:]][::-1]\n\nheap = [(0, i) for i in range(n)]\nfor i in range(m):\n    a_idx, b_idx, width = a[i], b[i], w[i]\n    heapq.heappush(heap, (width, 0 if i % 2 == 0 else -1))\n    while heap and abs(heap[0][0] - p[a_idx-1]) > abs(p[b_idx-1]-p[heap[0][1]]):\n        heapq.heappop(heap)\n    for j in range(n):\n        if p[j] > p[heap[0][1]]:\n            p[j], p[heap[0][1]], a[a_idx-1], b[b_idx-1] = p[heap[0][1]], p[j], b[b_idx-1], a[a_idx-1]\n    heapq.heapify(heap)\nprint(-1 if n*(n+1)//2 == sum(range(1, n+1)) else min([x[0] for x in heap]))\n```", "time_gen": "\ntime generating: 17.380104s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=993": {"code": "```\nimport sys\nfrom collections import defaultdict, deque\n\nN, M, C = map(int, input().split())\nmooney_list = list(map(int, input().split()))\nroad_dict = defaultdict(list)\nfor _ in range(M):\n    a, b = map(int, input().split())\n    road_dict[a].append(b)\n\ndp = [0] * (N + 1)\nqueue = deque([(N, mooney_list[N])])\nwhile queue:\n    city, mooney = queue.popleft()\n    for neighbor in road_dict[city]:\n        new_mooney = mooney - C * len(road_dict) ** 2\n        if new_mooney > dp[neighbor]:\n            dp[neighbor] = new_mooney\n            queue.append((neighbor, new_mooney))\n\nprint(dp[1])\n```", "time_gen": "\ntime generating: 9.29266s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=994": {"code": "```\npython\nN, Q = map(int, input().split())\nA = list(map(int, input().split()))\nresult = []\nfor _ in range(Q):\n    a, b = map(int, input().split())\n    left, right = 0, len(A) - 1\n    count = 0\n    while left <= right:\n        if A[left] + A[right] == -(A[a-1]):\n            count += (right - left + 1)\n            break\n        elif A[left] + A[right] < -(A[a-1]):\n            left += 1\n        else:\n            right -= 1\n    result.append(count)\n\nprint(*result, sep='\\n')\n```", "time_gen": "\ntime generating: 9.172112s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=995": {"code": "```\nimport heapq\nN, P = map(int, input().split())\nboard = []\nfor _ in range(P):\n    x1, y1, x2, y2 = map(int, input().split())\n    board.append((x2-x1, y2-y1, (x1, y1), (x2, y2)))\n\nheap = [(0, 0, 0)]  # distance, row, col\nvisited = set((0, 0))\nans = float('inf')\n\nwhile heap:\n    d, r, c = heapq.heappop(heap)\n    \n    if (r, c) == (N, N):\n        ans = min(ans, d)\n        continue\n\n    for dx, dy, (x1, y1), (x2, y2) in board:\n        nx1, ny1 = max(0, x1-1), max(0, y1-1)\n        nx2, ny2 = min(N, x2+1), min(N, y2+1)\n\n        if r+dy <= N and c+dx <= N and (nx1, ny1) != (x1, y1) and (nx2, ny2) != (x2, y2):\n            nr, nc = r+dy, c+dx\n            nd = d+1\n\n            if (nr, nc) not in visited:\n                visited.add((nr, nc))\n                heapq.heappush(heap, (nd, nr, nc))\n\nprint(ans)\n```", "time_gen": "\ntime generating: 15.781798s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=996": {"code": "```\ndef solve(n, m):\n    ans = 0\n    for i in range(1, n - 1):\n        if (n + 1) % (i * 2) == 0:\n            ans += 1\n    return pow(2, m, 10**9 + 7) * ans\n\nif __name__ == \"__main__\":\n    with open(\"cave.in\", \"r\") as fin, open(\"cave.out\", \"w\") as fout:\n        n, m = map(int, fin.readline().split())\n        print(solve(n, m), file=fout)\n```", "time_gen": "\ntime generating: 7.993581s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=997": {"code": "```\n```\n\nThis solution is as follows.", "time_gen": "\ntime generating: 3.657015s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=998": {"code": "```\nimport math\n\nN = int(input())\nA = list(map(int, input().split()))\nQ = list(map(int, input().split()))\n\nans = []\nfor i in range(N):\n    if A[i] > Q[i]:\n        ans.append(-1)\n    else:\n        for j in range(i+1, N):\n            if A[j] == Q[i]:\n                ans.append(str(Q[i]-i) + '/1')\n                break\n        else:\n            ans.append(str(A[Q[i-1]] - i) + '/' + str(Q[i-1] - i))\n\nprint('\\n'.join(ans))\n```", "time_gen": "\ntime generating: 8.246477s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1011": {"code": "```\ndef calculate_area(x1, y1, x2, y2, x3, y3):\n    return abs((x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))/2)\n\ndef find_max_area():\n    max_area = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            for k in range(j+1, N):\n                area = calculate_area(X[i], Y[i], X[j], Y[j], X[k], Y[k])\n                if (Y[i]-Y[j])*(X[k]-X[j]) == 0 and (Y[j]-Y[k])*(X[j]-X[i]) == 0:\n                    max_area = max(max_area, area)\n    return 2*max_area\n\nN = int(input())\nX = []\nY = []\nfor i in range(N):\n    x, y = map(int, input().split())\n    X.append(x)\n    Y.append(y)\n\nprint(find_max_area())\n```", "time_gen": "\ntime generating: 10.683318s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1012": {"code": "```\ndef solve():\n    n = int(input())\n    a = input().strip()\n    b = input().strip()\n\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[n][n]\n\nprint(solve())\n```", "time_gen": "\ntime generating: 8.932675s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1013": {"code": "```\nN = int(input())\nK = int(input())\nA1, A2 = map(int, input().split())\nB1, B2 = map(int, input().split())\n\nresult = list(range(1, N+1))\n\nfor _ in range(K):\n    temp = result[A1-1:A2]\n    temp.reverse()\n    result[A1-1:A2] = temp\n    temp = result[B1-1:B2]\n    temp.reverse()\n    result[B1-1:B2] = temp\n\nprint(*result, sep='\\n')\n```", "time_gen": "\ntime generating: 7.577812s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1014": {"code": "```\ndef swap_cows():\n    N, M, K = map(int, input().split())\n    cow_order = list(range(1, N+1))\n    \n    for _ in range(K):\n        for i in range(M):\n            L, R = map(int, input().split())\n            cow_order[L-1], cow_order[R-1] = cow_order[R-1], cow_order[L-1]\n    \n    print('\\n'.join(map(str, cow_order)))\n\nswap_cows()\n```", "time_gen": "\ntime generating: 7.459455s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1015": {"code": "```\nimport math\n\nN = int(input())\npoints = []\nfor _ in range(N):\n    x, y = map(int, input().split())\n    points.append((x, y))\n\ndef area(p1, p2, p3):\n    return abs((p1[0]*p2[1] + p2[0]*p3[1] + p3[0]*p1[1] -\n                (p1[1]+p2[1]+p3[1]))/2.0)\n\ntotal_area = 0\nfor i in range(N):\n    for j in range(i+1, N):\n        for k in range(j+1, N):\n            if ((points[i][0] - points[j][0])**2 + (points[i][1] - points[j][1])**2) == 0:\n                side1_x = points[i][0]\n                side1_y = points[j][1]\n            elif ((points[i][0] - points[k][0])**2 + (points[i][1] - points[k][1])**2) == 0:\n                side1_x = points[i][0]\n                side1_y = points[k][1]\n            elif ((points[j][0] - points[k][0])**2 + (points[j][1] - points[k][1])**2) == 0:\n                side1_x = points[j][0]\n                side1_y = points[k][1]\n\n            if (side1_x > min(x for x, y in points) and side1_x < max(x for x, y in points) and\n                side1_y > min(y for x, y in points) and side1_y < max(y for x, y in points)):\n                total_area += area(points[i], points[j], points[k])\n\nprint((2*total_area) % (10**9 + 7))\n```", "time_gen": "\ntime generating: 19.917961s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1016": {"code": "```\nimport sys\n\nN = int(sys.stdin.readline())\n\nclocks = [int(x) for x in sys.stdin.readline().split()]\ncorridors = []\nfor i in range(N-1):\n    a, b = map(int, sys.stdin.readline().split())\n    corridors.append((a-1, b-1))\n\ndef dfs(start_room, current_clock):\n    if current_clock == 12:\n        return True\n    visited = [False]*N\n    stack = [(start_room, current_clock)]\n    while stack:\n        room, clock = stack.pop()\n        if visited[room]:\n            continue\n        visited[room] = True\n        for corridor in corridors:\n            if abs(corridor[0]-room) + abs(corridor[1]-room) == 1:\n                next_room = corridor[0] if room == corridor[1] else corridor[1]\n                if not visited[next_room]:\n                    stack.append((next_room, (clock+(room+1)%12)%12))\n        if clock % 12 != current_clock-1:\n            return False\n    return True\n\nans = 0\nfor i in range(N):\n    if dfs(i, clocks[i]):\n        ans += 1\nprint(ans)\n```", "time_gen": "\ntime generating: 15.022018s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1017": {"code": "```\nfrom collections import defaultdict\n\nN, M, C = map(int, open('timeline.in', 'r').readline().split())\nS = list(map(int, open('timeline.in', 'r').readline().split()))\nmemories = [list(map(int, line.split())) for _ in range(C)]\n\ndp = [float('inf')] * (M + 1)\nfor i in range(N):\n    dp[S[i]] = min(dp[S[i]], S[i])\n\nfor a, b, x in memories:\n    dp[b] = min(dp[b], dp[a] + x)\n\nprint('\\n'.join(map(str, dp[:N])))\n```", "time_gen": "\ntime generating: 9.878401s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1018": {"code": "```\ndef solve():\n    n = int(input())\n    segs = []\n    for _ in range(n):\n        l, r = map(int, input().split())\n        segs.append((l, r))\n\n    total_complexity = 0\n    for mask in range(1 << n):\n        curr_segs = [segs[i] for i in range(n) if (mask >> i) & 1]\n        curr_complexity = 0\n        prev_end = float('-inf')\n        for seg in curr_segs:\n            if seg[0] > prev_end:\n                curr_complexity += 1\n            prev_end = max(prev_end, seg[1])\n        total_complexity += curr_complexity\n\n    print(total_complexity % (10**9 + 7))\n\nsolve()\n```", "time_gen": "\ntime generating: 10.523944s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1019": {"code": "```python\ndef is_divisible_by_k(edges, k):\n    degrees = [0] * (N + 1)\n    for a, b in edges:\n        degrees[a] += 1\n        degrees[b] += 1\n    \n    paths = 0\n    for i in range(2, N):\n        if degrees[i] % k == 0:\n            paths += 1\n    \n    return (N - 1) % k == 0 and paths >= k\n\n\ndef main():\n    global N\n    with open(\"deleg.in\", \"r\") as f:\n        N = int(f.readline())\n        edges = []\n        for _ in range(N - 1):\n            a, b = map(int, f.readline().split())\n            edges.append((a, b))\n\n    res = \"\"\n    for k in range(1, N):\n        if is_divisible_by_k(edges, k):\n            res += \"1\"\n        else:\n            res += \"0\"\n\n    with open(\"deleg.out\", \"w\") as f:\n        f.write(res)\n\n\nif __name__ == \"__main__\":\n    main()\n```", "time_gen": "\ntime generating: 15.089229s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1020": {"code": "```\ndef read_input():\n    N = int(input())\n    roads = []\n    for _ in range(N-1):\n        a, b = map(int, input().split())\n        roads.append((a, b))\n    return N, roads\n\nN, roads = read_input()\n\n# Calculate the number of paths\nK = 0\nfor edge in roads:\n    if edge[0] == 1 or edge[1] == 1:\n        K += 1\n\nprint(K)\n```", "time_gen": "\ntime generating: 5.891544s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1021": {"code": "```markdown\n```\n```\ndef count_triangles(grid):\n    N = len(grid)\n    count = 0\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == '*':\n                for x in range(-N, N+1):\n                    for y in range(-N, N+1):\n                        if abs(x) + abs(y) != 0 and all(abs(grid[(i+x)//abs(x), (j+y)//abs(y)].index('*')) - abs(x) - abs(y) == 0 for k in range(3)):\n                            count += 1\n    return count\n```", "time_gen": "\ntime generating: 8.205737s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1022": {"code": "```\ndef help():\n    N, K = map(int, input().split())\n    segs = []\n    for _ in range(N):\n        l, r = map(int, input().split())\n        segs.append((l, r))\n    \n    ans = 0\n    for bit in range(1 << N):\n        left = float('inf')\n        right = -float('inf')\n        for i in range(N):\n            if (bit >> i) & 1:\n                left = min(left, segs[i][0])\n                right = max(right, segs[i][1])\n        \n        ans += pow((right - left + 1) // K, K)\n    \n    print(ans % (10**9 + 7))\n\nhelp()\n```", "time_gen": "\ntime generating: 9.705619s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1035": {"code": "```\ndef read_input():\n    n = int(input())\n    stalls = list(map(int, input()))\n    return n, stalls\n\n\ndef solve(n, stalls):\n    occupied_stalls = [i for i, x in enumerate(stalls) if x == 1]\n    max_dist = float('inf')\n    for i in range(len(occupied_stalls)):\n        for j in range(i+2, len(occupied_stalls)+1):\n            dist = (occupied_stalls[j-1] - occupied_stalls[i]) // 2\n            if dist > max_dist:\n                max_dist = dist\n    return max_dist\n\n\nn, stalls = read_input()\nprint(solve(n, stalls))\n```", "time_gen": "\ntime generating: 8.927724s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1036": {"code": "```\ndef minimum_sick_cows(filename):\n    with open(filename, 'r') as f:\n        n = int(f.readline())\n        sick_cows = []\n        for _ in range(n):\n            x, s = map(int, f.readline().split())\n            if s == 1:\n                sick_cows.append(x)\n        sick_cows.sort()\n        min_sick_cows = 0\n        prev_sick_cow = None\n        for cow in sick_cows:\n            if prev_sick_cow is None or abs(cow - prev_sick_cow) > 2:\n                min_sick_cows += 1\n            prev_sick_cow = cow\n        return min_sick_cows\n\nprint(minimum_sick_cows('socdist2.in'))\n```", "time_gen": "\ntime generating: 9.646747s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1037": {"code": "```\ndef tracing(data):\n    n, t = data[0].split()\n    n, t = int(n), int(t)\n    infected_cows = [int(x) for x in data[1]]\n    interactions = [[int(y) for y in x.split()] for x in data[2:t+1]]\n\n    patient_zero_candidate = None\n    k_lower_bound = 0\n    k_upper_bound = float('inf')\n\n    for i, infected in enumerate(infected_cows):\n        if not infected:\n            patient_zero_candidate = i + 1\n            break\n\n    for x, y in interactions:\n        if infected_cows[x-1] and infected_cows[y-1]:\n            k_lower_bound = max(k_lower_bound, len([z for z in interactions[:x] if (z[0], z[1]) == (y, z[2]) or (z[0], z[2]) == (y, x)]))\n        elif infected_cows[x-1]:\n            k_upper_bound = min(k_upper_bound, len([z for z in interactions[:x] if (z[0], z[1]) == (y, z[2]) or (z[0], z[2]) == (y, x)]))\n\n    return \"{} {} {}\".format(patient_zero_candidate, k_lower_bound, k_upper_bound)\n```", "time_gen": "\ntime generating: 19.001296s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1038": {"code": "```\n```python\nn, m = map(int, input().split())\npos = []\nfor _ in range(m):\n    a, b = map(int, input().split())\n    pos.append((a, 0))\n    pos.append((b, 1))\n\npos.sort()\n\nd = 0\nlast = pos[0][0]\nfor p, c in pos:\n    if c == 0:\n        d = max(d, p - last)\n    else:\n        d = max(d, (p + 1) - last - 1)\n    last = p\n\nprint(d)\n```", "time_gen": "\ntime generating: 8.152507s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1039": {"code": "```\nn, m = map(int, input().split())\ncounts = [0] * (m + 1)\nfor _ in range(n):\n    f, s = map(int, input().split())\n    counts[f] += 1\n    if f != s:\n        counts[s] += 1\n\nfor i in range(m + 1):\n    print(counts[i])\n```", "time_gen": "\ntime generating: 6.135449s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1040": {"code": "```\npython\nN = int(input())\nparticles = []\nfor _ in range(N):\n    x, y = map(int, input().split())\n    particles.append((x, y))\n\ndef can_interact(p1, p2):\n    return p1[0] <= p2[0] and p1[1] <= p2[1]\n\ndef get_remaining_particles(particles):\n    remaining_particles = [particles[0]]\n    for particle in particles[1:]:\n        interactable = False\n        for r_particle in remaining_particles:\n            if can_interact(r_particle, particle):\n                remaining_particles.remove(r_particle)\n                interactable = True\n                break\n        if not interactable:\n            remaining_particles.append(particle)\n    return len(remaining_particles)\n\nprint(get_remaining_particles(particles))\n```", "time_gen": "\ntime generating: 9.692991s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1041": {"code": "```\nimport sys\n\nn = int(input())\na = list(map(int, input().split()))\nfor j in range(n):\n    badness = sum(1 for i in range(j+1) if a[i] > j)\n    print(badness)\n```", "time_gen": "\ntime generating: 4.832474s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1042": {"code": "```\nn, m = map(int, open('fcolor.in', 'r').readline().split())\ncolors = [0] * (n + 1)\nfor _ in range(m):\n    a, b = map(int, open('fcolor.in', 'r').readline().split())\n    colors[a] += 1\n    if colors[b]:\n        colors[b] -= 1\n\nans = []\nfor i in range(1, n + 1):\n    while colors[i]:\n        ans.append(i)\n        for j in range(n + 1):\n            if colors[j] > 0:\n                k = i\n                while True:\n                    colors[k] -= 1\n                    if colors[k] == 0:\n                        break\n                    k += 1\n                i, k = k, i\n                break\n\nfor i in range(1, n + 1):\n    print(ans[i - 1])\n```", "time_gen": "\ntime generating: 10.7721s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1043": {"code": "```\ndef solve():\n    N, M = map(int, input().split())\n    ans = 0\n    for i in range(1, min(N, M)):\n        if (i & (i - 1)) == 0:\n            continue\n        if pow(i, N-2, M) != 1:\n            continue\n        ans += i\n    print(ans % M)\n\nif __name__ == \"__main__\":\n    solve()\n```", "time_gen": "\ntime generating: 6.684856s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1044": {"code": "```\npython\nfrom collections import defaultdict\n\ndef solve():\n    N = int(input())\n    grid = [list(input().strip()) for _ in range(N)]\n    \n    sweet, alfalfa = 0, 0\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'W':\n                continue\n            if i < N // 2:\n                sweet += 1\n            else:\n                alfalfa += 1\n                \n    ways = (1 << (N * N)) - (1 << sweet) - (1 << alfalfa)\n    \n    print(ways % (10**9 + 7))\n\nif __name__ == '__main__':\n    solve()\n```", "time_gen": "\ntime generating: 10.088843s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1045": {"code": "```\nimport math\n\nN, M = map(int, input().split())\nmod = pow(10**9 + 7, 2)\ninv_N = pow(N, mod - 2)\n\nans = 1\nfor i in range(N):\n    ans *= i * inv_N % mod\nprint(ans)\n```", "time_gen": "\ntime generating: 8.501976s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1046": {"code": "```\nimport math\n\ndef get_equivalence_class_size(n):\n    if n == 1:\n        return [1]\n    else:\n        tree = [[], []]  # Left subtree and right subtree\n        for i, edge in enumerate(edges):\n            if edge[0] < edge[1]:\n                tree[0].append(i)\n            else:\n                tree[1].append(i)\n        size = [1, 1]\n        for edge in edges:\n            left_size = size[0]\n            right_size = size[1]\n            if len(edge) % 2 == 1:  # The degree of the current node is odd\n                size[0] += math.ceil(left_size / 2) * 2 + min(left_size % 2, 1)\n                size[1] += math.floor(right_size / 2) * 2 + max(right_size % 2 - 1, 0)\n            else:  # The degree of the current node is even\n                size[0] += left_size // 2 * 2 + min(left_size % 2, 1)\n                size[1] += right_size // 2 * 2 + max(right_size % 2 - 1, 0)\n\n        return [size[0], size[1]]\n\ndef get_answer(n):\n    answer = []\n    for i in range(1, n+1):\n        tree = [[], []]\n        edges = [(i-1, i) for i in range(1, n)]\n        for edge in edges:\n            if edge[0] < edge[1]:\n                tree[0].append(edge)\n            else:\n                tree[1].append(edge)\n        size = get_equivalence_class_size(n)\n        answer.append((size[0] + size[1] - 2) % (10**9+7))\n    return answer\n\nn = int(input())\nanswer = get_answer(n)\n\nfor i, num in enumerate(answer):\n    print(str(num))\n```\nNote: This code is written in Python and uses the Markdown formatting to make it readable.", "time_gen": "\ntime generating: 22.647632s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1059": {"code": "```\nn1 = int(input())\nn2 = int(input())\nn3 = int(input())\nn4 = int(input())\nn5 = int(input())\nn6 = int(input())\nn7 = int(input())\n\na, b, c = None, None, None\nfor x in [n1, n2, n3, n4, n5, n6, n7]:\n    if x <= 10**9 // (x+1):\n        a = min(a, x)\n    elif x <= 10**9 // 2:\n        b = min(b, x)\n    else:\n        c = max(c, x)\n\nprint(min(a, b), b, c)\n```", "time_gen": "\ntime generating: 7.841366s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1060": {"code": "```\nn = int(input())\nps = list(map(int, input().split()))\ntotal_petals = sum(ps)\ntotal_flowers = n * (n + 1) // 2\ncount = 0\n\nfor i in range(n):\n    for j in range(i, n):\n        average_petals = (sum(ps[i:j+1]) * (j - i + 1)) / (j - i + 1)\n        if average_petals == round(average_petals):\n            count += 1\nprint(count)\n```", "time_gen": "\ntime generating: 6.718685s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1061": {"code": "```python\ndef count_eaten_grass():\n    N = int(input())\n    positions = []\n    \n    for _ in range(N):\n        direction, x, y = input().split()\n        x, y = int(x), int(y)\n        position = (x, y, 0) if direction == 'N' else (x, 0, y)\n        positions.append(position)\n        \n    eaten_grass = []\n    \n    for i in range(N):\n        x, y, dx, dy = positions[i]\n        eaten = set()\n        while True:\n            new_x, new_y = x + dx, y + dy\n            if (new_x, new_y) in eaten:\n                break\n            eaten.add((x, y))\n            x, y = new_x, new_y\n            \n        eaten_grass.append(len(eaten) - 1)\n        \n    for i in range(N):\n        print('Infinity' if eaten_grass[i] == float('inf') else str(eaten_grass[i]))", "time_gen": "\ntime generating: 12.098627s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1062": {"code": "```\nN = int(input())\ngraph = [[] for _ in range(N + 1)]\nfor i in range(1, N):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\ndef dfs(node, parent):\n    if node == 0:\n        return 0\n    if visited[node]:\n        return depth[node]\n    \n    visited[node] = True\n    depth[node] = min(dfs(neighbor, node) + 1 for neighbor in graph[node] if neighbor != parent)\n    return depth[node]\n\ndepth = [0] * (N + 1)\nvisited = [False] * (N + 1)\n\nmax_depth = 0\nfor i in range(1, N):\n    max_depth = max(max_depth, dfs(i, 0))\n\nprint(max_depth + 1)\n```", "time_gen": "\ntime generating: 10.626492s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1063": {"code": "```\ndef count_fence_sets(cows):\n    n = len(cows)\n    x_coords, y_coords = zip(*cows)\n\n    x_set = set(x_coords)\n    y_set = set(y_coords)\n\n    def count_fences(top_left, bottom_right):\n        top, left, bottom, right = top_left[0], top_left[1], bottom_right[0], bottom_right[1]\n        \n        count = 1\n        \n        for cow in cows:\n            x, y = cow\n            if x < left or x > right or y < top or y > bottom:\n                continue\n            \n            if (x, y) == top_left or (x, y) == bottom_right:\n                continue\n                \n            if x == left and y <= top:\n                count += 1\n            elif x == right and y >= bottom:\n                count += 1\n            elif y == top and x > left and x < right:\n                count += 1\n            elif y == bottom and x < left or x > right:\n                count += 1\n            \n        return count\n    \n    total_count = 0\n    \n    for top in sorted(x_set):\n        for left in range(min(x_set), max(x_set) + 1):\n            for bottom in sorted(y_set):\n                for right in range(min(y_set), max(y_set) + 1):\n                    if (left, bottom) <= (top_left := (top, left)) and (bottom_right := (bottom, right)) <= (right, top):\n                        total_count += count_fences(top_left, bottom_right)\n    \n    return total_count\n```", "time_gen": "\ntime generating: 16.552606s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1064": {"code": "```\ndef cow_blame(n):\n    cows = []\n    for _ in range(n):\n        d, x, y = input().split()\n        d = {'N': (0, 1), 'E': (1, 0)}[d]\n        cows.append((int(x), int(y), d))\n\n    blame = [0] * n\n    eaten_cells = set()\n\n    for i in range(n):\n        x, y, dir = cows[i]\n        while True:\n            if (x, y) in eaten_cells:\n                break\n            eaten_cells.add((x, y))\n            if dir == (0, 1):  # north\n                y += 1\n            else:  # east\n                x += 1\n\n    for i in range(n):\n        x, y, dir = cows[i]\n        while True:\n            if (x, y) in eaten_cells:\n                break\n            eaten_cells.add((x, y))\n            if dir == (0, 1):  # north\n                y += 1\n            else:  # east\n                x += 1\n\n    for i in range(n):\n        x, y, dir = cows[i]\n        while True:\n            if (x, y) in eaten_cells:\n                break\n            eaten_cells.add((x, y))\n            if dir == (0, 1):  # north\n                y += 1\n            else:  # east\n                x += 1\n\n    for i in range(n):\n        blame[i] = sum(1 for j in range(n) if cows[j][2] != cows[i][2] and cows[i][0:2] == cows[j][0:2])\n\n    print(*blame, sep='\\n')\n```", "time_gen": "\ntime generating: 20.426391s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1065": {"code": "```\nimport sys\n\ndef solve():\n    N, D = map(int, input().split())\n    grid = []\n    for _ in range(N):\n        row = list(input())\n        if len(grid) == 0:\n            grid.append(row)\n        else:\n            grid[0] = ['#'] * N\n            grid[-1] = ['#'] * N\n            grid[0][0], grid[-1][-1] = '#', '#'\n    for i in range(1, N - 1):\n        grid[i][0] = grid[i][-1] = '#'\n\n    empty_cells = sum(row.count('.') for row in grid)\n    possible_starting_positions = sum(1 for row in grid if 'S' in row)\n\n    return min(D, (N-2) * (N-2)) + (empty_cells - possible_starting_positions)\n\n\nif __name__ == \"__main__\":\n    print(solve())\n```", "time_gen": "\ntime generating: 14.129322s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1066": {"code": "```\nimport math\n\ndef solve(genome):\n    n = len(genome)\n    count_a, count_g, count_c, count_t = 0, 0, 0, 0\n    for char in genome:\n        if char == '?':\n            count_a += 1\n            count_g += 1\n            count_c += 1\n            count_t += 1\n        elif char == 'A':\n            count_a += 1\n        elif char == 'G':\n            count_g += 1\n        elif char == 'C':\n            count_c += 1\n        else:\n            count_t += 1\n    mod = 10**9 + 7\n    if n % 2:\n        return (count_a * count_g * count_c * count_t) % mod\n    else:\n        return (math.factorial(count_a) // math.factorial(count_g) * math.factorial(count_c) * math.factorial(count_t)) % mod\n```", "time_gen": "\ntime generating: 11.472081s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1067": {"code": "```\nimport bisect\nfrom collections import defaultdict\n\nn = int(input())\ncow_coords = [(int(x), int(y)) for x, y in [input().split() for _ in range(n)]]\nmax_x = max(x for x, y in cow_coords)\nmax_y = max(y for x, y in cowcoords)\n\ndp = [[defaultdict(int) for _ in range(max_y+1)] for _ in range(max_x+1)]\n\nfor x, y in cow_coords:\n    dp[x][y][0] += 1\n\ntotal_cows = sum(len(cowset) for cowset in (set((x, y) for x, y in cow_coords)))\n\nans = 1\nfor i in range(2**n):\n    mask = [0]*n\n    for j in range(n):\n        if (i>>j)&1:\n            mask[j] = 1\n    total_cows_in_fence = sum(dp[x][y][mask.count(1)] for x, y in cow_coords)\n    ans += binomial(max_x+1, max_y+1) - binomial(total_cows-total_cows_in_fence, max_y+1)\n\nprint(ans)\n```", "time_gen": "\ntime generating: 13.320032s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1068": {"code": "```\nn = int(input())\nsizes = list(map(int, input().split()))\ntypes = list(map(int, input().split()))\n\ndp = [[0] * (1 << n) for _ in range(n + 1)]\n\nfor mask in range(1 << n):\n    for i in range(n):\n        if ((mask >> i) & 1):\n            dp[i][mask] += 1\n\nans = 0\nfor i in range(n):\n    for j in range(i, -1, -1):\n        if sizes[j] > types[i]:\n            break\n        if not (dp[j] & (1 << i)):\n            ans += 1\n            for k in range(n):\n                dp[k] &= ~(1 << i)\n\nprint(ans % (10**9 + 7))\n```", "time_gen": "\ntime generating: 10.16035s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1069": {"code": "```\ndef dfs(i, j, k):\n    dp = [[0] * (k + 1) for _ in range(N + 1)]\n    for s in range(1, N + 1):\n        t = rooms[s - 1].index(1)\n        for b_s in range(1, min(s, k) + 1):\n            if b_s == 1:\n                dp[t][b_s] += 1\n            else:\n                for pre_b_s in range(b_s - 1, 0, -1):\n                    if dp[s - 1][pre_b_s]:\n                        break\n                else:\n                    dp[t][b_s] = (dp[t][b_s] or 1)\n    return [sum(dp[-1]) % (10**9 + 7) for _ in range(Q)]\n```", "time_gen": "\ntime generating: 14.947052s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1070": {"code": "```\ndef count_mixtures(N, K):\n    total = 0\n    for i in range(N):\n        l, r = map(int, input().split())\n        for j in range(i+1, N):\n            ll, rr = map(int, input().split())\n            if all((l <= k) and (k < r) or (ll <= k) and (k < rr) for k in range(l, rr+1)):\n                total += binomial(r-l+1, 3)\n    return str(total % (10**9 + 7))\n\ndef binomial(n, k):\n    if k > n // 2:\n        k = n - k\n    result = 1\n    for i in range(k):\n        result = result * (n - i) // (i + 1)\n    return result\n\nprint(count_mixtures(int(input()), int(input())))\n```", "time_gen": "\ntime generating: 12.238847s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1083": {"code": "```\ncowphabet = input()\nquery = input()\n\ncowphabet_index = {letter: index for index, letter in enumerate(cowphabet)}\nquery_index = [cowphabet.index(letter) for letter in query]\n\nstart = 0\nend = 0\nmin_count = float('inf')\n\nwhile end < len(query_index):\n    while start <= end and query_index[start] == query_index[0]:\n        if query_index[:start+1] == query_index[:end+1]:\n            min_count = min(min_count, (query_index.index(query_index[-1]) - query_index[0] + 26) // 26 + 1)\n            break\n        start += 1\n\n    end += 1\n\nprint(min_count)\n```", "time_gen": "\ntime generating: 8.923587s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1084": {"code": "```\ndef max_groups(breed_ids):\n    n = len(breed_ids)\n    groups = []\n    current_sum = 0\n    group_type = \"even\"\n\n    for breed_id in breed_ids:\n        if (group_type == \"even\" and current_sum + breed_id % 2 == 1) or \\\n           (group_type == \"odd\" and current_sum + breed_id % 2 == 0):\n            if group_type == \"even\":\n                group_type = \"odd\"\n            else:\n                group_type = \"even\"\n            groups.append(current_sum)\n            current_sum = breed_id\n        else:\n            current_sum += breed_id\n\n    if current_sum != 0:\n        groups.append(current_sum)\n\n    return len(groups)\n```", "time_gen": "\ntime generating: 8.454796s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1085": {"code": "```\nimport math\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ncount = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        if a[i] <= b[j]:\n            count += 1\nprint(count)\n```", "time_gen": "\ntime generating: 5.235193s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1086": {"code": "```\nN, K = map(int, input().split())\npos = set()\nfor i in range(K):\n    a, b = map(int, input().split())\n    for j in range(i+1):\n        if (a+j) % 2 == 0:\n            pos.add((i*K + a + j) % N + 1)\n        else:\n            pos.add((i*K + b - j) % N + 1)\n\nprint(*map(lambda x: str(len(set(map(lambda y:(y*K+x)%N+1,range(K)))))), range(N))\n```", "time_gen": "\ntime generating: 8.524912s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1087": {"code": "```\nN, Q = map(int, input().split())\ndesired_color = list(input())\n\nanswers = []\nfor _ in range(Q):\n    a, b = map(int, input().split())\n    dark_segments = [i for i in range(a-1, b) if desired_color[i] >= 'M']\n    light_segments = [i for i in range(b+1, N) if desired_color[i] < 'M']\n    answers.append(len(dark_segments) + len(light_segments))\n\nprint('\\n'.join(map(str, answers)))\n```", "time_gen": "\ntime generating: 7.963712s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1088": {"code": "```\npython\n```python\ndef max_beauty(n, a):\n    max_beauty = 0\n    for i in range(2**n):\n        beauty = 0\n        temp_a = [x[:] for x in a]\n        for j in range(n):\n            if (i >> j) & 1:\n                for k in range(j+1, n):\n                    if ((i >> k) & 1):\n                        temp_a[j][k] = -1000\n        for i2 in range(0, n-1, 2):\n            for j2 in range(0, n-1, 2):\n                if (temp_a[i2][j2] + temp_a[i2][j2+1] +\n                    temp_a[i2+1][j2] + temp_a[i2+1][j2+1]) == -2000:\n                    beauty -= 4\n        for i in range(n):\n            for j in range(n):\n                beauty += temp_a[i][j]\n        max_beauty = max(max_beauty, beauty)\n    return max_beauty\n\nn = int(input())\na = [list(map(int, input().split())) for _ in range(n)]\nprint(max_beauty(n, a))```", "time_gen": "\ntime generating: 14.348113s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1089": {"code": "```\ndef cowphabet(string):\n    missing = set('abcdefghijklmnopqrstuvwxyz')\n    for char in string:\n        if char in missing:\n            missing.remove(char)\n    return len(missing)\n\nstring = input()\nprint(cowphabet(string))\n```", "time_gen": "\ntime generating: 4.405436s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1090": {"code": "```\n# define a function to calculate the minimum time needed to transmit a message from cow 1 to cow N\ndef min_time(N, K, breeds, S):\n    # create a graph using adjacency list representation\n    graph = [[] for _ in range(K)]\n    \n    # add edges to the graph based on the transmission matrix S\n    for i in range(N):\n        graph[breeds[i] - 1].append(i)\n        \n    # perform DFS from each connected component and update the time\n    time = 0\n    visited = [False] * K\n    \n    for i in range(K):\n        if not visited[i]:\n            stack = [(i, 0)]  # (node, time)\n            while stack:\n                node, t = stack.pop()\n                if not visited[node]:\n                    visited[node] = True\n                    time = max(time, t + len(graph[node]))\n                    for neighbor in graph[node]:\n                        stack.append((breeds[neighbor] - 1, t + abs(node - breeds[neighbor] + 1)))\n    \n    # return the minimum time needed to transmit a message from cow 1 to cow N\n    return -1 if time == float('inf') else time\n\n# read input and calculate the minimum time needed to transmit a message\nN, K = map(int, input().split())\nbreeds = list(map(int, input().split()))\nS = [input() for _ in range(K)]\n\nprint(min_time(N, K, breeds, S))", "time_gen": "\ntime generating: 16.18739s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1091": {"code": "```\nfrom collections import defaultdict, deque\n\nn, k, m = map(int, input().split())\na = [0] * (2 * k)\nfor i in range(k):\n    a[i], a[k + i] = map(int, input().split())\n\nd = defaultdict(int)\nq = deque([1])\n\nfor _ in range(m):\n    for _ in range(k):\n        d[a.pop()] += 1\n        a.append(b)\n    for _ in range(k):\n        a[a.pop()], a[a.popleft()] = a[a.pop()], a[a.popleft()]\n    for i in range(n + 1):\n        print(d[i])\n```", "time_gen": "\ntime generating: 10.2404s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1092": {"code": "```\ndef solve():\n    K = int(input())\n    components = []\n    for _ in range(K):\n        N, M = map(int, input().split())\n        graph = list(map(int, input().split()))\n        component = set()\n        i = 0\n        while i < M:\n            u, v = graph[i], graph[i+1]\n            if (u > v) and ((u-1, v-1) not in component or (v-1, u-1) not in component):\n                component.add((u-1, v-1))\n                i += 2\n            else:\n                i += 2\n        components.append(component)\n    answer = 0\n    for component in components:\n        visited = set()\n        queue = [(1,)*(K,),]\n        while queue:\n            node = queue.pop(0)\n            if node not in visited:\n                visited.add(node)\n                for neighbor in component:\n                    if all(i < N or j == 0 for i, j in zip(*neighbor)):\n                        queue.append(tuple(x+1 for x in neighbor))\n        for node in component:\n            answer += len(list(nx.shortest_path(graphs[0], node))) - 1\n    print(answer % (10**9 + 7))\n\nimport networkx as nx\ngraphs = [nx.Graph() for _ in range(K)]\nsolve()\n```", "time_gen": "\ntime generating: 18.134828s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1093": {"code": "```\nN, M = map(int, input().split())\ncosts = list(map(int, input().split()))\nQ = int(input())\n\ndp = [[float('inf')] * (M + 1) for _ in range(N + 1)]\ndp[0][0] = 0\n\nfor i in range(1, N + 1):\n    for j in range(M + 1):\n        if j < M:\n            dp[i][j] = min(dp[i][j], dp[i - 1][j] + i ** 2)\n        if j > 0:\n            dp[i][j] = min(dp[i][j], dp[i][j - 1] + costs[j - 1])\n\nfor _ in range(Q):\n    x, y = map(int, input().split())\n    print(min(dp[x][y], dp[x - 1][y] + c[y - 1]))\n```", "time_gen": "\ntime generating: 13.677657s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1094": {"code": "```\ndef paint_strokes(N, M, Q):\n    colors = [list(input().strip()) for _ in range(N)]\n    candidates = []\n    for _ in range(Q):\n        x1, y1, x2, y2 = map(int, input().split())\n        subrectangle = [row[y1-1:y2] for row in colors[x1-1:x2]]\n        strokes = 0\n        for i in range(len(subrectangle)):\n            for j in range(len(subrectangle[0])):\n                if all(colors[i][j-col+1] == c for col in range(j)):\n                    strokes += 1\n                else:\n                    break\n        candidates.append(strokes)\n    return '\\n'.join(map(str, candidates))\n\nN, M, Q = map(int, input().split())\nprint(paint_strokes(N, M, Q))\n```", "time_gen": "\ntime generating: 15.153511s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1107": {"code": "```\npython\nN = int(input())\ncow_years = {}\nfor _ in range(N):\n    rel, year_diff, cow1, _, zodiac_animal, cow2 = input().split()\n    if \"previous\" in rel:\n        cow_years[cow1] = cow_years.get(cow1, 0) - ([\"Rabbit\", \"Rooster\", \"Dog\"].index(zodiac_animal) % 12)\n    else:\n        cow_years[cow1] = cow_years.get(cow1, 0) + ([\"Rabbit\", \"Rooster\", \"Dog\"].index(zodiac_animal) % 12)\n\ncow_years['Bessie'] = 0\nElsie_year_diff = abs(cow_years.get('Elsie', 0) - cow_years.get('Bessie', 0))\nprint(Elsie_year_diff)\n```", "time_gen": "\ntime generating: 17.196602s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1108": {"code": "```\nn = int(input())\ngraph = {}\nfor _ in range(n):\n    x, y = map(int, input().split())\n    if (x, y) not in graph:\n        graph[(x, y)] = set()\n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx <= 1000 and 0 <= ny <= 1000:\n                graph[(x, y)].add((nx, ny))\n    print(len([cell for cell in graph if len(graph[cell]) == 3]))\n```", "time_gen": "\ntime generating: 24.728574s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1109": {"code": "```\ndef direction(s):\n    x, y = 0, 0\n    for d in s:\n        if d == \"N\":\n            y += 1\n        elif d == \"S\":\n            y -= 1\n        elif d == \"E\":\n            x += 1\n        elif d == \"W\":\n            x -= 1\n    return \"CW\" if x > 0 else (\"CCW\" if x < 0 else (\"CW\" if y > 0 else \"CCW\"))\n\nN = int(input())\nfor _ in range(N):\n    s = input()\n    print(direction(s))\n```", "time_gen": "\ntime generating: 22.103403s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1110": {"code": "```\ndef solve(n):\n    res = [0] * (n + 1)\n    visited = set()\n    for i in range(1, n + 1):\n        x, y = int(input().split()[0]), int(input().split()[1])\n        if (x, y) not in visited:\n            res[i] += res[i - 1]\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < 1001 and 0 <= ny < 1001 and (nx, ny) not in visited:\n                    res[i] += 1\n        else:\n            res[i] = res[i - 1]\n    return res\n\nn = int(input())\nprint(*solve(n), sep='\\n')\n```", "time_gen": "\ntime generating: 34.475555s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1111": {"code": "```\ndef min_time_travel(n, k):\n    ancestors = [int(input()) for _ in range(n)]\n    ancestors.sort()\n    ancestors.insert(0, 0)\n    dp = [[float('inf')] * (k + 1) for _ in range(len(ancestors) + 1)]\n\n    dp[0][0] = 0\n    for i in range(1, len(ancestors) + 1):\n        for j in range(min(i, k) + 1):\n            if ancestors[i - 1] <= j:\n                dp[i][j] = min(dp[i][j], max(dp[i - 1][0:j - ancestors[i - 1]], ancestors[i - 1]))\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[-1][-1]\n\n\nn, k = map(int, input().split())\nprint(min_time_travel(n, k))\n```", "time_gen": "\ntime generating: 45.011144s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1112": {"code": "```\ndef count_photos():\n    N = int(input())\n    min_val = float('inf')\n    max_val = 0\n    \n    for _ in range(N):\n        row = list(map(int, input().split()))\n        if min(row) < min_val:\n            min_val = min(row)\n        if max(row) > max_val:\n            max_val = max(row)\n\n    photos = []\n    for i in range(1 << N):\n        sub_grid_min = float('inf')\n        sub_grid_max = 0\n        for j in range(N):\n            k = i & ((1 << N) - 1)\n            if (k >> j) & 1:\n                for col in range(N):\n                    cell_val = row[j][col]\n                    if cell_val < sub_grid_min:\n                        sub_grid_min = cell_val\n                    if cell_val > sub_grid_max:\n                        sub_grid_max = cell_val\n        if sub_grid_min == min_val and sub_grid_max >= max_val:\n            photos.append(i)\n    return len(photos)", "time_gen": "\ntime generating: 38.761477s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1113": {"code": "```\nn = int(input())\na = list(map(int, input().split()))\nans = 0\nfor i in range(1, n+1):\n    if a[i-1] >= i:\n        ans += 1\nprint(ans)\n```", "time_gen": "\ntime generating: 20.232366s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1114": {"code": "```\nimport sys\n\nN = int(sys.stdin.readline().strip())\npainting = list(map(int, sys.stdin.readline().strip().split()))\npainting.sort()\nbrush_strokes = 0\ncolor_index = 0\n\nfor i in range(N):\n    while color_index < N and painting[color_index] <= i:\n        brush_strokes += 1\n        color_index += 1\n\nprint(brush_strokes)\n```", "time_gen": "\ntime generating: 30.028565s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1115": {"code": "```\ndef count_cows(x, y, d):\n    res = 0\n    for i in range(d+1):\n        if (x+i)//3**(y+i)//3 % 3 == ((x+i) // 3**(y+i) // 3) % 3:\n            res += 1\n    return res\n\nQ = int(input())\nfor _ in range(Q):\n    d, x, y = map(int, input().split())\n    print(count_cows(x, y, d))\n```", "time_gen": "\ntime generating: 29.693727s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1116": {"code": "```\nN, Q = map(int, input().split())\ncolor = list(map(int, input().split()))\nprint(*[min(2 * (b - a + 1) // i + (i > 1), N - b - 1) for a, b in [map(int, input().split()) for _ in range(Q)]], sep='\\n')\n```", "time_gen": "\ntime generating: 24.986184s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1117": {"code": "```\nimport sys\n\ndef read_input():\n    T = int(sys.stdin.readline())\n    for _ in range(T):\n        N, M = map(int, sys.stdin.readline().split())\n        edges = []\n        for _ in range(M):\n            x, y = map(int, sys.stdin.readline().split())\n            edges.append((min(x, y), max(x, y)))\n        yield N, M, edges\n\ndef solve(N, M, edges):\n    graph = {}\n    for u, v in edges:\n        if u not in graph:\n            graph[u] = set()\n        if v not in graph:\n            graph[v] = set()\n        graph[u].add(v)\n        graph[v].add(u)\n\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    for k in range(2, N):\n        for i in range(1, N - k + 1):\n            j = i + k\n            if i not in graph or j not in graph:\n                continue\n            for u in graph[i]:\n                if u == j:\n                    break\n                for v in graph[u]:\n                    if v == j:\n                        break\n                    dp[i][j] = max(dp[i][j], dp[i][u] + 1)\n\n    return sum(1 for row in dp[1:] for val in row if val > 0)\n\nfor N, M, edges in read_input():\n    print(solve(N, M, edges))\n```", "time_gen": "\ntime generating: 64.20947s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1118": {"code": "```\ndef count_ways(n, m):\n    mod = 10**9 + 7\n    ways = [[0] * (n+1) for _ in range(n+1)]\n    \n    for i in range(1, n+1):\n        ways[i][0] = 1\n    \n    for e in edges:\n        x, y = e\n        for j in range(n+1):\n            ways[x][j] += ways[y][j]\n            ways[y][j] += ways[x][j]\n    \n    ans = sum(ways[n][i] for i in range(n))\n    return ans % mod\n\nT = int(input())\nfor _ in range(T):\n    N, M = map(int, input().split())\n    edges = [list(map(int, input().split())) for _ in range(M)]\n    print(count_ways(N, M))```", "time_gen": "\ntime generating: 6.696783s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1131": {"code": "```\nimport sys\n\ninput = sys.stdin.read().split('\\n')\nN, L = map(int, input[0].split())\ncitations = list(map(int, input[1].split()))\ncitations.sort(reverse=True)\nh_index = 0\nfor i in range(N):\n    if citations[i] >= h_index + 1:\n        h_index += 1\n    else:\n        break\n\nprint(h_index)\n```", "time_gen": "\ntime generating: 4.2128s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1132": {"code": "```\nN, K = map(int, input().split())\nlab_members = list(input().split())\n\npublications = [list(map(str, input().split())) for _ in range(K)]\n\nseniorities = [['?' for _ in range(N)] for _ in range(N)]\nfor i in range(len(publications)):\n    for j in range(len(publications[i])):\n        p1 = lab_members.index(publications[i][j])\n        for k in range(j+1, len(publications[i])):\n            p2 = lab_members.index(publications[i][k])\n            if publications[i][p1] < publications[i][p2]:\n                seniorities[p1][p2] = '0'\n                seniorities[p2][p1] = '1'\n            elif publications[i][p1] > publications[i][p2]:\n                seniorities[p1][p2] = '1'\n                seniorities[p2][p1] = '0'\n\nfor i in range(N):\n    if i == 0:\n        print('B' + ''.join(seniorities[0]))\n    else:\n        print(''.join(seniorities[i]))\n```", "time_gen": "\ntime generating: 7.974561s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1133": {"code": "```\ndef find_friends(N, M):\n    pasture = [list(line) for line in (input().split() for _ in range(N))]\n    friends = 0\n    directions = [(0,1), (0,-1), (1,0), (-1,0)]\n    \n    for i in range(N):\n        for j in range(M):\n            if pasture[i][j] == 'C':\n                for direction in directions:\n                    ni, nj = i + direction[0], j + direction[1]\n                    if 0 <= ni < N and 0 <= nj < M and pasture[ni][nj] == 'G' and any((pasture[x][y] == 'C' and (abs(x-i) + abs(y-j)) > 1 for x in range(N) for y in range(M))):\n                        friends += 1\n                        pasture[ni][nj] = '.'\n    \n    return friends\n\nN, M = map(int, input().split())\nprint(find_friends(N, M))\n```", "time_gen": "\ntime generating: 6.77261s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1134": {"code": "```\nN = int(input())\n\nmaze = []\nfor _ in range(N):\n    maze.append(list(input()))\n\nmoves = {'M11': 'O', 'M13': 'O', 'O22': 'M', 'M22': 'O', 'M31': 'O', 'M11': 'O', 'M33': 'O', 'O31': 'M'}\n\ndef get_move(move):\n    return moves.get(move, '.')\n\nwin_configs = set()\n\ndef dfs(x, y, config):\n    global win_configs\n    if x < 0 or x >= N or y < 0 or y >= N:\n        return\n    if maze[x][y] == 'BBB':\n        return\n    if get_move(''.join([str(i) for i in maze[x][y]])):\n        config += get_move(''.join([str(i) for i in maze[x][y]])) + '\\n'\n        win_configs.add(config)\n        return\n    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < N and 0 <= ny < N:\n            maze[x][y], maze[nx][ny] = maze[nx][ny], maze[x][y]\n            dfs(nx, ny, config)\n            maze[x][y], maze[nx][ny] = maze[nx][ny], maze[x][y]\n\ndfs(1, 1, '')\nprint(len(win_configs))\n```", "time_gen": "\ntime generating: 11.278806s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1135": {"code": "```\ndef count_triples(nums):\n    nums.sort()\n    ans = 0\n    for i in range(len(nums) - 2):\n        j, k = i + 1, len(nums) - 1\n        while j < k:\n            x = nums[j] + nums[k]\n            if x == nums[i]:\n                ans += 1\n                j += 1\n                k -= 1\n            elif x > nums[i]:\n                k -= 1\n            else:\n                j += 1\n    return ans\n\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    nums = list(map(int, input().split()))\n    print(count_triples(nums))\n```", "time_gen": "\ntime generating: 5.947114s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1136": {"code": "```\nimport heapq\n\nN, K, L = map(int, input().split())\ncitations = list(map(int, input().split()))\n\nheap = []\nfor i, cite in enumerate(citations):\n    heapq.heappush(heap, -cite)\n\nh_index = 0\nwhile len(heap) >= h_index + 1:\n    if heap[0] < -(h_index + 1):\n        break\n    for _ in range(h_index + 1):\n        heapq.heappop(heap)\n    h_index += 1\n\nprint(h_index)\n```", "time_gen": "\ntime generating: 4.743747s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1137": {"code": "```\ndef solve():\n    n = int(input())\n    breeds = list(map(int, input().split()))\n    \n    leaders = set()\n    for i in range(n):\n        if not any(breeds[i] == breed for breed in leaders):\n            leaders.add(breeds[i])\n    \n    res = 0\n    for l1 in leaders:\n        for l2 in leaders - {l1}:\n            for r in range(n + 1):\n                if all(l1 != breeds[i] and l2 != breeds[i] for i in range(max(1, l1 - 1), min(r, n))):\n                    res += 1\n    print(res)\n\nsolve()\n```", "time_gen": "\ntime generating: 4.710401s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1138": {"code": "```\n```\n\n```python\nn = int(input())\ntotal_moonies = 0\n\nfor i in range(n):\n    c, p1, p2, p3, p4 = map(int, input().split())\n    if (p1, p2) != sorted((p1, p2)) or (p3, p4) != sorted((p3, p4)):\n        total_moonies += c\n```\n\n```", "time_gen": "\ntime generating: 5.252225s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1139": {"code": "```\ndef count_permutations():\n    n = int(input())\n    points = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        points.append((x, y))\n\n    permutations = 1\n    for i in range(3):\n        for j in range(i+1, n):\n            if (points[i][0] - points[j][0])**2 + (points[i][1] - points[j][1])**2 > 40000:\n                permutations *= 2\n\n    return permutations % (10**9 + 7)\n```", "time_gen": "\ntime generating: 4.76607s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1140": {"code": "```\ndef calculate_delegations(N, breeds):\n    count = 0\n    for i in range(len(breeds)):\n        for j in range(i+1, len(breeds)):\n            if (breeds[i] != breeds[j]):\n                for k in range(j+1, len(breeds)):\n                    if (breeds[k] != breeds[i]) and (breeds[k] != breeds[j]):\n                        count += 1\n    print(count)\n```\nNote: Please run this code with the sample input to see the expected output.", "time_gen": "\ntime generating: 4.214589s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1141": {"code": "Here is the Python code for the problem:\n```\ndef solve():\n    T = int(input())\n    for _ in range(T):\n        N, K = map(int, input().split())\n        S = ''.join([c if c in 'SR' else '.' for c in input()])\n        E = [list(map(int, input())) for _ in range(N)]\n        \n        senders = [i+1 for i in range(N) if S[i] == 'S']\n        receivers = [i+1 for i in range(N) if S[i] == 'R']\n        \n        G = [[0]*N for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                if E[i][j]:\n                    G[i][j] = 1\n        \n        ans = 1\n        for sender in senders:\n            for receiver in receivers:\n                if G[sender-1][receiver-1]:\n                    G[sender-1][receiver-1] = 0\n                    break\n            else:\n                ans *= (ans + 1)\n        \n        print(ans)\n\nsolve()\n```", "time_gen": "\ntime generating: 11.294298s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1142": {"code": "```\ndef solve():\n    N = int(input())\n    dp = [[0, 0] for _ in range(N)]\n    total = [0]\n    for i in range(N):\n        line = input()\n        for j in range(N):\n            if line[j] == 'G':\n                if i > 0 and (dp[i-1][j] & 1) or j > 0:\n                    dp[i][j] = [(x + y) % (10**9 + 7) for x, y in zip(dp[i-1][j], [2]*(N-1))]\n                else:\n                    dp[i][j] = [(x + 1) % (10**9 + 7) for x in dp[i-1][j]]\n            total[0] += dp[i][j][0]\n    print(total[0])\n\nsolve()\n```", "time_gen": "\ntime generating: 6.118182s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1155": {"code": "```\ncount = 0\nfor i in range(N - 2):\n    if (str(i) + str(i+1) + str(i+2)) in ['GGG', 'HHH']:\n        count += 1\nprint(count)\n```", "time_gen": "\ntime generating: 2.810365s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1156": {"code": "```\nn = int(input())\np = list(map(int, input().split()))\nt = list(map(int, input().split()))\n\ntotal_commands = 0\ni = 0\n\nwhile i < n:\n    if t[i] > p[i]:\n        total_commands += (t[i] - p[i])\n        for j in range(i + 1):\n            t[j] = min(t[j], p[j])\n    elif t[i] < p[i]:\n        total_commands += (p[i] - t[i])\n        for j in range(i, n):\n            t[j] = max(t[j], p[j])\n\n    i += 1\n\nprint(total_commands)\n```", "time_gen": "\ntime generating: 5.087002s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1157": {"code": "```\ndef calculate_paths(n, k):\n    # Initialize a grid with all empty cells initially.\n    grid = [['.' for _ in range(n)] for _ in range(n)]\n\n    # Read haybales from input and mark them on the grid.\n    for i in range(n):\n        line = input()\n        for j in range(n):\n            if line[j] == 'H':\n                grid[i][j] = 'H'\n\n    # Initialize counters for down and right movements.\n    down, right = n-1, n-1\n\n    # Calculate the number of paths.\n    paths = 0\n    for _ in range(k+1):\n        if _ < k:\n            # If not at the last turn, update the counters.\n            if grid[down][right] == 'H':\n                right -= 1\n            else:\n                down -= 1\n\n            # Update the path count.\n            paths *= (n - down)\n            paths /= (down + 1)\n\n        # If at the last turn, just decrement once for each movement.\n        elif grid[down][right] == 'H':\n            right -= 1\n        else:\n            down -= 1\n\n    return paths\n\n\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    print(calculate_paths(n, k))\n```", "time_gen": "\ntime generating: 9.364801s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1158": {"code": "```\nimport sys\nfrom bisect import bisect_left,bisect_right\nK,M,N = map(int, input().split())\npatches = []\nfor _ in range(K):\n    p,t = map(int, input().split())\n    patches.append((p,t))\n\ncows = []\nfor _ in range(M):\n    f = int(input())\n    cows.append(f)\n\nmax_tastiness = 0\nfor i in range(N):\n    low, high = min(patches[i][0], min(cow for cow in cows)), max(patches[i][1], max(cow for cow in cows))\n    if (low <= patches[i][0] < patches[i][0]) or (high > patches[i][0]):\n        idx = bisect_left([p for p,_ in patches],[patches[i][0]])\n        max_tastiness += patches[idx-1][1]\n    else:\n        cow_idx = bisect_right(cows,patches[i][0])\n        if cow_idx == 0:\n            max_tastiness += patches[0][1]\n        elif cow_idx == len(cows):\n            max_tastiness += patches[-1][1]\n        else:\n            if cows[cow_idx-1] <= patches[i][0]:\n                max_tastiness += patches[idx-1][1]\n            else:\n                max_tastiness += patches[idx-1][1]\n\nprint(max_tastiness)\n```", "time_gen": "\ntime generating: 8.811926s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1159": {"code": "```\nimport sys\nfrom collections import deque\n\ndef solve_case(n, m):\n    graph = [[] for _ in range(n+1)]\n    for i in range(m):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    dist = [float('inf')] * (n+1)\n    dist[1] = 0\n    queue = deque([1])\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if dist[neighbor] > dist[node] + 1:\n                dist[neighbor] = dist[node] + 1\n                queue.append(neighbor)\n\n    if dist[n] == float('inf'):\n        return -1\n\n    total_cost = sum((i-1)**2 for i in range(2, n+1) if dist[i])\n    return min(total_cost, (n-1)**2)\n\n\ndef main():\n    T = int(sys.stdin.readline().strip())\n    for _ in range(T):\n        n, m = map(int, sys.stdin.readline().split())\n        print(solve_case(n, m))\n\n\nif __name__ == \"__main__\":\n    main()\n```", "time_gen": "\ntime generating: 7.759412s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1160": {"code": "```\nN, M = map(int, input().split())\nintervals = []\nfor _ in range(N):\n    a, b = map(int, input().split())\n    intervals.append((a, b))\n\nanswer = [0] * (2*M + 1)\n\nfor i in range(N):\n    for j in range(i+1, N):\n        a_i, b_i = intervals[i]\n        a_j, b_j = intervals[j]\n        \n        for k in range(2*M+1):\n            if (a_i <= k and k <= b_i) or (a_j <= k and k <= b_j):\n                if min(a_i, a_j) + max(b_i, b_j) <= k:\n                    answer[k] += 1\n\nfor i in range(len(answer)):\n    print(answer[i])\n```", "time_gen": "\ntime generating: 5.757726s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1161": {"code": "```\nmin_sum = float('inf')\nmax_sum = 0\nfor i in range(N):\n    if not (i-1 >= 0 and x[i] - x[i-1] <= K) or not (i+1 < N and x[i+1] - x[i] <= K):\n        max_sum += y[i]\nif T == 2:\n    print(max_sum)\nelse:\n    print(min_sum)\n```", "time_gen": "\ntime generating: 4.63034s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1162": {"code": "```\nN = int(input())\npermutation = list(map(int, input().split()))\ncount = 0\nfor x in range(N+1):\n    hi_count = 0\n    lo_count = 0\n    for i in permutation:\n        if i > x + 0.5:\n            hi_count += 1\n            break\n        elif i < x + 0.5:\n            lo_count += 1\n            break\n    count += (hi_count - lo_count) // 4\nprint(*[str(count).ljust(6)], sep='\\n')\n```", "time_gen": "\ntime generating: 5.174942s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1163": {"code": "```\nimport sys\n\ndef is_possible(N, M, k_list):\n    colors = [0] * (N + 1)\n    for i in range(M):\n        for j in range(k_list[i]):\n            c = k_list[i][j]\n            if colors[c] % 2 == 1:\n                return False\n            colors[c] += 1\n\n    return True\n\n\nT = int(sys.stdin.readline().strip())\nfor _ in range(T):\n    N, M = map(int, sys.stdin.readline().strip().split())\n    k_list = []\n    for i in range(M):\n        line = list(map(int, sys.stdin.readline().strip().split()))\n        k = line[0]\n        c_list = line[1:]\n        k_list.append((k, c_list))\n\n    if is_possible(N, M, [x[1] for x in k_list]):\n        print('YES')\n    else:\n        print('NO')\n\n```", "time_gen": "\ntime generating: 7.682283s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1164": {"code": "```\n```\n```\n```\n```", "time_gen": "\ntime generating: 2.058433s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1165": {"code": "```\nimport sys\ninput = sys.stdin.readline\n\ndef read():\n    return [int(x) for x in input().split()]\n\nT, N, K = read()\nunpaired_holsteins = []\nunpaired_guernseys = []\n\nfor _ in range(N):\n    breed, x, y = read()\n    if breed == 'H':\n        unpaired_holsteins.append(y)\n    else:\n        unpaired_guernseys.append(y)\n\nunpaired_holsteins.sort()\nunpaired_guernseys.sort()\n\ni = j = 0\nmin_sum = max_sum = sum(unpaired_holsteins) + sum(unpaired_guernseys)\n\nwhile i < len(unpaired_holsteins) and j < len(unpaired_guernseys):\n    if unpaired_guernseys[j] - unpaired_holsteins[i] <= K:\n        min_sum = min(min_sum, unpaired_guernseys[j] + unpaired_holsteins[i])\n        i += 1\n        j += 1\n    elif unpaired_guernseys[j] > K + unpaired_holsteins[i]:\n        max_sum = max(max_sum, sum(unpaired_guernseys) - unpaired_guernseys[j] + unpaired_holsteins[i])\n        i += 1\n    else:\n        j += 1\n\nif T == 2:\n    print(max_sum)\nelse:\n    print(min_sum)\n```", "time_gen": "\ntime generating: 10.156914s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1166": {"code": "```\ndef solve(n, x):\n    s = \"LO\" * (x - 1) + \"HI\"\n    for i in range(2, n+1):\n        s += \"LO\" if i <= x else \"HI\"\n    return sum(1 for c in s if c == 'L' and s.count('HIL') % 4 == 0) % (10**9 + 7)\n\nn, x = map(int, input().split())\nprint(solve(n, x))\n```", "time_gen": "\ntime generating: 4.82256s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1179": {"code": "```\nfrom typing import List\n\ndef herdle(answer: List[str], guess: List[str]) -> str:\n    green_count = 0\n    yellow_count = 0\n    \n    for i in range(len(answer)):\n        if answer[i] == guess[i]:\n            green_count += 1\n        elif guess[i].upper() == answer[i]:\n            yellow_count += 1\n    \n    print(green_count)\n    print(yellow_count)\n\n# example usage\nanswer = [\"COW\", \"SAY\", \"MOO\"]\nguess = [\"WIN\", \"THE\", \"IOI\"]\nherdle(answer, guess)\n```", "time_gen": "\ntime generating: 4.919434s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1180": {"code": "```\ndef check_non_transitivity():\n    T = int(input())\n    for _ in range(T):\n        A = list(map(int, input().split()))\n        B = list(map(int, input().split()))\n        found = False\n        for i in range(1, 11):\n            if i not in A and i not in B:\n                C = [i] * 4\n                if (max(A) > max(B)) != (max(C) > max(A)):\n                    print('yes')\n                    found = True\n                    break\n        if not found:\n            print('no')\n\ncheck_non_transitivity()\n```", "time_gen": "\ntime generating: 4.964978s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1181": {"code": "```\n```\n\n```\ntotal = 0\nfor _ in range(int(input())):\n    n = int(input())\n    h = list(map(int, input().split()))\n    total += 1\n    for i in range(n):\n        h[i] -= 1\n    if max(h) != min(h):\n        print(-1)\n    else:\n        count = sum(1 for x in h if x > 0)\n        print(count * 2)\n```", "time_gen": "\ntime generating: 4.624944s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1182": {"code": "```\ndef find_min_operations(p1, p2):\n    diff = p2 - p1\n    operations = 0\n    while diff > 0:\n        if diff % 2 == 1:\n            operations += 1\n            diff -= 1\n        diff //= 2\n    return operations\n\nn = int(input())\nfor _ in range(n):\n    p1, p2 = map(int, input().split())\n    print(find_min_operations(p1, p2))\n```", "time_gen": "\ntime generating: 3.817846s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1183": {"code": "```\n```\n```\n```\n```\n```\nlong long total_distance = 0;\n\nfor (int i = 1; i < N; i++) {\n    for (int j = i + 1; j <= N; j++) {\n        if ((h[i] > h[j - 1]) && (j - i) % (j - i + 1) == 0) {\n            total_distance += j - i;\n        }\n    }\n}\n\ncout << total_distance << endl;\n```\n```\n```\n```\n```\n```\n```\n```\n```\n```", "time_gen": "\ntime generating: 4.332509s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1184": {"code": "```\nM = int(input().split()[1])\nN = int(input().split()[0])\ncows = list(map(int, input().split()) for _ in range(N))\n\ndef hungry_cow_count(cows):\n    c2 = {}\n    for i, (f, s) in enumerate(cows):\n        if f not in c2:\n            c2[f] = 1\n        else:\n            c2[f] += 1\n\n    return sum(1 for f in c2 if c2[f] > M)\n\ndef hungry_cow_permutation(cows):\n    cows.sort()\n    permutation = [i+1 for i, (f, s) in enumerate(cows)]\n    \n    for i, (f, s) in enumerate(cows):\n        while permutation[i] == f:\n            if len(permutation) > i+1:\n                permutation[i], permutation[-1] = permutation[-1], permutation[i]\n                break\n            else:\n                permutation.pop()\n                break\n\n    return permutation\n\nmin_hungry_cow_count = hungry_cow_count(cows)\nprint(min_hungry_cow_count)\n\nif min_hungry_cow_count > 0:\n    print(*hungry_cow_permutation(cows), sep='\\n')\n```", "time_gen": "\ntime generating: 8.573647s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1185": {"code": "```\ndef count_hunger_levels(n, h):\n    mod = 10**9 + 7\n    dp = [0] * (n+1)\n    for i in range(1, n+1):\n        if i <= 2:\n            dp[i] = 1\n        else:\n            dp[i] = dp[i-1]\n            for j in range(1, h[i]):\n                dp[i] = (dp[i] + dp[i-2]) % mod\n\n    return dp[n]\n\nn = int(input())\nh = list(map(int, input().split()))\nprint(count_hunger_levels(n, h))\n```", "time_gen": "\ntime generating: 5.119174s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1186": {"code": "```\nN, Q = map(int, input().split())\nrelevant_farms = [True] * N\nlast_update_time = {}\n\nfor _ in range(Q):\n    query = list(map(int, input().split()))\n    if query[0] == 'D':\n        relevant_farms[query[1]-1] = False\n    elif query[0] == 'A':\n        relevant_farms[query[1]-1] = True\n        relevant_farms[query[2]-1] = True\n        last_update_time[query[1]] = query[2]\n        last_update_time[query[2]] = query[1]\n    else:\n        road_to_remove = min(last_update_time.popitem()[0], key=lambda x: (x, last_update_time[x]))\n        relevant_farms[road_to_remove-1] = False\n\nfor i in range(N):\n    print(max(0, max((last_update_time.get(x, 0) for x in range(i+1)), default=Q-1)))\n```", "time_gen": "\ntime generating: 6.838379s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1187": {"code": "```\nn = int(input())\nj_n = list(map(int, input().split()))\nk = 1\nx_n = []\nfor i in range(n):\n    x_i = j_i + k\n    x_n.append(x_i)\n    while len(x_n) < i+1:\n        k += 1\n        x_n.append(min(j_n[:i+1]) + k)\n\nprint(k)\nfor i in range(n):\n    print(x_n[i])\n```", "time_gen": "\ntime generating: 4.808628s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1188": {"code": "```\nimport heapq\n\nN, K = map(int, input().split())\nheights = list(map(int, input().split()))\nheap = [(h, i) for i, h in enumerate(heights)]\nheapq.heapify(heap)\nans = []\n\nfor _ in range(N):\n    h, i = heapq.heappop(heap)\n    ans.append(h)\n    if heap:\n        prev_h, prev_i = heap[0]\n        if i > 1 and abs(h - heights[i-2]) <= K:\n            heights[i-1] += (h - heights[i-2])\n        elif i < N and abs(h - heights[i+1]) <= K:\n            heights[i] += (h - heights[i+1])\n    heapq.heapreplace(heap, (max(min(h+K, height), min(h-K, 10^9)), i))\n\nprint(*ans, sep='\\n')\n```", "time_gen": "\ntime generating: 5.706037s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1189": {"code": "```\ndef count_configs(h):\n    n = len(h)\n    dp = [0]*(n+1)\n    dp[1] = 1\n    for i in range(2, n+1):\n        if h[i-1]-h[i-2] == 1:\n            dp[i] = dp[i-1]\n        elif h[i-1]-h[i-2] == -1:\n            dp[i] = dp[i-1] + dp[i-2]\n    return (dp[n]+7)%10**9\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    h = list(map(int, input().split()))\n    print(count_configs(h))\n```", "time_gen": "\ntime generating: 5.433318s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1190": {"code": "```\nimport sys\nfrom collections import namedtuple\n\nCoord = namedtuple('Coord', 'x y')\n\ndef max_squared_distance(groups):\n    total_coords = [0, 0]\n    for group in groups:\n        min_x = min(y.x for y in group)\n        min_y = min(y.y for y in group)\n        max_x = max(y.x for y in group)\n        max_y = max(y.y for y in group)\n\n        x_range = (max_x - min_x) // 2\n        y_range = (max_y - min_y) // 2\n\n        total_coords[0] += x_range\n        total_coords[1] += y_range\n\n    return sum(c ** 2 for c in total_coords)\n\nif __name__ == '__main__':\n    N = int(input())\n    groups = []\n    for _ in range(N):\n        G = int(input())\n        group = [Coord(*map(int, input().split())) for _ in range(G)]\n        groups.append(group)\n    print(max_squared_distance(groups))\n```", "time_gen": "\ntime generating: 6.433313s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1203": {"code": "```\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    a = list(map(int, input().split()))\n    total = sum(a)\n    avg = total // N\n    diff = abs(total - (avg * N))\n    res = 0\n    i = 1\n    while i <= N:\n        if i > 1 and a[i-1] == a[i-2]:\n            res += min(diff, a[i-1])\n        else:\n            res += diff\n        i += 1\n    print(res)\n```", "time_gen": "\ntime generating: 4.915571s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1204": {"code": "```python\nfrom collections import Counter\n\ndef min_modifications(a, b):\n    a_count = Counter(a)\n    b_count = Counter(b)\n\n    return sum((a_count[i] - b_count.get(i, 0)) ** 2 for i in set(a))\n\nN = int(input())\na = list(map(int, input().split()))\nb = list(map(int, print().split()))\n\nprint(min_modifications(a, b))\n```", "time_gen": "\ntime generating: 3.501804s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1205": {"code": "```\nwords = []\nblocks = []\n\nfor _ in range(4):\n    line = input().split()\n    blocks.append(line)\n\nn = int(input())\nfor word in range(n):\n    w = input().upper()\n    flag = True\n    for letter in w:\n        found = False\n        for block in blocks:\n            if letter in block:\n                found = True\n                break\n        if not found:\n            flag = False\n            break\n    print(\"YES\" if flag else \"NO\")\n```", "time_gen": "\ntime generating: 3.584466s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1206": {"code": "```\nN = int(input())\npreferences = [list(map(int, input().split())) for _ in range(N)]\n\noutput = []\nfor i in range(N):\n    most_preferred_gift = -1\n    for j in range(N):\n        if preferences[i].index(j) < preferences[i].index(i) and j > most_preferred_gift:\n            most_preferred_gift = j\n    output.append(str(most_preferred_gift + 1))\n\nprint('\\n'.join(output))\n```", "time_gen": "\ntime generating: 3.860057s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1207": {"code": "```python\ndef count_ways(n, xg, yg):\n    ways = [0] * (n + 1)\n    for _ in range(n):\n        x, y = map(int, input().split())\n        new_ways = [0] * (n + 1)\n        for k in range(1, n + 1):\n            if k <= _:\n                new_ways[k] = ways[k - 1]\n            elif k > _ and yg == xg and xg % (_ - k + 1) == 0:\n                new_ways[k] = new_ways[k - 1] + (ways[_ - k] if _ - k >= 0 else 0)\n        ways = new_ways\n    return ' '.join(map(str, ways[1:]))\n\n\nn = int(input())\nxg, yg = map(int, input().split())\nprint(count_ways(n, xg, yg))\n```\n\nNote that this code is in Python and assumes the input format specified in the problem statement.", "time_gen": "\ntime generating: 7.510393s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1208": {"code": "```python\n```\n\n```\nT = int(input())\nfor _ in range(T):\n    M, N, K = map(int, input().split())\n    folder_list = list(range(1, M+1))\n    email_list = list(range(1, N+1))\n    f = list(map(int, input().split()))\n    \n    for i in range(N):\n        if email_list[i] > K:\n            break\n        to_folder = f[email_list[i]-1]\n        folder_list.insert(to_folder-1, email_list[i])\n        del email_list[i]\n        \n        while len(email_list) < K:\n            email_list.append(len(folder_list)+1)\n            \n        while len(folder_list) < M+1:\n            folder_list.append(M+1)\n    \n    if email_list:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n```", "time_gen": "\ntime generating: 6.911503s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1209": {"code": "```\ndef solve():\n    N = int(input())\n    pref_list = [list(map(int, input().split())) for _ in range(N)]\n    Q = int(input())\n    for _ in range(Q):\n        breed_str = input()\n        same_type_cows = sum(1 for i in range(N) if breed_str[i] == 'H' if i % 2 == 0 else breed_str[i] == 'G')\n        same_breed_gifts = sum((pref_list[i].index(i+1)+1)%2==int(breed_str[i]=='H') for i in range(N))\n        \n        print(max(0, min(same_type_cows, same_breed_gifts)))\n```\n\nNote: This problem is a variant of the classic \"Reassign Gifts\" problem. The twist here is that each cow has a preference list and some constraints on reassignment.", "time_gen": "\ntime generating: 6.138299s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1210": {"code": "```\ndef solve(T, K):\n    p = [0] * (K + 1)\n    for i in range(1, K + 1):\n        p[i] = p[i - 1] + ((-1) ** i) / 2\n    return round((p[K] - p[K - 1]) * T, 6)\n\nT, K = map(int, input().split())\nprint(solve(T, K))\n```", "time_gen": "\ntime generating: 4.077083s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1211": {"code": "```\n```\n\n```python\nimport heapq\nfrom collections import defaultdict\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[self.find(self.parent[x])] = self.find(x)\n        return self.parent[x]\n\n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x == root_y:\n            return\n        if self.rank[root_x] > self.rank[root_y]:\n            self.parent[root_y] = root_x\n        else:\n            self.parent[root_x] = root_y\n            if self.rank[root_x] == self.rank[root_y]:\n                self.rank[root_y] += 1\n\ndef total_cost(cows):\n    edges = []\n    for i in range(len(cows)):\n        for j in range(i+1, len(cows)):\n            cost = ((cows[i][0] - cows[j][0]) ** 2) + (cows[i][1] - cows[j][1]) ** 2\n            edges.append((cost, i, j))\n    heapq.heapify(edges)\n    uf = UnionFind(len(cows))\n    total_cost = 0\n    while edges:\n        cost, x, y = heapq.heappop(edges)\n        if uf.find(x) != uf.find(y):\n            uf.union(x, y)\n            total_cost += cost\n    return total_cost\n\ndef main():\n    n = int(input())\n    cows = [list(map(int, input().split())) for _ in range(n)]\n    print(total_cost(cows))\n\nif __name__ == \"__main__\":\n    main()\n```", "time_gen": "\ntime generating: 10.129652s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1212": {"code": "```\nN, T = map(int, input().split())\nregions = set()\nfor _ in range(N):\n    x1, y1, x2, y2 = map(int, input().split())\n    for i in range(y1, y2+1):\n        for j in range(x1, x2+1):\n            if (i, j) not in regions:\n                if (i, j-1) in regions and T == 1:\n                    break\n                elif (i-1, j) in regions and T == 1:\n                    break\n                regions.add((i, j))\n    for i in range(y2+1, y1-1, -1):\n        for j in range(x2+1, x1-1, -1):\n            if (i, j) not in regions:\n                if (i, j+1) in regions and T == 1:\n                    break\n                elif (i+1, j) in regions and T == 1:\n                    break\n                regions.add((i, j))\nif T == 1:\n    print(len(regions))\nelif T == 2:\n    black = len([x for x in regions if x[0] % 2 == 1])\n    white = len(regions) - black\n    print(white, black)\n```", "time_gen": "\ntime generating: 8.649466s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1213": {"code": "```\ndef min_modifications(log):\n    n = len(log)\n    modifications = 0\n    \n    for i in range(1, n):\n        if log[i] - log[i-1] > 0:\n            modifications += (log[i] - log[i-1]) // (i+1) * (i+1) + min((i+1) - log[i], log[i-1])\n    \n    return modifications\n\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    q = int(input())\n    \n    for _ in range(q):\n        q = int(input())\n        \n        if sum(a) % q != 0:\n            print(-1)\n        else:\n            print(min_modifications(a))\n```", "time_gen": "\ntime generating: 6.270313s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1214": {"code": "```\nimport sys\nfrom math import factorial\ndef calc_permutations(s):\n    d = {'1': 3, '2': 3, '3': 2, '4': 2, '5': 2, '6': 2, '7': 1, '8': 1, '9': 1}\n    return factorial(len(s)) // (reduce(lambda x, y: x * y, [d[i] for i in s], 1))\nfor _ in range(int(sys.stdin.readline())):\n    s = sys.stdin.readline().strip()\n    if len(set(s)) == 4:\n        print(24 % (10**9 + 7))\n    elif set('123').issubset(set(s)):\n        print(factorial(len(s)) // (3 * 2) % (10**9 + 7))\n    else:\n        print(calc_permutations(s) % (10**9 + 7))\n```", "time_gen": "\ntime generating: 6.926399s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1227": {"code": "```\nn = int(input())\ns = input()\n\ng_count = s.count('G')\nholstein_count = n - g_count\n\nreversals = float('inf')\n\nfor i in range(n):\n    g_even_count = sum(1 for j in range(i+1) if (j % 2 == 0 and s[j] == 'G') or (s[j] == 'H' and j % 2 != 0))\n    holstein_even_count = n // 2 - g_even_count\n    if abs(g_even_count - holstein_even_count) <= 1:\n        reversals = min(reversals, i // 2 + i % 2)\n        break\n\nprint(reversals)\n```", "time_gen": "\ntime generating: 4.908726s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1228": {"code": "```\nN = int(input())\nlies = 0\nfor i in range(N):\n    p_i = int(input().split()[1])\n    if (i > 0 and p_i <= all_pis[i-1]) or (i < N-1 and p_i >= all_pis[i]):\n        lies += 1\nprint(lies)\n```", "time_gen": "\ntime generating: 2.735415s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1229": {"code": "```\nimport heapq\nn = int(input())\na = list(map(int, input().split()))\nk = int(input())\npq = []\nfor _ in range(k):\n    l, m = map(int, input().split(1))\n    for i in range(m):\n        pq.append((l - 1, a[l-1]))\nheapq.heapify(pq)\na[n-1] = 0\nwhile pq:\n    t, x = heapq.heappop(pq)\n    if t >= n:\n        break\n    a[t] += x\nprint(a[n-1])\n```", "time_gen": "\ntime generating: 4.455253s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1230": {"code": "```\nimport heapq\nn = int(input())\nvisits = []\nfor _ in range(n):\n    a, v = map(int, input().split())\n    visits.append((-v, a))\n\nheapq.heapify(visits)\nans = 0\nseen = set()\nwhile visits:\n    v, a = heapq.heappop(visits)\n    if a not in seen:\n        ans += -v\n        seen.add(a)\n\nprint(ans)", "time_gen": "\ntime generating: 4.250898s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1231": {"code": "```python\ns = input().lower()\nt = input().lower()\nq = int(input())\n\nfor _ in range(q):\n    query = set(input().lower())\n    if sorted(s)[:len(query)] == sorted(t)[:len(query)]:\n        print('Y')\n    else:\n        print('N')", "time_gen": "\ntime generating: 2.632035s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1232": {"code": "```\ndef reduce_string(s):\n    n = len(s)\n    dp = [[False] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            if s[j - 1] == s[i - 1]:\n                dp[i][j] = True\n            elif (i < j and dp[i][j - 1] and s[j - 1] in {s[i - 2], s[i - 1]} or\n                  i > 1 and dp[i - 1][j] and s[i - 1] in {s[j - 2], s[j - 1]}):\n                dp[i][j] = True\n\n    for q in range(int(input())):\n        l, r = map(int, input().split())\n        print('Y' if dp[l][r] else 'N')\n```", "time_gen": "\ntime generating: 6.118318s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1233": {"code": "```\ndef apple_catcher(cow_times, apple_times):\n    cow_catchers = sorted([(int(t), int(x)) for t, x, n in cow_times if t > 0], key=lambda x: (x[0], -x[1]))\n    apples_caught = 0\n    for i, (t, x) in enumerate(cow_catchers):\n        for a_t, a_x in apple_times:\n            if t >= a_t and abs(x - a_x) <= max(0, min(t - a_t, a_x - x)):\n                apples_caught += 1\n    return apples_caught\n\nN = int(input())\ncow_times = []\napple_times = []\n\nfor _ in range(N):\n    q_i = int(input())  # either 1 (new cow) or 2 (new apple)\n    if q_i == 1:\n        n_i = int(input())  # number of new cows\n        t_i = int(input())\n        x_i = int(input())\n        cow_times.append((q_i, t_i, x_i, n_i))\n    elif q_i == 2:\n        n_i = int(input())  # number of apples\n        t_i = int(input())\n        x_i = int(input())\n        apple_times.append((q_i, t_i, x_i, n_i))\n\nprint(apple_catcher(cow_times, apple_times))\n```", "time_gen": "\ntime generating: 9.277893s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1234": {"code": "```\ndef count_expessions():\n    mod = 10**9 + 7\n    total = 0\n    for _ in range(int(input())):\n        n = int(input())\n        bessie = input()\n        elsie = input()\n        \n        bessie_vars = set(c for c in bessie if c == '+')\n        elsie_vars = set(c for c in elsie if c == '+')\n        \n        if len(bessie_vars & elsie_vars):\n            total += 1\n        else:\n            total += (len(bessie_vars) + len(elsie_vars)) * len(set(d for d in bessie + elsie if d.isdigit()))\n        \n    print(total % mod)\n```", "time_gen": "\ntime generating: 6.044319s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1235": {"code": "```\ndef find_min_imbalance():\n    T, B = map(int, input().split())\n    for _ in range(T):\n        N = int(input())\n        parent = list(map(int, input().split()))\n        bound = []\n        for i in range(N):\n            l, r = map(int, input().split())\n            bound.append([l, r])\n        if B:\n            s = [0] * (N + 1)\n            s[1] = min(r - l for l, r in bound)\n            for i in range(2, N + 1):\n                s[i] += s[parent[i - 1]] + max(bound[i][0], bound[parent[i - 1]][1]) - min(bound[i][0], bound[parent[i - 1]][1])\n            print(min(bound))\n            for i in range(1, N + 1):\n                l, r = bound[i]\n                s[i] = l if s[i] < (r - l) // 2 else r\n            print(' '.join(map(str, s[1:])))\n\nfind_min_imbalance()\n```", "time_gen": "\ntime generating: 8.46908s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1236": {"code": "```\ndef min_final(a):\n    n = len(a)\n    dp = [0] * 1000001\n    for i, x in enumerate(a):\n        y = max(x-1, 1)\n        for j in range(y, 10**6+1):\n            if dp[j-1] > 0:\n                dp[j] = min(dp[j], dp[j-1])\n        dp[x] = min(dp[x], i)\n    return sum(min(dp[i:i+n] for i in range(n)) for _ in range((n*(n+1)//2),))\n\nn = int(input())\na = list(map(int, input().split()))\nprint(min_final(a))\n```", "time_gen": "\ntime generating: 5.703706s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1237": {"code": "```markdown\n```\n```\ndef solution():\n    N, M = map(int, input().split())\n    graph = [[] for _ in range(N+1)]\n    for _ in range(M):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n\n    Q = int(input())\n    res = []\n    for _ in range(Q):\n        x, y = map(int, input().split())\n        if len(graph[x]) == 0 or len(graph[y]) == 0:\n            res.append('H' if len(graph[x]) > 0 else 'B')\n        elif all(node not in graph[x] for node in graph[y]):\n            res.append('H')\n        else:\n            res.append('B')\n\n    print(''.join(res))\n```", "time_gen": "\ntime generating: 5.492706s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1238": {"code": "```\nN = int(input())\np = list(map(int, input().split()))\ns = input()\n\nk = 0\nfor i in range(1, N):\n    if s[i-1] == 'U' and p[i-1] < p[i]:\n        k += 1\n    elif s[i-1] == 'D' and p[i-1] > p[i]:\n        k += 1\n\nprint(k)\n```", "time_gen": "\ntime generating: 3.596729s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1251": {"code": "```\n```\n\n```\n```", "time_gen": "\ntime generating: 1.44827s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1252": {"code": "```\nimport sys\n\ndef read_input():\n    T = int(input())\n    inputs = []\n    for _ in range(T):\n        N, K = map(int, input().split())\n        breed = list(input())\n        inputs.append((N, K, breed))\n    return inputs\n\ndef solve_case(case):\n    N, K, breed = case\n    patches_guernsey = 0\n    patches_holstein = 0\n    for i in range(N-1, -1, -1):\n        if breed[i] == 'G' and (patches_guernsey > 0 or i + K >= N):\n            patches_guernsey += 1\n        elif breed[i] == 'H' and (patches_holstein > 0 or i + K >= N):\n            patches_holstein += 1\n    return str(patches_guernsey + patches_holstein)\n    # print the configuration here\n\ndef main():\n    inputs = read_input()\n    for case in inputs:\n        solution = solve_case(case)\n        print(solution)\n        # print a configuration that uses the minimum amount of patches needed to feed the cows\n        print(\"...\")\n\n\nif __name__ == \"__main__\":\n    sys.stdin = open('in.txt', 'r')\n    main()", "time_gen": "\ntime generating: 8.544195s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1253": {"code": "```\nT = int(input())\nfor _ in range(T):\n    N, M = map(int, input().split())\n    inputs = []\n    for _ in range(M):\n        b, out = input().strip().split()\n        b = [int(x) for x in list(b)]\n        inputs.append((b, int(out)))\n    \n    valid_programs = set()\n    for i in range(2**N):\n        program = \"\"\n        for j in range(N-1):\n            if ((i >> j) & 1) == 0:\n                program += \"if (b[\" + str(j) + \"] == 0) return 0; else \"\n            else:\n                program += \"if (b[\" + str(j) + \"] == 1) return 1; else \"\n        if ((i >> (N-1)) & 1) == 0:\n            program += \"return 0;\"\n        else:\n            program += \"return 1;\"\n        \n        for b, out in inputs:\n            eval(\"if (\" + program[:-6] + b[0] + \") return \" + str(out) + \"; else if (\")\n            i = N - 2\n            while i >= 0:\n                if ((i >> j) & 1) == 0:\n                    eval(program[:-6] + \"b[\" + str(j) + \"] == 0) return \" + str(out) + \"; else \")\n                    break\n                i -= 1\n            if i < 0:\n                eval(\"return \" + str(out) + \";\")\n        \n        valid_programs.add(program)\n    \n    print(len(valid_programs) > 0 and \"OK\" or \"LIE\")\n```", "time_gen": "\ntime generating: 10.768069s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1254": {"code": "```\nimport heapq\nn = int(input())\nhaystacks = list(map(int, input().split()))\nroads = []\nfor _ in range(n-1):\n    u, v = map(int, input().split())\n    roads.append((u, v))\n\ndef get_total_hay():\n    return sum(haystacks)\n\ndef bfs():\n    queue = [(get_total_hay(), 0)]\n    visited = set()\n    while queue:\n        total_hay, order_count = heapq.heappop(queue)\n        if total_hay == len(set(haystacks)):\n            return order_count\n        for road in roads:\n            u, v = road\n            if v not in visited or u not in visited:\n                visited.add(u)\n                visited.add(v)\n                new_total_hay = total_hay - (haystacks[u-1] // len(set(haystacks))) + (haystacks[v-1] // len(set(haystacks)))\n                heapq.heappush(queue, (new_total_hay, order_count+1))\n\norder_count = bfs()\nprint(order_count)\norders = []\nqueue = [(get_total_hay(), 0)]\nvisited = set()\nwhile queue:\n    total_hay, order_count = heapq.heappop(queue)\n    for road in roads:\n        u, v = road\n        if v not in visited or u not in visited:\n            visited.add(u)\n            visited.add(v)\n            new_total_hay = total_hay - (haystacks[u-1] // len(set(haystacks))) + (haystacks[v-1] // len(set(haystacks)))\n            heapq.heappush(queue, (new_total_hay, order_count+1))\n    if order_count == order_count:\n        break\nwhile queue:\n    total_hay, order_count = heapq.heappop(queue)\n    for road in roads:\n        u, v = road\n        if v not in visited or u not in visited:\n            visited.add(u)\n            visited.add(v)\n            new_total_hay = total_hay - (haystacks[u-1] // len(set(haystacks))) + (haystacks[v-1] // len(set(haystacks)))\n            heapq.heappush(queue, (new_total_hay, order_count+1))\n    if order_count == order_count:\n        break\norders = []\nwhile queue:\n    total_hay, order_count = heapq.heappop(queue)\n    for road in roads:\n        u, v = road\n        if v not in visited or u not in visited:\n            visited.add(u)\n            visited.add(v)\n            new_total_hay = total_hay - (haystacks[u-1] // len(set(haystacks))) + (haystacks[v-1] // len(set(haystacks)))\n            heapq.heappush(queue, (new_total_hay, order_count+1))\n    if order_count == order_count:\n        break\nwhile queue:\n    total_hay, order_count = heapq.heappop(queue)\n    for road in roads:\n        u, v = road\n        if v not in visited or u not in visited:\n            visited.add(u)\n            visited.add(v)\n            new_total_hay = total_hay - (haystacks[u-1] // len(set(haystacks))) + (haystacks[v-1] // len(set(haystacks)))\n            heapq.heappush(queue, (new_total_hay, order_count+1))\n    if order_count == order_count:\n        break\norders = []\nwhile queue:\n    total_hay, order_count = heapq.heappop(queue)\n    for road in roads:\n        u, v = road\n        if v not in visited or u not in visited:\n            visited.add(u)\n            visited.add(v)\n            new_total_hay = total_hay - (haystacks[u-1] // len(set(haystacks))) + (haystacks[v-1] // len(set(haystacks)))\n            heapq.heappush(queue, (new_total_hay, order_count+1))\n    if order_count == order_count:\n        break\norders = []\nwhile queue:\n    total_hay, order_count = heapq.heappop(queue)\n    for road in roads:\n        u, v = road\n        if v not in visited or u not in visited:\n            visited.add(u)\n            visited.add(v)\n            new_total_hay = total_hay - (haystacks[u-1] // len(set(haystacks))) + (haystacks[v-1] // len(set(haystacks)))\n            heapq.heappush(queue, (new_total_hay, order_count+1))\n    if order_count == order_count:\n        break\norders = []\nwhile queue:\n    total_hay, order_count = heapq.heappop(queue)\n    for road in roads:\n        u, v = road\n        if v not in visited or u not in visited:\n            visited.add(u)\n            visited.add(v)\n            new_total_hay = total_hay - (haystacks[u-1] // len(set(haystacks))) + (haystacks[v-1] // len(set(haystacks)))\n            heapq.heappush(queue, (new_total_hay, order_count+1))\n    if order_count == order_count:\n        break", "time_gen": "\ntime generating: 29.805947s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1255": {"code": "```\ndef is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef win_farmer(a):\n    i = 1\n    while any(a[i:] for a in [a[:i]]):\n        P = min((p for p in range(1, min(a[i:]) + 1) if is_prime(p)), default=1)\n        a[i] -= P\n        i = (i + 1) % len(a)\n    return \"Farmer John\" if any(a) else \"Farmer Nhoj\"\n\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    a = list(map(int, input().split()))\n    print(\"Farmer John\" if win_farmer(a) == \"Farmer Nhoj\" else \"Farmer Nhoj\")\n```", "time_gen": "\ntime generating: 7.075555s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1256": {"code": "```\nn = int(input())\narr = []\nfor i in range(n):\n    temp = list(map(int, input().split()))\n    arr.append(temp)\n    \nstart = 0\nend = [0] * n\nfor i in range(n):\n    for j in range(i+1):\n        end[i] = max(end[i], start + arr[j][i])\n    if i < n-1:\n        start = sum(arr[:i+1])\nprint(' '.join(map(str, [start - end[i-1] for i in range(1, n)])))\n```", "time_gen": "\ntime generating: 4.818023s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1257": {"code": "```\ndef bessie():\n    N, A, B = map(int, input().split())\n    P = []\n    C = []\n    X = []\n\n    for _ in range(N):\n        p, c, x = map(int, input().split())\n        P.append(p)\n        C.append(c)\n        X.append(x)\n\n    dp = [[0] * (B + 1) for _ in range(A + 1)]\n    for i in range(1, A + 1):\n        for j in range(1, B + 1):\n            if C[0] <= i and X[0] <= j:\n                dp[i][j] = max(dp[i][j], P[0] + dp[i - C[0]][j - X[0]])\n            else:\n                dp[i][j] = dp[i][j]\n\n    print(max(sum(P[:i+1]) for i in range(N) if A >= C[i] and B >= X[i]))\n\nbessie()\n```", "time_gen": "\ntime generating: 7.19935s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1258": {"code": "```\ndef solve(N, Q):\n    H = [0] * (N + 1)\n    for i, h in enumerate(map(int, input().split())):\n        H[i + 1] = h\n    for _ in range(Q):\n        x, y = map(int, input().split())\n        H[x] += y\n    ans = [0]\n    for i in range(2, N + 1):\n        ans.append(ans[-1] - (i * (H[i] - H[i - 1])))\n    print('\\n'.join(map(str, ans[1:])))\n\nsolve(*map(int, input().split()))\n```", "time_gen": "\ntime generating: 5.552009s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1259": {"code": "```\nimport networkx as nx\n\nN, M = map(int, input().split())\nG = nx.Graph()\n\nfor _ in range(M):\n    u, v = map(int, input().split())\n    G.add_edge(u, v)\n\nmax_strength = 0\nfor node in G:\n    for neighbor in G.neighbors(node):\n        strength = G.degree(neighbor)\n        max_strength = max(max_strength, strength)\n\nprint(max_strength)\n```", "time_gen": "\ntime generating: 3.609931s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1260": {"code": "```\nN, K = map(int, input().split())\ngraph = [[] for _ in range(N+1)]\nfor i in range(1, N+1):\n    graph[i] = list(map(int, input().split()))\nfor i in range(1, N+1):\n    for j in range(1, N+1):\n        graph[i].append((j, int(input())))\nedges = [(i, j, w) for i in range(1, N+1) for j in range(1, N+1) if graph[i][j-1]]\nedges.sort(key=lambda x: (x[2], x[0], x[1]))\n\ndef dfs(u, k, visited):\n    if k == 0:\n        return 0\n    if len(visited) > K or u == N:\n        return float('inf')\n    res = float('inf')\n    for v, w in graph[u]:\n        if v not in visited:\n            res = min(res, dfs(v, k-1, visited + [v]) + w)\n    return res\n\nres = []\nfor i in range(N+1):\n    visited = set()\n    res.append(min(dfs(1, K-i, visited) for _ in range(i+1)))\nprint('\\n'.join(map(str, res)))\n```", "time_gen": "\ntime generating: 8.825178s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1261": {"code": "```\nM, N = map(int, input().split())\nfriendships = set()\nfor _ in range(M):\n    u, v = map(int, input().split())\n    friendships.add((min(u, v), max(u, v)))\n\nans = 0\nfor i in range(N-1):\n    ans += len(friendships) - (len(set([pair[0] for pair in friendships if pair[0] <= i])) +\n                                 len(set([pair[1] for pair in friendships if pair[1] >= i+2])))\nprint(ans)\n```", "time_gen": "\ntime generating: 3.981952s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1262": {"code": "```\ndef sum_of_transpositions(lineup):\n    n = len(lineup)\n    total = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            subsequence = lineup[i:j+1]\n            if subsequence == subsequence[::-1]:\n                continue\n            transpositions = 0\n            left, right = 0, len(subsequence) - 1\n            while left < right:\n                if subsequence[left] != subsequence[right]:\n                    break\n                left += 1\n                right -= 1\n            if left == right:\n                total += 0\n            else:\n                transpositions += min(left, right)\n                total += transpositions\n    return total\n\nlineup = input()\nprint(sum_of_transpositions(lineup))\n```", "time_gen": "\ntime generating: 5.726684s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1275": {"code": "```\nn = int(input())\nbreed = input()\nleaders = list(map(int, input().split()))\nguernsey_count = breed.count('G')\nholstein_count = breed.count('H')\n\n# Count number of leaders that must have a list including all Guernseys\nguernsey_leaders = 0\nfor i in range(n):\n    if i < guernsey_count:\n        if leaders[i] > 1 and (leaders[i] == n or breed[leaders[i]-1] == 'G'):\n            guernsey_leaders += 1\n\n# Count number of leaders that must have a list including all Holsteins\nholstein_leaders = 0\nfor i in range(n):\n    if i < holstein_count:\n        if leaders[i] > 1 and (leaders[i] == n or breed[leaders[i]-1] == 'H'):\n            holstein_leaders += 1\n\n# Count number of valid leader pairs\nvalid_pairs = guernsey_leaders * holstein_leaders\nprint(valid_pairs)\n```", "time_gen": "\ntime generating: 6.757775s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1276": {"code": "```\nn, m = map(int, input().split())\ncow_stalls = []\nair_conditioners = []\n\nfor _ in range(n):\n    s, t, c = map(int, input().split())\n    cow_stalls.append((s, t, c))\n\nfor _ in range(m):\n    a, b, p, m = map(int, input().split())\n    air_conditioners.append((a, b, p, m))\n\ncow_stalls.sort()\nair_conditioners.sort(key=lambda x: (x[1], -x[3]))\n\nmin_cost = 0\ncurr_cow = 0\n\nfor ac in air_conditioners:\n    while curr_cow < n and cow_stalls[curr_cow][1] <= ac[1]:\n        if cow_stalls[curr_cow][2] > 0:\n            min_cost += max(0, ac[3] - (ac[2] - (cow_stalls[curr_cow][1] - cow_stalls[curr_cow][0] + 1) * (10 ** 6)))\n        curr_cow += 1\n\nprint(min_cost)\n```", "time_gen": "\ntime generating: 7.577743s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1277": {"code": "```\ndef solve(q):\n    for _ in range(q):\n        s = input()\n        m, o = s.count('M'), s.count('O')\n        if m == 2 and o == 1:\n            print(0)\n        else:\n            operations = max(abs(m - 2), abs(o - 1))\n            print(operations)\n\nq = int(input())\nsolve(q)\n```", "time_gen": "\ntime generating: 3.267862s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1278": {"code": "```\nT = int(input())\nfor _ in range(T):\n    s1, s2 = input().split()\n    if s1 == s2:\n        print(0)\n    elif len(set(s1)) != len(set(s2)):\n        print(-1)\n    else:\n        diff_count = 0\n        for c1, c2 in zip(s1, s2):\n            if c1 != c2:\n                diff_count += 1\n        print(diff_count)\n```", "time_gen": "\ntime generating: 4.007636s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1279": {"code": "```\nN = int(input())\ngrid = [input().split() for _ in range(N)]\nvat_costs = [[int(c) if c != 'R' and c != 'D' else 0 for c in row[1:]] + [int(row[-1])] for row in grid]\nqueries = [list(map(int, input().split())) for _ in range(int(input()))]\n\nfor query in queries:\n    i, j = query\n    if vat_costs[i][j] == 0:\n        vat_costs[i][j] = int(grid[i][j-1])\n    else:\n        vat_costs[i][j] = 0\n\ntotal_cost = sum(sum(row) for row in vat_costs)\nprint(total_cost)\n\nfor query in queries:\n    i, j = query\n    if vat_costs[i][j] == 0:\n        vat_costs[i][j] = int(grid[i][j-1])\n    else:\n        vat_costs[i][j] = 0\n    total_cost = sum(sum(row) for row in vat_costs)\n    print(total_cost)\n```", "time_gen": "\ntime generating: 8.310269s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1280": {"code": "```\nN = int(input())\nA = list(map(int, input().split()))\nT = sum(A)\nS = ''\ni, dir = 0, 'R'\nfor _ in range(T):\n    if i < A[dir == 'R'] - 1:\n        S += dir\n        i += 1\n    else:\n        dir = 'L' if dir == 'R' else 'R'\n        S += dir\n        i = 0\nprint(S)\n```", "time_gen": "\ntime generating: 4.387587s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1281": {"code": "```\nimport re\n\nl, r, n = map(int, input().split())\ns = 'a'\nfor _ in range(n):\n    c, s_ = input().split()\n    s = re.sub(re.escape(c), lambda x: ''.join([c] + list(s_)), s)\nprint(s[l-1:r])\n```", "time_gen": "\ntime generating: 3.11282s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1282": {"code": "```\ndef count_moves(lights, switches):\n    moves = 0\n    while True:\n        off_switches = sum(switches)\n        if all(not bit for bit in lights):\n            return moves\n        for i in range(len(switches)):\n            if switches[i] == 1:\n                lights[i] = not lights[i]\n        switches = [switch for switch in switches[1:]] + [off_switches % 2]\n        moves += 1\n\nt, n = map(int, input().split())\nfor _ in range(t):\n    lights, switches = zip(*map(int, input().split()))\n    print(count_moves(lights, list(switches)))\n```", "time_gen": "\ntime generating: 5.066046s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1283": {"code": "```\nimport math\n\ndef solve():\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    if N == 0:\n        return \"0\\n\"\n    \n    if len(A) != N or min(A) < 1 or max(A) > N:\n        raise Exception(\"Invalid input\")\n    \n    res = math.inf\n    for i in range(N):\n        Bessie_moves_left = A[i]\n        for j in range(i+1, N):\n            Bessie_moves_right = sum(A[j:])\n            if abs(Bessie_moves_left - Bessie_moves_right) % 2 == 0:\n                res = min(res, (Bessie_moves_left + Bessie_moves_right)//2)\n    \n    return str((res + N - 1) // 2) + \"\\n\"\n```", "time_gen": "\ntime generating: 5.803049s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1284": {"code": "```\nn, q = map(int, input().split())\nlefts, rights = [], []\nspecials = [0] * (n + 1)\nfor i in range(n):\n    if i % 2 == 0:\n        lefts.append(int(input()))\n    else:\n        rights.append(int(input()))\n\nlefts.sort()\nrights.sort()\n\nfor i in range(0, len(lefts), 2):\n    specials[0] = len(lefts) - i // 2\n    for j in range(i, min(len(lefts), i + 3)):\n        specials[j] = 1\n\nfor _ in range(q):\n    a, b = map(int, input().split())\n    print(min(b - a, len(rights) - (rights.index(rights[b]) - rights.index(lefts[a])))),\n\n    for i in range(a, b + 1):\n        if specials[i]:\n            print(specials.count(1))\n            break\n    else:\n        print(0)\n```", "time_gen": "\ntime generating: 7.828603s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1285": {"code": "```\ndef max_mana(m, t):\n    d = {}\n    for a, b, c in zip(*[iter([a, m[a-1], t])]*3):\n        if a not in d:\n            d[a] = c\n        else:\n            d[a] += c\n    return sum(d.get(i, 0) for i in range(1, N+1))\n\nN, M = map(int, input().split())\nm = list(map(int, input().split()))\nt = []\nfor _ in range(M):\n    a, b, c = map(int, input().split())\n    t.append((a-1, b-1, c))\nQ = int(input())\nans = [max_mana({i: 0 for i in range(1, N+1)}, s) - m[e-1] if e != 1 else max_mana({i: 0 for i in range(1, N+1)}, s) for s, e in zip(*[iter([s, e])]*Q)]\nprint('\\n'.join(map(str, ans)))\n```", "time_gen": "\ntime generating: 7.945531s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1286": {"code": "```\nimport sys\nfrom collections import deque\n\nN = int(sys.stdin.readline())\nparent = [0] + list(map(int, sys.stdin.readline().split()))\nvisited = [False] * (N+1)\ndepth = [0] * (N+1)\nqueue = deque([(1, 1)])\n\nwhile queue:\n    node, par = queue.popleft()\n    if not visited[node]:\n        visited[node] = True\n        depth[node] = depth[par]\n        if par > 0:\n            depth[node] += 1\n        for child in range(node+1, N+1):\n            if parent[child] == node and not visited[child]:\n                queue.append((child, node))\n                break\n\nans = 0\nfor i in range(N+1):\n    if visited[i]:\n        ans += 2\n    else:\n        ans += 1\nprint(ans)\n```", "time_gen": "\ntime generating: 6.075572s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1299": {"code": "```\nN, T = map(int, input().split())\ntotal_haybales = 0\nfor i in range(N):\n    day, bale = map(int, input().split())\n    total_haybales += min(bale, T - day + 1)\nprint(total_haybales)\n```", "time_gen": "\ntime generating: 3.610809s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1300": {"code": "```\ndef stamp_painting(N, K, stamp):\n    for i in range(N-K+1):\n        for j in range(N-K+1):\n            if all(stamp[i+k-1][j+l-1] == '*' for k in range(K) for l in range(K)):\n                return \"YES\"\n    return \"NO\"\n\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    desired_painting = [input() for _ in range(N)]\n    K = int(input())\n    stamp = [input() for _ in range(K)]\n    print(stamp_painting(N, K, stamp))\n```", "time_gen": "\ntime generating: 5.255748s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1301": {"code": "```\nimport heapq\n\nN, K = map(int, input().split())\ndays = list(map(int, input().split()))\nheap = []\n\nfor day in days:\n    if heap and heap[0] <= day - 1:\n        heapq.heappop(heap)\n    heapq.heappush(heap, day + K)\n\nprint(sum(heap))\n```", "time_gen": "\ntime generating: 3.059502s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1302": {"code": "```\nT = int(input())\n\nfor _ in range(T):\n    N, tC, tM = map(int, input().split())\n    friends = []\n    for _ in range(N):\n        a, b, c = map(int, input().split())\n        friends.append((a, b, c))\n    \n    moonies = 0\n    while True:\n        reducedTC = max(1, tC - 1)\n        reducedTM = max(1, tM - 1)\n        \n        satisfiedFriends = 0\n        for a, b, c in friends:\n            if (a + b) * min(tC, tM) <= c:\n                continue\n            timeNeeded = min((c - ((min(a, b)) * reducedTC + max(0, b) * reducedTM)) // reducedTM, (c - ((max(0, a) * reducedTC + min(b, a))) * reducedTM) // reducedTC)\n            if timeNeeded <= c:\n                satisfiedFriends += 1\n        \n        moonies += 1\n        if satisfiedFriends == N:\n            break\n    \n    print(moonies)\n```", "time_gen": "\ntime generating: 8.131796s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1303": {"code": "```\ng, n = map(int, input().split())\ngrazings = []\nfor _ in range(g):\n    x, y, t = map(int, input().split())\n    grazings.append((x, y, t))\n\nalibis = []\nfor _ in range(n):\n    x, y, t = map(int, input().split())\n    alibis.append((x, y, t))\n\ncount = 0\nfor i, (gx, gy, gt) in enumerate(grazings):\n    for j, (ax, ay, at) in enumerate(alibis):\n        if ((ax - gx)**2 + (ay - gy)**2)**(1/2) <= gt - at:\n            break\n    else:\n        count += 1\n\nprint(count)\n```", "time_gen": "\ntime generating: 5.877199s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1304": {"code": "```\nimport heapq\n\nn, m = map(int, input().split())\ngraph = [[] for _ in range(n + 1)]\nfor i in range(m):\n    c, r, d, s = map(int, input().split())\n    graph[c].append((s, d))\nfor i in range(1, n + 1):\n    a_i = int(input())\n    pq = [(0, i)]  # (time, airport)\n    for t, d in graph[i]:\n        if t >= s and t - s <= a_i:\n            heapq.heappush(pq, (t, d))\n    print(-1) if not pq else print(pq[0][0])\n```", "time_gen": "\ntime generating: 5.860948s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1305": {"code": "```\nn = int(input())\na = list(map(int, input().split()))\nfor i in range(n):\n    for j in range(i+1, n):\n        if sum(a[:i+1]) == sum(a[j:]):\n            print(abs(a[i] - a[j]))\n            break\n```", "time_gen": "\ntime generating: 2.676252s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1306": {"code": "```\nimport heapq\nn, t = map(int, input().split())\ngraph = [[] for _ in range(n)]\nfor i in range(2, n):\n    p, a = map(int, input().split())\n    graph[p].append((a, i))\n    graph[i].append((0, p))\n\nif t == 1:\n    pq = [(0, 0, [1])]\nelse:\n    pq = [(0, 0, [1])]\n\nans_time = float('inf')\nans_fertilizer = float('inf')\n\nwhile pq:\n    time, fertilizer, path = heapq.heappop(pq)\n    if t == 0 and path[-1] != 1:\n        continue\n    for a, node in graph[path[-1]]:\n        if node not in path:\n            new_time = time + a\n            new_fertilizer = fertilizer + a\n            new_path = list(path) + [node]\n            heapq.heappush(pq, (new_time, new_fertilizer, new_path))\n            if new_time < ans_time or (new_time == ans_time and new_fertilizer < ans_fertilizer):\n                ans_time = new_time\n                ans_fertilizer = new_fertilizer\n\nprint(f\"{ans_time} {ans_fertilizer}\")\n```", "time_gen": "\ntime generating: 9.835877s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1307": {"code": "```\ndef get_count(N, A, B):\n    MOD = 10**9 + 7\n    dp = [0] * (B - A + 1)\n    for i in range(1, N+1):\n        for j in range(B-A, 0, -1):\n            if int(''.join(map(str, a[:i])) + str(j)) >= A and int(''.join(map(str, a[:i])) + str(j)) <= B:\n                dp[j-A] += 3**(N-i)\n                dp[j-A] %= MOD\n    return sum(dp)\n\nN, A, B = map(int, input().split())\na = list(map(int, input().split()))\nQ = int(input())\nfor _ in range(Q):\n    l, r = map(int, input().split())\n    print(get_count(N, A, B))\n```", "time_gen": "\ntime generating: 6.649614s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1308": {"code": "```\ndef solve():\n    u = int(input())\n    for _ in range(u):\n        d, b = map(int, input().split())\n        if b > 0:\n            print((d + sum(range(1, b+1))) % (10**9 + 7))\n        else:\n            print(d % (10**9 + 7))\n\nif __name__ == \"__main__\":\n    solve()\n```", "time_gen": "\ntime generating: 3.410069s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1309": {"code": "```\ndef f(n, m):\n    MOD = 10**9 + 7\n    dp = [[0] * (1 << n) for _ in range(m+1)]\n    dp[0][0] = 1\n    for i in range(1, m+1):\n        for j in range(i-1, -1, -1):\n            if not ((1<<i)&j): dp[i][j^((1<<i))]+=dp[j][j^((1<<i))]\n        if (1<<i)%MOD == 0: dp[i][-1] = sum(dp[i][:])%MOD\n    return sum([v for v in dp[m]]) % MOD\n\nn, m = map(int, input().split())\nprint(f(n, m))\n```", "time_gen": "\ntime generating: 5.261735s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1310": {"code": "```\nn = int(input())\ncowlix = list(map(int, input()))\nedges = []\nfor _ in range(n-1):\n    a, b = map(int, input().split())\n    edges.append((a, b))\n\ndef dfs(node, parent, visited, component_size):\n    visited.add(node)\n    for edge in edges:\n        if edge[0] == node and edge[1] not in visited:\n            dfs(edge[1], node, visited, component_size + 1)\n        elif edge[1] == node and edge[0] not in visited:\n            dfs(edge[0], node, visited, component_size + 1)\n    return component_size\n\nmin_cost = float('inf')\nfor k in range(1, n+1):\n    visited = set()\n    component_sizes = []\n    for i in range(n):\n        if cowlix[i]:\n            component_size = dfs(i, None, visited, 0)\n            while visited:\n                visited.pop()\n            component_sizes.append(component_size + k)\n    min_cost = min(min_cost, sum(component_sizes))\n\nprint(*min_cost for _ in range(1, n+1), sep='\\n')\n```", "time_gen": "\ntime generating: 8.068133s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1323": {"code": "```\nN = int(input())\nS = input()\nexcitement_levels = set()\n\nfor i in range(len(S)):\n    for j in range(i+2, len(S)+1):\n        substring = S[i:j]\n        if 'BB' in substring or 'EE' in substring:\n            excitement_levels.add(substring.count('BB') + substring.count('EE'))\n\nprint(len(excitement_levels))\nfor level in sorted(list(excitement_levels)):\n    print(level)\n```", "time_gen": "\ntime generating: 3.473454s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1324": {"code": "```\npython\ndef solve():\n    for _ in range(int(input())):\n        N, C, P = map(int, input().split())\n        words = []\n        word_types = []\n        for _ in range(N):\n            w, t = input().split()\n            words.append(w)\n            word_types.append(t)\n\n        max_length = 0\n        sentence = ''\n        for i in range(len(word_types)):\n            if word_types[i] == 'noun':\n                sentence += words[i]\n                if i < len(word_types) - 1:\n                    sentence += ', '\n            elif word_types[i] == 'transitive-verb' and (i + 2 >= len(word_types) or word_types[i+2] != 'noun'):\n                continue\n            elif word_types[i] == 'intransitive-verb':\n                if i < len(word_types) - 1:\n                    sentence += words[i] + '. '\n                else:\n                    sentence += words[i]\n                    max_length = max(max_length, len(sentence))\n                    sentence = ''\n            elif word_types[i] == 'conjunction' and i > 0:\n                sentence = sentence[:-2] + ', ' + words[i]\n\n        if P != C:\n            for i in range(len(word_types) - 1):\n                if word_types[i] == 'intransitive-verb':\n                    max_length = min(max_length, len(sentence))\n                    sentence += '. '\n                    break\n            sentence = sentence[:-2]\n        else:\n            max_length = max_length + P\n\n        print(max_length)\n        print(sentence)\n```", "time_gen": "\ntime generating: 10.913249s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1325": {"code": "```\nimport sys\n\nN, K, T = map(int, input().split())\nA = list(map(int, input().split()))\norder = [i for i in range(N)]\nfor _ in range(T):\n    for i in range(K-1):\n        order[A[i]], A[i] = A[i], (A[i]+1)%N\nprint(' '.join(map(str, order)))\n```", "time_gen": "\ntime generating: 4.236108s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1326": {"code": "```\nN = int(input())\na = list(map(int, input().split()))\nQ = int(input())\n\nT = sum(i*(a[i-1] if i > 0 else 0) for i in range(1, N+1))\n\nfor _ in range(Q):\n    i, j = map(int, input().split())\n    a[i-1] = j\n    T = sum(i*(a[i-1] if i > 0 else 0) for i in range(1, N+1))\n    print(T)\n```", "time_gen": "\ntime generating: 5.175346s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1327": {"code": "```\nN, C = map(int, input().split())\nmax_diff = [0] * N\nfor i in range(N):\n    team = list(input()[:C])\n    diff = 0\n    prev_breed = 'G'\n    for j in range(C):\n        breed = team[j]\n        if breed != prev_breed:\n            diff += 1\n        prev_breed = breed\n    max_diff[i] = diff\n\nfor i in range(N):\n    print(max([abs(j - k) for j in range(N) for k in range(N) if j != k and max_diff[j] == j and max_diff[k] == k]))\n```", "time_gen": "\ntime generating: 4.195422s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1328": {"code": "```\ndef total_bessies(s):\n    n = len(s)\n    res = 0\n    for i in range(n):\n        bessies = 0\n        for j in range(i, n):\n            if s[j:j+6] == \"bessie\":\n                bessies += 1\n            else:\n                break\n        res += bessies\n    return res\n\ns = input()\nprint(total_bessies(s))\n```", "time_gen": "\ntime generating: 3.573476s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1329": {"code": "```python\ndef can_return_to_stall(stalls_colors, stalls_keys, final_states):\n    n = len(stalls_colors)\n    visited = [False] * (n + 1)\n    for state in final_states:\n        if not visited[state]:\n            visited[state] = True\n            for i in range(n):\n                if state == i and stalls_colors[i] == stalls_keys[i]:\n                    return False\n    return True\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    stalls_colors = list(map(int, input().split()))\n    stalls_keys = list(map(int, input().split()))\n    final_states = []\n    for _ in range(m):\n        x, y, z = map(int, input().split())\n        final_states.append(y)\n    if can_return_to_stall(stalls_colors, stalls_keys, final_states):\n        print(\"YES\")\n    else:\n        print(\"NO\")", "time_gen": "\ntime generating: 10.04267s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1330": {"code": "```\nimport sys\n\ndef find_max_bessie(s):\n    n = len(s)\n    dp = [[0, 0] for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        if s[i - 1] == 'b' and i >= 6:\n            j = i - 6\n            while j >= 0 and s[j:j+6] != \"bessie\":\n                j -= 1\n            if j >= 0:\n                dp[i][0] = max(dp[i][0], dp[j][0] + (i - 1) * c[j])\n        dp[i][1] += c[i - 1]\n    \n    return max((dp[n][0], dp[n][1]))\n\nc = list(map(int, input().split()))\ns = input()\nprint(*find_max_bessie(s))\n```", "time_gen": "\ntime generating: 6.520415s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1331": {"code": "```\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    initial_tree = {}\n    for _ in range(N - 1):\n        v, p = map(int, input().split())\n        if p not in initial_tree:\n            initial_tree[p] = []\n        initial_tree[p].append(v)\n\n    M = int(input())\n    final_tree = {}\n    for _ in range(M - 1):\n        v, p = map(int, input().split())\n        if p not in final_tree:\n            final_tree[p] = []\n        final_tree[p].append(v)\n\n    operations = []\n    stack = [(n, set([n])) for n in initial_tree]\n    while stack:\n        node, parent_set = stack.pop()\n        if node in final_tree and len(final_tree[node]) == 1:\n            continue\n        max_val = max(parent_set)\n        for child in list(initial_tree.get(node, [])):\n            new_parent_set = set(list(parent_set))\n            new_parent_set.add(child)\n            stack.append((child, new_parent_set))\n        if node in final_tree and len(final_tree[node]) > 1:\n            for child in list(final_tree[node]):\n                operations.append(max_val + \" \" + str(child))\n    print(len(operations))\n    for operation in operations:\n        print(operation)", "time_gen": "\ntime generating: 8.653284s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1332": {"code": "```\ndef calculate_bessies(s):\n    n = len(s)\n    bessie_count = 0\n    current_bessie_count = 0\n    \n    for i in range(n):\n        if s[i:i+6] == \"bessie\":\n            bessie_count += current_bessie_count + 1\n            current_bessie_count = 0\n        elif current_bessie_count > 0:\n            current_bessie_count -= 1\n    \n    return bessie_count\n\ndef update_string(s, p, c):\n    return s[:p-1] + c + s[p:]\n\nt = input()\nn = len(t)\nbessies = calculate_bessies(t)\n\nfor _ in range(int(input())):\n    p, c = input().split()\n    p, c = int(p), c[0]\n    bessies = (bessies - 1) if t[p-1].lower() == \"e\" and bessie_count > 0 else bessies\n    t = update_string(t, p, c)\n    print(bessies)\n\nprint(bessies)\n```", "time_gen": "\ntime generating: 7.749791s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1333": {"code": "```\nimport math\n\ndef solve(A, B):\n    res = 0\n    for i in range(min(A, B) + 1):\n        if (A - i) * B <= i * A:\n            res += 1\n        else:\n            break\n    return res\n\nT = int(input())\nfor _ in range(T):\n    A, B = map(int, input().split())\n    print(solve(A, B))\n```", "time_gen": "\ntime generating: 4.57542s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1334": {"code": "```\nN = int(input())\nfriends = [set() for _ in range(N)]\nfor i in range(N-1):\n    u, v = map(int, input().split())\n    friends[u].add(v)\n    friends[v].add(u)\n\ntriples = 0\nfor a in range(1, N):\n    for b in range(a+1, N):\n        if b in friends[a]:\n            for c in range(b+1, N):\n                if c in friends[b] and c not in friends[a]:\n                    triples += 1\n\nfor i in range(N):\n    print(triples - sum(len(friends[j]) for j in range(i)))\n```", "time_gen": "\ntime generating: 5.039099s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1347": {"code": "```\ndef main():\n    N, M = map(int, input().split())\n    cows_heights = list(map(int, input().split()))\n    candy_cane_heights = list(map(int, input().split()))\n\n    for cane_height in candy_cane_heights:\n        for i in range(N):\n            if cows_heights[i] < cane_height:\n                cows_heights[i] += min(cows_heights[i], cane_height)\n            else:\n                break\n        for i in range(N):\n            cows_heights[i] += cane_height - cows_heights[i]\n\n    print(*cows_heights, sep='\\n')\n\nif __name__ == \"__main__\":\n    main()\n```", "time_gen": "\ntime generating: 5.30274s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1348": {"code": "```\nn = int(input())\ns = input()\n\nmin_affected = n\nmax_affected = 0\nfor i in range(n):\n    affected = sum(1 for j in range(i) if s[j] == '1')\n    max_affected = max(max_affected, affected)\nprint(min_affected)\n```", "time_gen": "\ntime generating: 3.206574s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1349": {"code": "```\nT = int(input())\n\nfor _ in range(T):\n    N = int(input())\n    h = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    t = list(map(int, input().split()))\n\n    days = 0\n    while True:\n        taller_than_i = [j for j in range(N) if j != i and h[j] > h[i]]\n        if len(taller_than_i) == t[i]:\n            break\n        h = [hi + ai for hi, ai in zip(h, a)]\n        days += 1\n        i = (i + 1) % N\n\n    print(days if days < float('inf') else -1)\n```", "time_gen": "\ntime generating: 6.514453s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1350": {"code": "```\nN, M, K = map(int, input().split())\nweights = []\nfor _ in range(N):\n    w, a = map(int, input().split())\n    weights += [w] * a\nweights.sort(reverse=True)\nans = 0\ni = 0\nwhile i < len(weights) and M > 0:\n    j = i\n    while j < len(weights) and weights[j] - K >= weights[i]:\n        j += 1\n    ans += j - i\n    i = j\n    M -= (j - i)\nprint(ans)\n```", "time_gen": "\ntime generating: 4.489029s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1351": {"code": "```\ndef find_fixed_points(n, k, a, b):\n    fixed_points = set()\n    \n    for i in range(k - 1):\n        if a[i] + 1 == a[(i + 1) % k]:\n            fixed_points.add(a[i])\n        if b[i] + 1 == b[(i + 1) % k]:\n            fixed_points.add(b[i])\n            \n    return len(fixed_points)\n```", "time_gen": "\ntime generating: 3.608019s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1352": {"code": "```\nt, c = [int(x) for x in input().split()]\ntargets = list(map(int, input().split()))\ncommands = input()\n\nmax_targets = 0\nfor i in range(c):\n    if targets[i] == 0:\n        max_targets += 1\nprint(max_targets)\n```", "time_gen": "\ntime generating: 3.448771s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1353": {"code": "```\nimport itertools\n\ndef count_pairs( N, parity_flights ):\n    pairs = 0\n    for i, j in itertools.combinations( range(N), r=2 ):\n        if (parity_flights[i-1][j-i] + parity_flights[j-1][i-j]) % 2 == 1:\n            pairs += 1\n    return pairs\n\nN = int(input())\nparity_flights = [list(map(int, input().split())) for _ in range(N-1)]\nprint(count_pairs( N, parity_flights ))\n```", "time_gen": "\ntime generating: 4.729807s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1354": {"code": "```\nimport heapq\n\nN, M = map(int, input().split())\nroads = []\nfor _ in range(M):\n    a, b, l = map(int, input().split())\n    roads.append((l, a, b))\n\ntowns = [0] * (N + 1)\nprev_town = {}\nfor i in range(N - 1, -1, -1):\n    town = N\n    for road in roads:\n        if road[2] == i and road[1] > towns[road[1]]:\n            towns[i] = road[0]\n            prev_town[i] = road[1]\n            break\n\ndef get_trip_length_sum(town):\n    trip = [town]\n    while town != 1:\n        town = prev_town[town]\n        trip.append(town)\n    print(f'{len(trip) - 1} {sum(roads[i][0] for i in range(len(roads)) if roads[i][2] in trip)}')\nfor i in range(N):\n    get_trip_length_sum(i+1)\n\n```", "time_gen": "\ntime generating: 8.256413s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1355": {"code": "```\nimport heapq\n\nN = int(input())\nx_barns = list(map(int, input().split()))\nQ = int(input())\n\nheap = []\nfor _ in range(Q):\n    a, b = map(int, input().split())\n    heapq.heappush(heap, (a + b, -b))  # Push the tuple (-b, a+b) to heap\n\nans = []\nfor _ in range(N):\n    ans.append(min(0, min(-heap[0][1], sum(x_barns))))\n    for i in range(len(heap)):\n        heapq.heappop(heap)\nprint(\"\\n\".join(map(str, ans)))\n```", "time_gen": "\ntime generating: 4.986998s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1356": {"code": "```\nimport sys\nfrom collections import deque\n\nN = int(input())\ninfected_cows = [int(x) for x in input()]\ngraph = {}\nfor _ in range(N - 1):\n    a, b = map(int, input().split())\n    if a not in graph:\n        graph[a] = []\n    if b not in graph:\n        graph[b] = []\n    graph[a].append(b)\n    graph[b].append(a)\n\nQ = int(input())\nfor _ in range(Q):\n    nights = int(input())\n    infected_set = set(infected_cows)\n    queue = deque([(night, 0) for night in range(nights + 1)])\n    visited = {i: False for i in range(N)}\n    while queue:\n        n, day = queue.popleft()\n        if day > nights:\n            break\n        for cow in graph.get(n, []):\n            if not visited[cow]:\n                visited[cow] = True\n                queue.append((cow, day + 1))\n    if any(not visited[i] for i in range(N)):\n        print(-1)\n    else:\n        print(len(infected_set) - len([i for i in infected_set if not visited[i]]))\n```", "time_gen": "\ntime generating: 8.43789s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1357": {"code": "```\ndef solve():\n    N, M = map(int, input().split())\n    edges = [list(map(int, input().split())) for _ in range(M)]\n    ans = [0] * (N + 1)\n\n    for i in range(N):\n        S = {i}\n        h = 0\n        while len(S) < N:\n            e = min([edge for edge in edges if edge[0] in S and edge[1] not in S] or [edge for edge in edges if edge[1] in S and edge[0] not in S], key=lambda x: (x[0], x[1]))\n            S.add(e[1])\n            h = 10 * h + e[0]\n        ans[i] = h % (10**9 + 7)\n\n    for i, a in enumerate(ans):\n        print(a)\n\nsolve()\n```", "time_gen": "\ntime generating: 6.725202s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1358": {"code": "```python\nimport heapq\nT, N = map(int, input().split())\ns, t = [], []\nfor _ in range(N):\n    si, ti = input().split()\n    s.append(si == 'A')\n    t.append(int(ti))\n\nt.sort()\n\npq = [(ti + T, 1 - si) for (si, ti) in zip(s, t)]\npq.sort()\nans = 0\ni = 0\nfor si, ti in pq:\n    while i < N and ti >= t[i]:\n        i += 1\n    if i > 0:\n        ans += ti - t[i - 1]\nprint(ans)\n```", "time_gen": "\ntime generating: 5.368816s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1371": {"code": "```\nimport heapq\n\ndef find_hay_types():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        hays = list(map(int, input().split()))\n        count = [0] * (n + 1)\n        for hay in hays:\n            count[hay] += 1\n        min_heap = []\n        for i in range(n + 1):\n            if count[i]:\n                heapq.heappush(min_heap, (-count[i], i))\n        if len(min_heap) > 2:\n            print(-1)\n        else:\n            hays_to_print = set()\n            while min_heap:\n                c, hay = heapq.heappop(min_heap)\n                for _ in range(c):\n                    if -c <= len(hays_to_print):\n                        break\n                    hays_to_print.add(hay)\n            print(' '.join(map(str, sorted(list(hays_to_print)))))\n\n\nfind_hay_types()\n```", "time_gen": "\ntime generating: 7.232484s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1372": {"code": "```\ndef bouncing_targets(n, s):\n    targets_broken = 0\n    power = 1\n    while True:\n        if s > n or s < 1:\n            break\n        target = (q := [line.split()][s-1])[-1]\n        if q[0] == '1':\n            if power >= int(target):\n                targets_broken += 1\n            power = int(target)\n        elif q[0] == '0':\n            power += int(target)\n        s += power\n    return targets_broken\n\nn, s = map(int, input().split())\nq = []\nfor _ in range(n):\n    line = input()\n    q.append(line.split())\n\nprint(bouncing_targets(n, s))\n```", "time_gen": "\ntime generating: 5.964278s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1373": {"code": "```\nimport math\n\nN = int(input())\na = list(map(int, input().split()))\nb = [0] * N\nfor i in range(N):\n    b[i] = min(max(a[i], 0), 10**15)\nans = 0\nL = N\nwhile True:\n    L -= 1\n    for i in range(L):\n        if a[i] < 0:\n            a[i] += 1\n        elif a[i] > 0:\n            a[i] -= 1\n    if all(0 <= x <= 10**15 for x in a):\n        break\n    ans += 1\nprint(ans)\n```", "time_gen": "\ntime generating: 5.353548s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1374": {"code": "```\nT = int(input())\nfor _ in range(T):\n    N, Q, C = map(int, input().split())\n    scores = list(map(int, input().split()))\n    pairs = []\n    for _ in range(Q):\n        a, h = map(int, input().split())\n        pairs.append((a, h))\n\n    def get_max_scores(i):\n        max_scores = [0] * (i + 1)\n        for j in range(i + 1):\n            if scores[j] > 0:\n                max_scores[j] = scores[j]\n            else:\n                max_scores[j] = max_scores[j - 1] if j > 0 else 0\n        return max_scores\n\n    def check_validity(max_scores, pairs):\n        for a, h in pairs:\n            if scores[a - 1] >= max_scores[h - 1]:\n                return False\n        return True\n\n    def get_minimal_score(i):\n        max_scores = get_max_scores(i)\n        while not check_validity(max_scores, pairs):\n            i -= 1\n            if i == 0:\n                break\n            max_scores = get_max_scores(i)\n        return max_scores[:]\n\n    minimal_scores = get_minimal_score(N)\n\n    result = []\n    for score in minimal_scores:\n        result.append(str(score))\n    print(' '.join(result)) if minimal_scores else print(-1)", "time_gen": "\ntime generating: 10.937017s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1375": {"code": "```\nn = int(input())\npotsions = list(map(int, input().split()))\nedges = [list(map(int, input().split())) for _ in range(n-1)]\n\ndp = [[0] * (2**n) for _ in range(n)]\nfor i in range(1 << n):\n    for j in range(n):\n        if ((i >> j) & 1):\n            dp[j][i] = max(dp[j][i], dp[(i ^ (1 << j))][i >> 1] + (potsions[j] == 0))\nfor i in range(2**n):\n    for j in range(n-1):\n        if ((i >> j) & 1):\n            k = (i ^ (1 << j))\n            dp[n-1][k] = max(dp[n-1][k], dp[j][i] + (potsions[n-1] == 0))\n\nprint(max(dp[n-1]))\n```", "time_gen": "\ntime generating: 7.019363s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1376": {"code": "```\nimport sys\nfrom math import gcd\ndef lcm(a, b):\n    return a*b // gcd(a, b)\n\nN = int(input())\ndays = list(map(int, input().split()))\nmax_lcm = 1\nfor i in range(1, N+1):\n    lcm_val = 1\n    for j in range(i):\n        lcm_val = lcm(lcm_val, days[j])\n    for j in range(i, N):\n        lcm_val = lcm(lcm_val, days[j]%lcm_val)\n    max_lcm = lcm(max_lcm, lcm_val)\nprint(sum([k for k in range(1, max_lcm+1) if all((days[i]//k)%j in [0, 1, 2, 3] for i in range(N))]))\n```", "time_gen": "\ntime generating: 5.618367s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1377": {"code": "```\nQ = int(input())\nN = int(input())\n\nroads = []\nfor _ in range(N):\n    direction = input().strip()\n    coord = int(input())\n    roads.append((direction, coord))\n\ncows = []\nfor _ in range(Q):\n    x, y, d = map(int, input().split())\n    cows.append((x, y, d))\n\nfor i in range(Q):\n    x, y, d = cows[i]\n    direction = \"H\" if d % 2 == 1 else \"V\"\n    \n    if direction == \"H\":\n        for _ in range(d):\n            x += 1\n            if (x, y) not in roads:\n                if y + 1 > 10**9 or (x, y+1) in roads:\n                    break\n                y += 1\n    else:\n        for _ in range(d):\n            y += 1\n            if (x, y) not in roads:\n                if x + 1 > 10**9 or (x+1, y) in roads:\n                    break\n                x += 1\n    \n    print(f\"{x} {y}\")\n```", "time_gen": "\ntime generating: 7.841631s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1378": {"code": "```\nN, Q, C = map(int, input().split())\ndp = [0] * (C + 1)\nfor _ in range(Q):\n    a, h = map(int, input().split())\n    dp[a - 1] += 1\n    for i in range(a - 1, h - 1):\n        dp[i] -= 1\nans = 1\nfor x in dp:\n    ans = (ans * (x + 1)) % (10**9 + 7)\nprint(ans)\n```", "time_gen": "\ntime generating: 4.527694s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1379": {"code": "```\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    a = list(map(int, input().split()))\n    t = 0\n    for i in sorted(a):\n        t += i\n    print(t)\n```", "time_gen": "\ntime generating: 3.936651s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1380": {"code": "```\nimport math\n\ndef dfs(graph, p, visited, current):\n    if len(visited) == 0:\n        return 1\n    res = 0\n    for neighbor in graph[current]:\n        if neighbor not in visited:\n            res += (p - (dfs(graph, p, visited + [neighbor], neighbor)) % (10**9 + 7))\n    return res % (10**9 + 7)\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        n, m = map(int, input().split())\n        p = list(map(int, input().split()))\n        graph = [[] for _ in range(n + 1)]\n        for i in range(m):\n            u, v = map(int, input().split())\n            graph[u].append(v)\n            graph[v].append(u)\n\n        res = [0] * (n + 1)\n        visited = []\n        current = 1\n        for _ in range(n):\n            res[current] = dfs(graph, p[current - 1], visited, current)\n            visited = [current]\n            current += 1\n\n        print(' '.join(map(str, res[1:])))\n```", "time_gen": "\ntime generating: 9.827645s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1381": {"code": "```python\nimport math\n\ndef main():\n    N = int(input())\n    sizes = list(map(int, input().split()))\n    probabilities = [0] * N\n    \n    for i in range(N):\n        left = 1\n        right = i - 1\n        for j in range(left, right + 1):\n            if sizes[j] > sizes[i]:\n                left = max(left, j + 1)\n            elif sizes[j] < sizes[i]:\n                right = min(right, j)\n        \n        probability = (right - left + 1) / math.comb(N, 2)\n        probabilities[i] = int((probability * (10**9 + 7)) % (10**9 + 7))\n    \n    for p in probabilities:\n        print(p)\n\nif __name__ == \"__main__\":\n    main()\n```", "time_gen": "\ntime generating: 6.845184s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1382": {"code": "```\ndef solve(n, x):\n    total = 1\n    for i in range(2*n-1):\n        if (i < n):\n            total *= (n - i)\n        else:\n            total *= i - n + 1\n    return pow(total, 2, 10**9+7)\n\nn = int(input())\nx = list(map(int, [input().split() for _ in range(n)]))\nprint(solve(n, x))\n```", "time_gen": "\ntime generating: 4.850216s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1395": {"code": "```python\nT = int(input())\nfor _ in range(T):\n    S = int(input())\n    if str(S) == str(S)[::-1]:\n        print(\"B\")\n    else:\n        print(\"E\")", "time_gen": "\ntime generating: 2.426608s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1396": {"code": "```\nmilk = sum(a for a in map(int, input().split()))\ndirections = list(input())\nbucket_size = [int(a) for a in input().split()]\n\ndef solve():\n    result = 0\n    for _ in range(m):\n        for i in range(n-1):\n            if bucket_size[i] > 0 and bucket_size[i+1] < bucket_size[i]:\n                bucket_size[i+1] += min(bucket_size[i], bucket_size[i+1])\n                bucket_size[i] -= min(bucket_size[i], bucket_size[i+1])\n        for i in range(n-1):\n            if directions[i] == 'R':\n                bucket_size[i] = bucket_size[i] - 1\n                bucket_size[(i+1)%n] = bucket_size[(i+1)%n] + 1\n            else:\n                bucket_size[i] = bucket_size[i] + 1\n                bucket_size[(i-1+n)%n] = bucket_size[(i-1+n)%n] - 1\n    return sum(bucket_size)\n\nprint(solve())\n```", "time_gen": "\ntime generating: 7.741973s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1397": {"code": "```\nN, Q = map(int, input().split())\ncloses = list(map(int, input().split()))\ntimes = list(map(int, input().split()))\n\nfor _ in range(Q):\n    v, s = map(int, input().split())\n    count = 0\n    for i in range(N):\n        if times[i] + s < closes[i]:\n            count += 1\n        else:\n            break\n    print('YES' if count >= v else 'NO')\n```", "time_gen": "\ntime generating: 4.15805s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1398": {"code": "```\nimport sys\n\ndef read_input():\n    T = int(input())\n    for _ in range(T):\n        N, X1 = map(int, input().split())\n        target_coords = []\n        slopes = []\n        for _ in range(N):\n            y1, y2, x2 = map(int, input().split())\n            target_coords.append((y1, y2, x2))\n        for i in range(4*N):\n            slope = int(input())\n            slopes.append(slope)\n        yield N, X1, target_coords, slopes\n\ndef main():\n    min_distance = sys.maxsize\n    for T in read_input():\n        N, X1, targets, slopes = T\n        for i in range(N):\n            y1, y2, x2 = targets[i]\n            for j in range(4):\n                if slopes[4*i+j] > 0:\n                    target_y = y1 + (y2-y1)*(x2-X1)/(x2-X1)\n                else:\n                    target_y = y1 + (y2-y1)*(-X1)/(x2-X1)\n                min_distance = min(min_distance, abs(target_y))\n\n    if min_distance == sys.maxsize:\n        print(-1)\n    else:\n        print(min_distance)\n\nif __name__ == \"__main__\":\n    main()\n```", "time_gen": "\ntime generating: 10.381581s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1399": {"code": "```\ndef pour_tube1_to_3(tube1, tube2):\n    while True:\n        if '1' not in tube1 and '2' in tube2:\n            return 0\n        elif '2' not in tube2 and '1' in tube1:\n            return 0\n\n        if '12' in tube1:\n            tube1 = tube1.replace('12', '')\n            tube3 = '22' + tube3\n            return 1\n        elif '21' in tube2:\n            tube2 = tube2.replace('21', '')\n            tube3 = '11' + tube3\n            return 1\n\n        if len(tube1) < len(tube2):\n            tube1, tube2 = tube2, tube1\n        move_from_tube1_to_tube3(tube1[0], tube3)\n        tube1 = tube1[1:]\n    return -1\n\n\ndef pour_tube2_to_3(tube1, tube2):\n    while True:\n        if '1' not in tube2 and '2' in tube1:\n            return 0\n        elif '2' not in tube1 and '1' in tube2:\n            return 0\n\n        if '21' in tube2:\n            tube2 = tube2.replace('21', '')\n            tube3 = '11' + tube3\n            return 1\n        elif '12' in tube1:\n            tube1 = tube1.replace('12', '')\n            tube3 = '22' + tube3\n            return 1\n\n        if len(tube2) < len(tube1):\n            tube1, tube2 = tube2, tube1\n        move_from_tube2_to_tube3(tube2[0], tube3)\n        tube2 = tube2[1:]\n    return -1\n\n\ndef pour_tube1_to_2(tube1, tube2):\n    while True:\n        if '1' not in tube1 and '2' not in tube2:\n            return 0\n        elif '2' not in tube2 and '1' not in tube1:\n            return 0\n\n        if '12' in tube1:\n            tube1 = tube1.replace('12', '')\n            move_from_tube1_to_tube2(tube1[0], tube2)\n            tube1 = tube1[1:]\n            return 1\n        elif '21' in tube2:\n            tube2 = tube2.replace('21', '')\n            move_from_tube2_to_tube1(tube2[0], tube1)\n            tube2 = tube2[1:]\n            return 1\n\n        if len(tube1) < len(tube2):\n            tube1, tube2 = tube2, tube1\n        move_from_tube1_to_tube2(tube1[0], tube2)\n        tube1 = tube1[1:]\n    return -1\n\n\ndef pour_tube2_to_1(tube1, tube2):\n    while True:\n        if '1' not in tube2 and '2' not in tube1:\n            return 0\n        elif '2' not in tube1 and '1' not in tube2:\n            return 0\n\n        if '21' in tube2:\n            tube2 = tube2.replace('21', '')\n            move_from_tube2_to_tube1(tube2[0], tube1)\n            tube2 = tube2[1:]\n            return 1\n        elif '12' in tube1:\n            tube1 = tube1.replace('12', '')\n            move_from_tube1_to_tube2(tube1[0], tube2)\n            tube1 = tube1[1:]\n            return 1\n\n        if len(tube2) < len(tube1):\n            tube1, tube2 = tube2, tube1\n        move_from_tube2_to_tube1(tube2[0], tube1)\n        tube2 = tube2[1:]\n    return -1\n\n\ndef solve():\n    t = int(input())\n    for _ in range(t):\n        f = input()\n        if f == '1':\n            tube1, tube2 = input().split()\n            print(pour_tube1_to_3(tube1, tube2))\n        elif f == '2':\n            tube1, tube2 = input().split()\n            print(pour_tube2_to_3(tube1, tube2))\n        elif f == '3':\n            tube1, tube2 = input().split()\n            print(pour_tube1_to_2(tube1, tube2))\n        elif f == '4':\n            tube1, tube2 = input().split()\n            print(pour_tube2_to_1(tube1, tube2))\n\n\nif __name__ == '__main__':\n    solve()\n```", "time_gen": "\ntime generating: 29.926827s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1400": {"code": "```\nT = int(input())\nfor _ in range(T):\n    N, M, K = map(int, input().split())\n    moves = []\n    for _ in range(M):\n        a = list(map(int, input().split()))\n        if not moves:\n            even = sum(1 for x in a if x % 2 == 0)\n            odd = len(a) - even\n            if even <= odd:\n                moves.extend(['Even'] * (even + 1))\n                moves.extend(['Odd'] * (odd - 1))\n            else:\n                moves.extend(['Odd'] * (odd + 1))\n                moves.extend(['Even'] * (even - 1))\n        else:\n            prev_even = sum(1 for x in a if x % 2 == 0)\n            prev_odd = len(a) - prev_even\n            even_diff = prev_even - sum(1 for x in moves[-K:] if x == 'Even')\n            odd_diff = prev_odd - K + sum(1 for x in moves[-K:] if x == 'Odd')\n            if even_diff <= odd_diff:\n                moves.extend(['Even'] * (even_diff + 1))\n                moves.extend(['Odd'] * (odd_diff - 1))\n            else:\n                moves.extend(['Odd'] * (odd_diff + 1))\n                moves.extend(['Even'] * (even_diff - 1))\n    if N <= 0:\n        print(-1)\n    else:\n        print(' '.join(moves))\n```", "time_gen": "\ntime generating: 10.658692s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1401": {"code": "```\nN, M, C, R, K = map(int, input().split())\nconnected_destinations = set()\nfor i in range(M):\n    u, v, _ = map(int, input().split())\n    if abs(u - v) <= 2 * R:\n        for j in range(1, C + 1):\n            if abs(j - u) <= R and abs(j - v) <= R:\n                connected_destinations.add(v)\n                break\nprint(len(connected_destinations))\nfor dest in sorted(list(connected_destinations)):\n    print(dest)\n```", "time_gen": "\ntime generating: 5.167321s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1402": {"code": "```\nN = int(input())\na = list(map(int, input().split()))\nfor i in range(N):\n    total = sum(a)\n    for j in range(N):\n        a[j] = min(a[j], (total - 1) // N)\n    print(total)\n```", "time_gen": "\ntime generating: 3.819716s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1403": {"code": "```\ndef simulate_particles(n, positions, speeds):\n    observations = [0] * n\n    for i in range(n):\n        if i % 2 == 0:\n            positions[i] -= speeds[i]\n        else:\n            positions[i] += speeds[i]\n        observations[(positions[i] // 1) + 1] = (positions[i] // 1) + 1\n    return ' '.join(map(str, observations))\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    positions = list(map(int, input().split()))\n    speeds = list(map(int, input().split()))\n    print(simulate_particles(n, positions, speeds))\n```", "time_gen": "\ntime generating: 6.297106s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1404": {"code": "```\nn = int(input())\nfor _ in range(n):\n    m, b = map(int, input().split())\n    e = 0\n    for i in range(1, m+1):\n        a = min(i-1 + (b - i)**0.5 // 3)\n        e = max(e, sum([3**j for j in range(1, a+1)]))\n    print(int(e) % (10**9 + 7))", "time_gen": "\ntime generating: 5.075629s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1405": {"code": "```\n```\n\nHere is a simple Python script that will solve this problem.\n\n```python\nN, K = map(int, input().split())\na = list(map(int, input().split()))\nx = list(map(int, input().split()))\n\nb = [0] * N\nfor i in range(K):\n    b[x[i]] = 1\n\nleft, right = min(a), max(a)\nans = (right - left) * (N - K)\n\nfor i in range(N):\n    if not b[i]:\n        ans += max(left, a[i])\n\nprint(ans)\n```\n\nThis script first reads the input and initializes an array `b` of size `N`. Then it calculates the minimum possible total ugliness. The total ugliness is the sum of `(right - left) * (N - K)` for the tiles that are stuck in place, and the maximum ugliness over every consecutive pair of tiles.", "time_gen": "\ntime generating: 6.218952s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1406": {"code": "```\nN, Q = map(int, input().split())\nT = list(map(int, input().split()))\nfor i in range(N):\n    T[i] = 2 ** (T[i].bit_length() - 1)\n\nqueries = []\nfor _ in range(Q):\n    v, t, delta = map(int, input().split())\n    queries.append((v, t, delta))\n\nans = []\nfor v, t, delta in queries:\n    cur_city = v\n    for _ in range(delta):\n        cur_city = (cur_city + t % T[cur_city - 1]) % N\n    ans.append(cur_city)\n\nprint(*ans, sep='\\n')\n```", "time_gen": "\ntime generating: 6.431767s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1419": {"code": "Here is a Python solution for this problem:\n```\nn, q = map(int, input().split())\nstatement = list(input().strip().split())\n\nfor _ in range(q):\n    l, r = map(int, input().split(1))\n    query_statement = statement[l:r+1]\n    \n    if query_statement[0] == 'true' and len(query_statement) > 1:\n        continue\n    elif len(query_statement) == 2:\n        if query_statement[0] == 'true':\n            print('Y')\n        else:\n            print('N')\n    else:\n        for i in range(len(query_statement)):\n            if query_statement[i] == 'and' or query_statement[i] == 'or':\n                query_statement = query_statement[:i-1] + ['true'] * 2\n                break\n        result = True\n        for keyword in query_statement[1:]:\n            if keyword == 'false':\n                result = False\n                break\n        if result:\n            print('Y')\n        else:\n            print('N')\n```", "time_gen": "\ntime generating: 8.24432s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1420": {"code": "```\ndef distance(cow):\n    x1, y1, x2, y2 = cow\n    if (x2 - x1) ** 2 + (y2 - y1) ** 2 == 0:\n        return abs(x2 - x1) + abs(y2 - y1)\n    else:\n        return max(abs(x2 - x1), abs(y2 - y1))\n\nn, p = map(int, input().split())\ndata = [list(map(int, input().split())) for _ in range(p)]\ncows = [tuple(map(int, input().split())) for _ in range(n)]\n\nfor i in range(n):\n    print(distance(cows[i]))\n```", "time_gen": "\ntime generating: 5.457587s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1421": {"code": "```\ndef reconstruct_p(h, n):\n    p = [i for i in range(1, n+1)]\n    for i in range(len(h)-1):\n        if h[i] < h[-1]:\n            p[0], p[-1] = p[-1], p[0]\n        else:\n            p[-1], p[0] = p[0], p[-1]\n        p.pop()\n    return p\n\nT = int(input())\nfor _ in range(T):\n    n = int(input())\n    h = list(map(int, input().split()))\n    if len(h) == 1 or len(set(h)) != 1:\n        print(-1)\n    else:\n        print(' '.join(map(str, reconstruct_p(h, n))))\n```", "time_gen": "\ntime generating: 6.164219s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1422": {"code": "```\nN, K = map(int, input().split())\nt = list(map(int, input().split()))\nprint(sum(t[:K-1]) + 1)\nprint(''.join('1' if i < K else '0' for i in range(K)))\n```", "time_gen": "\ntime generating: 3.522543s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1423": {"code": "```\nimport numpy as np\nfrom collections import defaultdict\n\ndef main():\n    N, P = map(int, input().split())\n    post_coords = [list(map(int, input().split())) for _ in range(P)]\n    cow_paths = []\n    for _ in range(N):\n        x1, y1, x2, y2 = map(int, input().split())\n        if x1 == x2:\n            start_y = min(y1, y2)\n            end_y = max(y1, y2)\n            cow_paths.append((x1, start_y, end_y))\n        elif y1 == y2:\n            start_x = min(x1, x2)\n            end_x = max(x1, x2)\n            cow_paths.append((start_x, y1, end_x, y2))\n\n    post_touches = defaultdict(int)\n    for path in cow_paths:\n        if path[0] == path[2]:\n            if path[3] > path[1]:\n                post_touches[path[0]] += 1\n            else:\n                post_touches[path[0]] -= 1\n        elif path[1] == path[3]:\n            if path[2] > path[0]:\n                post_touches[path[0]] += 1\n            else:\n                post_touches[path[0]] -= 1\n\n    for i, touch in enumerate(post_touches.values()):\n        print(touch)\n\nif __name__ == \"__main__\":\n    main()\n```", "time_gen": "\ntime generating: 10.424344s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1424": {"code": "```\nimport collections\n\ndef process_input():\n    N = int(input())\n    S = input().upper()\n    return N, S\n\nN, S = process_input()\n\nP = set()\nfor k in range(1, N+1):\n    for l in range(1, min(k+1, N)+1):\n        candidates = set()\n        for i in range(N-k+l):\n            candidate = S[i:i+l]\n            if len(candidate) == l:\n                candidates.add(min(candidates) if candidates else candidate)\n        P.add(len(candidates))\n\nprint(*P, sep='\\n')\n```", "time_gen": "\ntime generating: 5.845082s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1425": {"code": "```\nN, K = map(int, input().split())\ns1, s2 = input(), input()\n\nones = s1.count('1')\nmoves = 0\ni, j = 0, N - 1\nwhile i < j:\n    if (s1[i] == '1' and s2[j] == '0') or (s1[i] == '0' and s2[j] == '1'):\n        moves += abs(i - j)\n        break\n    i += 1\n    j -= 1\n\nfor _ in range(K):\n    if ones > N // 2:\n        while i < j:\n            if s1[i] != s2[j]:\n                moves += abs(i - j) + 1\n                i, j = (j, i) if s1[i] == '0' else (i, j)\n                break\n            i += 1\n            j -= 1\n        ones -= 1\n    else:\n        while i < j:\n            if s2[j] != s1[i]:\n                moves += abs(i - j)\n                i, j = (j, i) if s2[j] == '0' else (i, j)\n                break\n            i += 1\n            j -= 1\n        ones += 1\n\nprint(moves)\n```", "time_gen": "\ntime generating: 8.076124s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1426": {"code": "```\nn = int(input())\noverlaps = []\nfor i in range(n):\n    l, r, k = map(int, input().split())\n    overlaps.append(sum(1 for j in range(i) if l <= r and r >= l + k and l < r - k))\n\nprint(*overlaps, sep='\\n')\n```", "time_gen": "\ntime generating: 3.109336s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1427": {"code": "```python\nimport math\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\ndef split_array(a, b):\n    k = 1\n    while k * (k + 1) // 2 <= n:\n        left_sum_a = sum(a[:k])\n        right_sum_a = sum(a[k:])\n        left_sum_b = sum(b[:k])\n        right_sum_b = sum(b[k:])\n        \n        if left_sum_a / k > right_sum_a / (n - k):\n            return 0\n        if left_sum_b / k <= right_sum_b / (n - k):\n            return k\n        k += 1\n    return 0\n\nprint(split_array(a, b) % (10**9 + 7))", "time_gen": "\ntime generating: 6.136399s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1428": {"code": "```\nimport heapq\nN = int(input())\nidnums = [input() for _ in range(N)]\nheap = []\nfor i, idnum in enumerate(idnums):\n    count = 0\n    for j in range(len(idnum)):\n        new_idnum = idnum[:j] + '1' + idnum[j:]\n        if new_idnum not in idnums:\n            heapq.heappush(heap, (-len(new_idnum), i))\n        else:\n            count += 1\n    if count == N-1:\n        print(-heap[0][0])\n        break\n```", "time_gen": "\ntime generating: 5.664799s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1429": {"code": "```\nN = int(input())\nhaystack = list(map(int, input().split()))\nQ = int(input())\n\nfor _ in range(Q):\n    l, r, x = map(int, input().split())\n    bessie_hay = 0\n    elsie_hay = x\n    for i in range(l-1, r):\n        if haystack[i] > abs(x):\n            if x > 0:\n                bessie_hay += 1\n            else:\n                elsie_hay -= 1\n        elif x > 0:\n            bessie_hay += 1\n        else:\n            elsie_hay += 1\n    print(elsie_hay - bessie_hay)\n```", "time_gen": "\ntime generating: 6.294073s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=1430": {"code": "```\nimport sys\n\nL, R, N, K = map(int, input().split())\na = list(map(int, input().split()))\nrobots = [0]\nfor i in a:\n    if abs(i - robots[-1]) < (L/R) - 1:\n        t = min((i-robots[-1])/(K-1), 1)\n        robots.append(robots[-1] + (i-robots[-1]) * K // L * K + (K-1-t)*K)\n    else:\n        robots.append(i)\n\ntime = 0\nfor i in range(len(robots)-2):\n    time += max((robots[i+1]-robots[i])/K, ((L/R) - 1))\nprint(time)\n```", "time_gen": "\ntime generating: 5.383893s"}}