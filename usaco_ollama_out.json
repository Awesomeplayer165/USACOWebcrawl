{"https://usaco.org/index.php?page=viewproblem2&cpid=84": {"code": "```\npython\nstart_date = \"11/11/2011\"\nstart_time = \"11:11 AM\"\n\nend_date, end_hour, end_minute = map(int, input().split())\n\n# convert start and end times to minutes from midnight\nstart_minutes = (int(start_date.split(\"/\")[0]) * 60 + int(start_date.split(\"/\")[1])) * 24 + int(start_time[:2]) * 60 + int(start_time[3:5])\n\nend_minutes = (12 * 60) + 13 * 60 + int(end_minute)\ntotal_minutes = end_minutes - start_minutes\n\nif total_minutes < 0:\n    print(-1)\nelse:\n    print(total_minutes)\n```", "time_gen": "\ntime generating: 3.946495s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=85": {"code": "```\nfrom collections import defaultdict\n\ndef convert_base(num, base):\n    convert_string = \"0123456789ABC\"\n    if num < base:\n        return convert_string[num]\n    else:\n        return convert_base(num//base, base) + convert_string[num%base]\n\ndef solve():\n    b2, b3 = input().strip(), input().strip()\n    \n    # Find incorrect digits in both bases\n    for i in range(1, len(b2)):\n        if b2[i] != '0' and b2[i-1] == '0':\n            b2i = int(b2, 2)\n            b3i = int(b3, 3)\n            b2n = convert_base(b2i^b3i, 10).lstrip('0')\n            if len(b2n) > 0:\n                return str(int(b2n, 10))\n\n# Run the solver\nprint(solve())\n```", "time_gen": "\ntime generating: 5.13914s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=86": {"code": "```\nimport re\n\nn = int(input())\nnotes = list(map(int, input().split()))\nc = int(input())\nchord = list(map(int, input().split()))\n\npattern = r'\\b' + '|'.join(map(str, chord)) + r'\\b'\nmatch_count = 0\nstart_index = []\n\nfor i in range(len(notes)):\n    if re.fullmatch(pattern, ','.join(map(str, notes[i:i+c]))):\n        match_count += 1\n        start_index.append(i+1)\n\nprint(match_count)\nfor index in sorted(start_index):\n    print(index)", "time_gen": "\ntime generating: 5.135306s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=87": {"code": "Here is the Python code for Problem 4: Cow Beauty Pageant (Bronze Level):\n```\nn, m = map(int, input().split())\nspots = []\nfor _ in range(n):\n    spots.append(list(input()))\n\ndef dfs(i, j):\n    if i < 0 or i >= n or j < 0 or j >= m:\n        return\n    if spots[i][j] == '.':\n        return\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    for direction in directions:\n        new_i, new_j = i + direction[0], j + direction[1]\n        if 0 <= new_i < n and 0 <= new_j < m and spots[new_i][new_j] == 'X':\n            dfs(new_i, new_j)\n\nmin_paints = float('inf')\nfor i in range(n):\n    for j in range(m):\n        if spots[i][j] == 'X':\n            dfs(i, j)\n            paints = 0\n            for k in range(n):\n                for l in range(m):\n                    if spots[k][l] == '.':\n                        paints += 1\n            min_paints = min(min_paints, paints)\n\nprint(min_paints)\n```\nNote: This code uses depth-first search (DFS) to find all the connected 'X' characters and then calculates the minimum number of new 'X' characters needed to merge the two spots into one.", "time_gen": "\ntime generating: 9.51874s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=88": {"code": "Here is the Python solution for the problem:\n```\ndef merge_spots(N, M, grid):\n    # Initialize variables\n    total = 0\n    stack = []\n    \n    # Iterate over each row of the grid\n    for i in range(N):\n        # Add '.' characters to the stack if they are not part of a spot\n        for j in range(M-1):\n            if grid[i][j] == '.' and grid[i][j+1] == '.':\n                stack.append('.')\n        \n        # Check if there is no spot on this row or the current spot ends here\n        if len(stack) % 2 == 0:\n            continue\n        \n        # If there are odd number of spots, it means we have at least one full spot\n        total += len(stack)\n    \n    return total\n\nN, M = map(int, input().split())\ngrid = [input() for _ in range(N)]\nprint(merge_spots(N, M, grid))\n```\nThis code defines a function `merge_spots` that takes the dimensions of the grid and the grid itself as input. It then iterates over each row of the grid, keeping track of non-spot characters (`'.'`) on a stack. When it encounters a spot (i.e., an odd number of characters), it adds the size of the current spot to the total count. Finally, it returns the minimum number of new `'X'`s that must be added to merge three spots into one.", "time_gen": "\ntime generating: 9.551829s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=89": {"code": "Here is the Python solution for the problem:\n```\nn = int(input())\ncows = []\nfor _ in range(n):\n    x, breed = map(int, input().split())\n    cows.append((x, breed))\n\ncow_breeds = set()\nmin_cost = float('inf')\nleft = 0\nright = 0\n\nwhile right < n:\n    while left <= right and cow_breeds & set([cow[1] for cow in cows[left:right+1]]) != set():\n        left += 1\n    if left > right:\n        break\n    min_cost = min(min_cost, right - left + 1)\n    right += 1\n\nprint(min_cost)\n```", "time_gen": "\ntime generating: 5.115627s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=90": {"code": "Here is a Python solution for the problem:\n```markdown\n```\n```python\nn, m = map(int, input().split())\nareas = list(map(int, input().split()))\ncosts = [0] * (n + 1)\nfor i in range(1, n + 1):\n    costs[i] = costs[i - 1] + areas[i - 1]\nres = float('inf')\nleft = 0\nright = m\nwhile left <= right:\n    mid = (left + right) // 2\n    if costs[n] - costs[0] > mid:\n        res = min(res, costs[n] - costs[0] - mid)\n        right = mid - 1\n    else:\n        left = mid + 1\nif m <= costs[0]:\n    print(-1)\nelse:\n    print(res)\n```", "time_gen": "\ntime generating: 6.371908s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=91": {"code": "Here is the Python solution for this problem:\n```\nn, x = map(int, input().split())\nheights = [int(input()) for _ in range(n)]\n\ndef count_subsequences(heights):\n    n = len(heights)\n    left = 0\n    right = 0\n    count = 0\n    total = sum(1 for height in heights if height >= x)\n    \n    while right < n:\n        if heights[right] >= x:\n            total += 1\n        while total > (right - left + 1) // 2 and left <= right:\n            if heights[left] < x:\n                total -= 1\n            left += 1\n        \n        count += right - left + 1\n        right += 1\n    \n    return count\n\nprint(count_subsequences(heights))\n```", "time_gen": "\ntime generating: 6.043829s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=92": {"code": "```\nimport re\n\ndef count_toggles(board):\n    rows = [list(map(int, row)) for row in board]\n    cols = [[row[i] for row in rows] for i in range(9)]\n    subs = [[rows[i//3*3 + j//3][i%3*3+j%3] for j in range(9)] for i in range(81)]\n\n    toggle_rows = []\n    toggle_cols = []\n    toggle_subs = []\n\n    # toggle rows\n    for row in rows:\n        ones = sum(row)\n        if ones % 2 != 0:\n            toggle_rows.append(list(map(lambda x: int(not x), row)))\n\n    # toggle cols\n    for col in cols:\n        ones = sum(col)\n        if ones % 2 != 0:\n            idx = [i for i, row in enumerate(rows) if row == col][0]\n            rows[idx] = list(map(lambda x: int(not x), col))\n\n    # toggle subs\n    for sub in subs:\n        ones = sum(sub)\n        if ones % 2 != 0:\n            for i, row in enumerate(sub):\n                for j, val in enumerate(row):\n                    if val == 1:\n                        rows[i//3*3 + j//3][i%3*3+j%3] = int(not val)\n\n    total_toggles = len(toggle_rows) + len(toggle_cols) + len(toggle_subs)\n    return str(total_toggles)\n\n\nboard = []\nfor _ in range(9):\n    board.append(re.sub('(.{3})', r'\\1 ', input().strip()).split())\n\nprint(count_toggles(board))\n```", "time_gen": "\ntime generating: 10.148525s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=93": {"code": "```\npython\nimport math\n\ndef max_segments():\n    N = int(input())\n    obstacles = []\n    for _ in range(N):\n        x1, y1, x2, y2 = map(int, input().split())\n        if x1 == x2:\n            orientation = 'v'\n            start, end = min(y1, y2), max(y1, y2)\n        else:\n            orientation = 'h'\n            start, end = min(x1, x2), max(x1, x2)\n\n        obstacles.append((orientation, start, end))\n\n    events = []\n    for obstacle in obstacles:\n        if obstacle[0] == 'v':\n            events.append((obstacle[1], 'start'))\n            events.append((obstacle[2], 'end'))\n        else:\n            events.append((obstacle[1], 'start'))\n            events.append((obstacle[2], 'end'))\n\n    events.sort()\n\n    active = 0\n    max_segments = 0\n\n    for event in events:\n        if event[1] == 'start':\n            active += 1\n        else:\n            active -= 1\n        max_segments = max(max_segments, active)\n\n    print(max_segments)\n\n\nif __name__ == '__main__':\n    max_segments()\n```", "time_gen": "\ntime generating: 9.126774s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=94": {"code": "```\n```python\nn = int(input())\ntotal = sum(int(input()) for _ in range(n))\ndiff = total // n\nextra = total % n\n\nmoves = 0\nfor i in range(n):\n    moves += abs(int(input()) - diff)\nif extra > 0:\n    moves += extra\nprint(moves)\n```", "time_gen": "\ntime generating: 3.081702s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=95": {"code": "```\nn = int(input())\nphotos = []\nfor i in range(5):\n    photo = [int(x) for x in input().split()]\n    photos.append(photo)\n\nlast_photo = photos[-1]\noriginal_order = [0] * (n+1)\nfor i in range(n):\n    original_order[last_photo[i]] = i + 1\n\nprint(\"\\n\".join(map(str, original_order[1:])))\n```", "time_gen": "\ntime generating: 4.731848s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=96": {"code": "```\nimport heapq\n\nN = int(input())\nweights = []\nfor _ in range(N):\n    weights.append(int(input()))\n\nheap = []\nfor weight in weights:\n    if len(heap) > 0 and heap[0] + weight <= 10000000: \n        heapq.heappush(heap, weight)\n    else:\n        while len(heap) > 1 and (heap[0] + weight > 10000000 or heap[0] + heap[1] > 10000000):\n            heapq.heappop(heap)\n        heapq.heappush(heap, weight)\n\nprint(len(heap))\n```", "time_gen": "\ntime generating: 4.903615s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=97": {"code": "```\ndef photo():\n    n = int(input())\n    photos = []\n    for _ in range(5):\n        cows = [int(x) for x in input().split()]\n        photos.append(cows)\n        \n    for i in range(len(photos[0])):\n        cows = [x[i] for x in photos]\n        if len(set(cows)) == 1:\n            print(cows[0])\n            return\n```", "time_gen": "\ntime generating: 4.764567s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=98": {"code": "```\nfrom heapq import *\nfrom collections import defaultdict\n\nN, M = map(int, input().split())\ngraph = defaultdict(dict)\nfor _ in range(M):\n    A, B, L = map(int, input().split())\n    graph[A][B] = L\n    graph[B][A] = L\n\nINF = float('inf')\ndp = [INF] * (N + 1)\ndp[0] = 0\nqueue = [(0, 0)]\nwhile queue:\n    dist, node = heappop(queue)\n    if dist > dp[node]:\n        continue\n    for neighbor, length in graph[node].items():\n        new_dist = dp[node] + length\n        if new_dist < dp[neighbor]:\n            dp[neighbor] = new_dist\n            heappush(queue, (new_dist, neighbor))\n\nans = INF\nfor i in range(1, N):\n    ans = min(ans, dp[i])\n\nprint(max(0, dp[N - 1] - ans))\n```", "time_gen": "\ntime generating: 7.712682s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=99": {"code": "```\n```\n\n```\n```", "time_gen": "\ntime generating: 2.117871s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=100": {"code": "```\nimport sys\n\nn = int(sys.stdin.readline())\nfor _ in range(5):\n    photo = [int(line) for line in sys.stdin.readlines(n)]\n    sys.stdin.seek(0)\n    if i == 0:\n        ordering = photo\n    else:\n        for j in range(len(ordering)):\n            if ordering[j] != photo[0]:\n                ordering.insert(0, ordering.pop(j))\n                break\n\nprint(*ordering, sep='\\n')\n```", "time_gen": "\ntime generating: 5.166681s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=101": {"code": "```\nimport heapq\nfrom collections import defaultdict\n\nN, M = map(int, input().split())\nedges = []\nfor _ in range(M):\n    a, b, n = map(int, input().split())\n    edges.append((n, a, b))\n\ngraph = defaultdict(list)\nfor edge in edges:\n    _, a, b = edge\n    graph[a].append(b)\n    graph[b].append(a)\n\nheap = []\nfor node in range(1, N+1):\n    if len(graph[node]) > 0:\n        for neighbor in graph[node]:\n            heapq.heappush(heap, (1, node, neighbor))\n\nparent = [i for i in range(N+1)]\nrank = [0] * (N+1)\n\ndef find(node):\n    if parent[node] != node:\n        parent[node] = find(parent[node])\n    return parent[node]\n\ndef union(a, b):\n    root_a = find(a)\n    root_b = find(b)\n    if root_a != root_b:\n        if rank[root_a] > rank[root_b]:\n            parent[root_b] = root_a\n        else:\n            parent[root_a] = root_b\n            if rank[root_a] == rank[root_b]:\n                rank[root_b] += 1\n\nmst_sum = 0\ncount = 0\n\nwhile heap and len(graph) > 1:\n    length, a, b = heapq.heappop(heap)\n    if find(a) != find(b):\n        mst_sum += length\n        union(a, b)\n        graph[a].remove(b)\n        graph[b].remove(a)\n        for neighbor in graph[a]:\n            if (1, a, neighbor) in edges:\n                heapq.heappush(heap, (1, a, neighbor))\n        for neighbor in graph[b]:\n            if (1, b, neighbor) in edges:\n                heapq.heappush(heap, (1, b, neighbor))\n        count += 1\n\nprint(mst_sum % int(1e9+7), count % int(1e9+7))\n```", "time_gen": "\ntime generating: 13.079675s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=102": {"code": "```\n```python\nn, m = map(int, input().split())\ngraph = [[] for _ in range(n+1)]\nfor i in range(1, n):\n    a, b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n\ndef dfs(node, visited, count):\n    if node not in visited:\n        visited.add(node)\n        count[0] += 1\n        for neighbor in graph[node]:\n            dfs(neighbor, visited, count)\n\ncount = [0]\nvisited = set()\nfor _ in range(m):\n    action, a, b = input().split()\n    a, b = map(int, (a, b))\n    if action == 'P':\n        graph[a].append(b)\n        graph[b].append(a)\n        dfs(a, visited, count)\n        dfs(b, visited, count)\n    elif action == 'Q':\n        print(count[0] - 1)\n\n```\n```", "time_gen": "\ntime generating: 6.884413s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=103": {"code": "Here is the Python code for the problem:\n```\nn, b = map(int, input().split())\np = [int(input()) for _ in range(n)]\ns = [int(input()) for _ in range(n)]\n\ngifts_given = 0\ntotal_cost = 0\n\nfor i in range(n):\n    if p[i] / 2 + s[i] <= b:\n        total_cost += p[i] + s[i]\n        gifts_given += 1\n    elif p[i] + s[i] <= b:\n        total_cost += p[i] + s[i]\n        gifts_given += 1\n\nprint(gifts_given)\n```", "time_gen": "\ntime generating: 5.252585s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=104": {"code": "Here is a Python solution for this problem:\n\n```markdown\n```\n```\nn, k = map(int, input().split())\nstacks = [0] * n\nfor _ in range(k):\n    a, b = map(int, input().split())\n    for i in range(a-1, b):\n        stacks[i] += 1\n\nstacks.sort()\nmedian_height = stacks[n//2]\nprint(median_height)\n```", "time_gen": "\ntime generating: 3.874783s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=105": {"code": "Here is the solution to the problem:\n```\nimport sys\nfrom collections import deque\n\ndef bfs(grid, bessie_start, mildred_start):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n    queue = deque([(bessie_start, mildred_start, 0)])\n    result = []\n    \n    while queue:\n        bessie, mildred, step = queue.popleft()\n        \n        if (bessie, mildred) not in visited and grid[bessie][mildred] == '.':\n            visited.add((bessie, mildred))\n            \n            if bessie == mildred:\n                result.append(step)\n            else:\n                for d in directions:\n                    new_bessie = bessie + d[0]\n                    new_mildred = mildred + d[1]\n                    \n                    if 0 <= new_bessie < len(grid) and 0 <= new_mildred < len(grid[0]) and (new_bessie, new_mildred) not in visited:\n                        queue.append((new_bessie, new_mildred, step + 1))\n    \n    return len(result)\n\nK = int(input())\ngrid = [['.' for _ in range(5)] for _ in range(5)]\nfor _ in range(K):\n    i, j = map(int, input().split())\n    grid[i][j] = 'x'\n\nprint(bfs(grid, 0, 4))\n```", "time_gen": "\ntime generating: 10.520629s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=106": {"code": "```\ndef delivery():\n    N = int(input())\n    farms = []\n    for _ in range(N):\n        x, y = map(int, input().split())\n        farms.append((x, y))\n\n    farms.sort()\n\n    total_time = 0\n    current_position = (farms[1][0], farms[1][1])\n\n    for i in range(2, N):\n        dx = abs(farms[i][0] - current_position[0])\n        dy = abs(farms[i][1] - current_position[1])\n        total_time += max(dx, dy)\n        current_position = (farms[i][0], farms[i][1])\n\n    dx = abs(farms[0][0] - current_position[0])\n    dy = abs(current_position[1] - farms[0][1])\n    total_time += min(dx, dy) + 2\n\n    print(total_time)\n\n\ndelivery()\n```", "time_gen": "\ntime generating: 6.175083s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=107": {"code": "```\n```\n\n```\nn = int(input())\nsizes = list(map(int, input().split() for _ in range(n)))\nsizes.sort(reverse=True)\nb1 = sum(sizes[i:i+3] for i in range(0, n, 3))\nprint(b1)\n```", "time_gen": "\ntime generating: 2.657223s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=108": {"code": "```\n```\n```python\nimport heapq\n\nn = int(input())\npq = []\ntotal_time = 0\n\nfor _ in range(n):\n    u, d = map(int, input().split())\n    pq.append((u, 1))  # (time, direction)\n    pq.append((d, -1))\n\npq.sort()\ncurr_time = 0\nprev_direction = None\n\nwhile pq:\n    time, direction = heapq.heappop(pq)\n\n    if direction == 1:  # climbing up\n        curr_time += time\n        prev_direction = 1\n    else:  # descending down\n        curr_time += time\n        prev_direction = -1\n\n    while pq and pq[0][1] != prev_direction:\n        heapq.heappop(pq)\n\nprint(curr_time)\n```", "time_gen": "\ntime generating: 5.555865s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=109": {"code": "```\ndef read_input():\n    N, K = map(int, input().split())\n    combos = []\n    for _ in range(N):\n        combos.append(input())\n    return N, K, combos\n\ndef solve(N, K, combos):\n    dp = [0] * (K + 1)\n    for combo in combos:\n        i = j = 0\n        while i <= K and j < len(combo):\n            if combo[j] == 'A':\n                while i < K and not any(c == 'A' for c in combos[i][j:j+2]):\n                    dp[i] += 1\n                    i += 1\n            elif combo[j] == 'B':\n                while i < K and not any(c == 'B' for c in combos[i][j:j+2]):\n                    dp[i] += 1\n                    i += 1\n            j += 1\n    return max(dp)\n\nN, K, _ = read_input()\nprint(solve(N, K, []))\n```", "time_gen": "\ntime generating: 6.848256s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=110": {"code": "```\npython\nimport sys\n\nN, M, K = map(int, input().split())\nmoves = list(input())\n\nfor _ in range(N):\n    cards = list(map(int, input().split()))\n    if moves[_] == 'T':\n        print('TB'[cards.index(max(cards)) < (M+K)//2], end='')\n    else:\n        print('BT'[cards.index(min(cards)) >= (M-K)//2], end='')\n```", "time_gen": "\ntime generating: 8.395578s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=111": {"code": "```\npython\ndef alliance(n, m):\n    MOD = 1000000007\n    res = 1\n    for _ in range(m - 2):\n        res = (res * (n - 2)) % MOD\n        n -= 1\n    return res\n```", "time_gen": "\ntime generating: 6.293757s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=112": {"code": "```\ndef count_folding_points(N, L):\n    folding_points = 0\n    for i in range(1, N-1):\n        if (i + 1) % ((L+1)//2) == 0:\n            folding_points += 1\n    return folding_points\n\nN, L = map(int, input().split())\nprint(count_folding_points(N, L))\n```", "time_gen": "\ntime generating: 5.886263s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=113": {"code": "```\n# Problem 2: Overplanting (Bronze)\nN = int(input())\ntotal_area = 0\nfor _ in range(N):\n    x1, y1, x2, y2 = map(int, input().split())\n    total_area += (x2 - x1) * (y2 - y1)\n\nprint(total_area)\n```", "time_gen": "\ntime generating: 4.711732s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=114": {"code": "```\n```python\nN = int(input())\n\ndef get_moo(N):\n    moomoos = \"m o \"\n    moo_length = len(moomoos)\n    result = \"\"\n    \n    while N > 0:\n        if N >= moo_length:\n            result += moomoos\n            N -= moo_length\n        else:\n            result += moomoos[:N]\n            break\n    \n    return \"m\" if result[N-1] == \"m\" else \"o\"\n\nprint(get_moo(N))\n```", "time_gen": "\ntime generating: 8.067201s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=115": {"code": "```\ndef calculate_area():\n    n = int(input())\n    total_area = 0\n    \n    for _ in range(n):\n        x1, y1, x2, y2 = map(int, input().split())\n        \n        # Calculate area of each rectangle\n        area = abs((x2 - x1) * (y2 - y1))\n        \n        # Add to total area\n        total_area += area\n    \n    print(total_area)\n```", "time_gen": "\ntime generating: 6.268461s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=116": {"code": "```\nimport sys\n\nN, K = map(int, sys.stdin.readline().split())\n\ndef generate_cow_ids(K):\n    cow_ids = []\n    for i in range(2**K):\n        id_str = ''\n        count = 0\n        for j in range(K-1, -1, -1):\n            if (i >> j) & 1:\n                id_str += '1'\n                count += 1\n            else:\n                id_str += '0'\n        if count == K and len(id_str) == K:\n            cow_ids.append(int(id_str, 2))\n    return cow_ids\n\ncow_ids = generate_cow_ids(K)\nprint(cow_ids[N-1])\n```", "time_gen": "\ntime generating: 8.477978s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=117": {"code": "Here is the Python code to solve this problem:\n```\nimport sys\nfrom collections import deque\n\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([(start, 0)])\n    min_distance = {i: float('inf') for i in range(1, N+1)}\n    min_distance[start] = 0\n\n    while queue:\n        (node, distance) = queue.popleft()\n        if node not in visited:\n            visited.add(node)\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    queue.append((neighbor, distance + graph[node][neighbor]))\n                    if distance + graph[node][neighbor] < min_distance[neighbor]:\n                        min_distance[neighbor] = distance + graph[node][neighbor]\n\n    return min_distance\n\nN, M, K = map(int, sys.stdin.readline().split())\nmarkets = [int(i) for i in sys.stdin.read().splitlines()[:K]]\nroads = [[*map(int, line.split())] for line in sys.stdin.read().splitlines()[K:]]\ngraph = {i: {} for i in range(1, N+1)}\n\nfor road in roads:\n    graph[road[0]][road[1]] = road[2]\n    graph[road[1]][road[0]] = road[2]\n\nmin_distance = bfs(graph, 0)  # Start at town 1\ntotal_distance = sum(min_distance[i] for i in range(1, N+1) if i not in markets)\nprint(total_distance)\n```\nThis code first reads the input and constructs the graph. Then it uses a breadth-first search (BFS) algorithm to find the minimum distance from each town to all other towns. Finally, it calculates the total minimum distance by summing up the distances for the N-K towns without markets.", "time_gen": "\ntime generating: 22.958478s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=118": {"code": "Here is the Python solution:\n```markdown\n```\n```python\nn, k, m = map(int, input().split())\np = []\nc = []\n\nfor i in range(n):\n    pi, ci = map(int, input().split())\n    p.append(pi)\n    c.append(ci)\n\np.sort(reverse=True)\nc.sort()\n\nans = 0\n\nfor i in range(min(k, n)):\n    if p[i] <= m:\n        ans += 1\n        m -= p[i]\n    else:\n        break\n\nif k > n and m >= min(c):\n    ans += (k - n)\n\nprint(ans)\n```", "time_gen": "\ntime generating: 8.393565s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=119": {"code": "```\nimport itertools\nN = int(input())\npoints = [list(map(int, input().split())) for _ in range(N)]\nlines_of_symmetry = 0\n\nfor p1, p2 in itertools.combinations(range(N), 2):\n    x1, y1 = points[p1]\n    x2, y2 = points[p2]\n    \n    if (x1 == x2 and y1 != y2) or (y1 == y2 and x1 != x2):\n        lines_of_symmetry += 1\n    elif x1 == x2:\n        for p3 in range(N):\n            if p3 != p1 and p3 != p2:\n                x3, y3 = points[p3]\n                if x1 == x3 and y1 + y2 - 2*y3 != 0:\n                    lines_of_symmetry += 1\n                    break\n    elif y1 == y2:\n        for p3 in range(N):\n            if p3 != p1 and p3 != p2:\n                x3, y3 = points[p3]\n                if y1 == y3 and x1 + x2 - 2*x3 != 0:\n                    lines_of_symmetry += 1\n                    break\n\nprint(lines_of_symmetry)\n```", "time_gen": "\ntime generating: 14.278291s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=120": {"code": "```\nimport networkx as nx\nfrom collections import deque\n\nG = nx.Graph()\nN, K = map(int, input().split())\nfor _ in range(N-1):\n    i, j = map(int, input().split())\n    G.add_edge(i, j)\n\nC = [int(input()) for _ in range(N)]\n\ndef dfs(node, visited, max_cows):\n    if node not in visited:\n        visited.add(node)\n        return C[node]\n    else:\n        return 0\n\nM = [0]*N\nfor i in range(1, N):\n    queue = deque([(i, K)])\n    while queue and K > 0:\n        node, trails_left = queue.popleft()\n        if node not in M[i-1]:\n            continue\n        for neighbor in G.neighbors(node):\n            if M[neighbor-1] + C[neighbor] > max_cows[neighbor-1]:\n                max_cows[neighbor-1] = M[neighbor-1] + C[neighbor]\n                queue.append((neighbor, trails_left-1))\n    M[i-1] = max_cows[i-1]\n\nfor i in range(N):\n    print(M[i])\n```", "time_gen": "\ntime generating: 13.918073s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=121": {"code": "Here is the solution:\n```\nn = int(input(), 2)\nresult = bin(n * 17)[2:]\nprint(result.zfill(1000))\n```", "time_gen": "\ntime generating: 2.895366s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=122": {"code": "Here is the Python code for Problem 2: Connect the Cows:\n```\nn = int(input())\nroutes = 0\nfor i in range(1, n):\n    if (i % 4 == 1) or (i % 4 == 3):\n        routes += 1\nprint(routes)\n```", "time_gen": "\ntime generating: 5.283672s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=123": {"code": "```\ndef wrongdir():\n    s = input().strip()\n    n = len(s)\n    x, y = 0, 0\n    for c in s:\n        if c == 'F':\n            y += 1\n        elif c == 'L':\n            x -= 1\n        elif c == 'R':\n            x += 1\n    directions = ['N', 'E', 'S', 'W']\n    dir_index = 0\n    for c in s:\n        if c == 'F':\n            pass\n        elif c == 'L':\n            dir_index = (dir_index + 1) % 4\n        elif c == 'R':\n            dir_index = (dir_index - 1) % 4\n    dir_types = ['N', 'E', 'S', 'W']\n    dir_type_index = 0 if s.count('F') > s.count('L') and s.count('F') > s.count('R') else 1 if s.count('L') > s.count('R') else 2\n    print(len({(x, y), (x-1, y), (x+1, y), (-1*y, -1*x)}))\n\nwrongdir()\n```", "time_gen": "\ntime generating: 13.034008s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=124": {"code": "```\n```\n```python\nfrom collections import deque\n\ndef tractor(start, end, hays):\n    queue = deque([(start, 0)])\n    visited = {start}\n\n    while queue:\n        (x, y), dist = queue.popleft()\n\n        if (x, y) == end:\n            return dist\n\n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) not in visited and 1 <= nx <= 1000 and 1 <= ny <= 1000:\n                for hay in hays:\n                    if (nx, ny) == hay:\n                        break\n                else:\n                    queue.append(((nx, ny), dist + 1))\n                    visited.add((nx, ny))\n\n    return -1\n\nn, x, y = map(int, input().split())\nhays = [map(int, input().split()) for _ in range(n)]\nprint(tractor((x, y), (0, 0), hays))\n```", "time_gen": "\ntime generating: 12.853933s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=125": {"code": "```\nimport sys\n\nN, D = map(int, raw_input().split())\nraindrops = [map(int, line.split()) for line in sys.stdin.readlines()[1:]]\n\nmin_width = float('inf')\n\nfor i in range(N):\n    left = 0\n    right = max(x for x, _ in raindrops)\n    \n    while right - left > D:\n        min_width = min(min_width, right - left)\n        mid = (left + right) / 2\n        count = sum(1 for x, y in raindrops if x <= mid and y <= mid + D)\n        \n        if count < N:\n            right = mid\n        else:\n            left = mid + 1\n\nif min_width == float('inf'):\n    print(-1)\nelse:\n    print(min_width)\n```", "time_gen": "\ntime generating: 9.899122s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=126": {"code": "Here is a Python solution for the problem:\n```\nN, X, Y, Z = map(int, input().split())\nA = [0] * N\nB = [0] * N\nfor i in range(N):\n    A[i], B[i] = map(int, input().split())\n\ndp = [[float('inf')] * (N + 1) for _ in range(N + 1)]\ndp[0][0] = 0\n\nfor i in range(1, N + 1):\n    for j in range(max(i - 1, 0), min(N, i + 2)):\n        dp[i][j] = min(dp[i][j], dp[i-1][k] + X if A[k-1] < B[k-1] else dp[i-1][k] + Y for k in range(1, j+1))\n        dp[i][j] = min(dp[i][j], dp[j-1][k] + Z * abs(i-k) if A[k-1] > B[k-1] else dp[j-1][k] + X if A[k-1] < B[k-1] else dp[j-1][k] + Y for k in range(j+1, N))\n\nprint(dp[-1][-1])\n```", "time_gen": "\ntime generating: 14.481364s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=127": {"code": "```python\ndef solve():\n    m, n, l, h, b = map(int, input().split())\n    count = 0\n    for i in range(m+1):\n        for j in range(n+1):\n            if (i == 0 or j == 0) and (i == m or j == n):\n                continue\n            if l <= abs(i-j) + max(abs(i-m), abs(j-n)) <= h:\n                count += 1\n    print(count % b)\n\nsolve()\n```", "time_gen": "\ntime generating: 8.415319s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=128": {"code": "```\n```python\nn = int(input())\ndiffs = []\nfor i in range(n):\n    a, b = map(int, input().split())\n    diffs.append(abs(a - b))\n\ntotal_work = 0\ni = 0\nwhile len(diffs) > 1:\n    min_diff = min(diffs)\n    for _ in range(min_diff // 2):\n        if i == n - 1:\n            i = 0\n        else:\n            i += 1\n        total_work += min_diff\n        diffs[i % n] -= 2\n    i = (i + 1) % n\n\nprint(total_work)\n```", "time_gen": "\ntime generating: 8.148479s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=129": {"code": "Here is a Python solution for the problem:\n```\ndef skyscraper():\n    N, W = map(int, input().split())\n    cows = list(map(int, [input() for _ in range(N)]))\n\n    rides = 0\n    remaining_weight = W\n    current_cows = []\n\n    for cow in sorted(cows):\n        if cow > remaining_weight:\n            rides += 1\n            remaining_weight = W\n            current_cows = []\n        if sum(current_cows) + cow <= remaining_weight:\n            current_cows.append(cow)\n        else:\n            print(rides + 1)\n            for i in range(len(current_cows)):\n                print(len(current_cows), end=' ')\n                for j in range(len(current_cows)):\n                    if j < i:\n                        print(j, end=' ')\n            return\n\n    print(rides)\n    for i in range(rides):\n        print(len(current_cows[i]), end=' ')\n        for cow in current_cows[i]:\n            print(cow, end=' ')\n        print()\n\nskyscraper()\n```", "time_gen": "\ntime generating: 12.335009s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=130": {"code": "Here is the solution in Python:\n```\nn = int(input())\nbreed_ids = list(map(int, input().split() for _ in range(n)))\nmax_length = 0\ncurrent_length = 1\n\nfor i in range(1, n):\n    if breed_ids[i] == breed_ids[i-1]:\n        current_length += 1\n    else:\n        max_length = max(max_length, current_length)\n        current_length = 1\n\nprint(max_length)\n```", "time_gen": "\ntime generating: 6.232092s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=131": {"code": "```\n# 3lines problem\nimport sys\n\nN = int(input())\ncow_locations = [list(map(int, input().split())) for _ in range(N)]\n\ndef can_monitor_all_cows():\n    # Get all unique x and y coordinates\n    x_coords = set([location[0] for location in cow_locations])\n    y_coords = set([location[1] for location in cow_locations])\n\n    # Check if we have enough lines to cover all cows\n    return len(x_coords) + len(y_coords) >= 3\n\nprint(1 if can_monitor_all_cows() else 0)\n```", "time_gen": "\ntime generating: 7.535953s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=132": {"code": "Here is the Python code for the problem:\n```\nn = int(input())\nislands = []\nwater_level = 0\nmax_islands = 0\n\nfor i in range(n):\n    h = int(input())\n    while water_level <= h:\n        islands.append(h)\n        max_islands = max(max_islands, len(islands))\n        water_level += 1\n    islands.pop()\n\nprint(max_islands + 1)  # add 1 for the last island that will always exist\n```", "time_gen": "\ntime generating: 6.708543s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=133": {"code": "```\n```\n\nThis Python script checks whether three connected shapes can be separated by moving them around. It does this by checking if there is a path from one unit square to another, which means they are not yet separate.\n\n```python\ndef check_unlockable(n1, n2, n3, obj1, obj2, obj3):\n    for i in range(n1):\n        for j in range(n2):\n            for k in range(n3):\n                if all((abs(x1 - x2) + abs(y1 - y2)) <= 1\n                       for x1, y1 in zip(obj1[i], obj1[0])\n                       for x2, y2 in zip(obj2[j], obj2[0])\n                       for x3, y3 in zip(obj3[k], obj3[0])):\n                    return 0\n    return 1\n\nn1, n2, n3 = map(int, input().split())\nobj1 = [list(map(int, input().split())) for _ in range(n1)]\nobj2 = [list(map(int, input().split())) for _ in range(n2)]\nobj3 = [list(map(int, input().split())) for _ in range(n3)]\n\nprint(check_unlockable(n1, n2, n3, obj1, obj2, obj3))\n```", "time_gen": "\ntime generating: 15.422198s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=134": {"code": "```\ndef unlock():\n    N1, N2, N3 = [int(x) for x in input().split()]\n    object1 = []\n    object2 = []\n    object3 = []\n    \n    for _ in range(N1):\n        x, y = map(int, input().split())\n        object1.append((x, y))\n        \n    for _ in range(N2):\n        x, y = map(int, input().split())\n        object2.append((x, y))\n        \n    for _ in range(N3):\n        x, y = map(int, input().split())\n        object3.append((x, y))\n    \n    min_moves = float('inf')\n    \n    def get_manhattan_distance(obj1, obj2):\n        return sum(abs(a - b) for a, b in zip(obj1, obj2))\n    \n    def get_minimum_moves(obj1, obj2, obj3):\n        nonlocal min_moves\n        min_moves = min(min_moves, get_manhattan_distance(obj1[0], obj3[-1]) + \n                         get_manhattan_distance(obj2[0], obj3[0]) + \n                         get_manhattan_distance(obj3[-1], obj2[-1]))\n    \n    def is_separated():\n        for a in object1:\n            if any(abs(a[0] - b) <= 1 and abs(a[1] - b) <= 1 for b in object2 + object3):\n                return False\n        return True\n    \n    if not is_separated():\n        print(-1)\n    else:\n        get_minimum_moves(object1, object2, object3)\n        print(min_moves)\n\nunlock()\n```", "time_gen": "\ntime generating: 18.591598s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=135": {"code": "```\npython\nimport heapq\n\nN, L = map(int, input().split())\nbooks = []\nfor _ in range(N):\n    h, w = map(int, input().split())\n    books.append((-h, -w))\n\nshelves = []\ntotal_height = 0\nfor book in sorted(books):\n    while shelves and shelf_width(shelves[-1]) + book[1] > L:\n        total_height -= shelves.pop()[0]\n    if shelves:\n        height = max(height for _, height in shelves) + book[0]\n    else:\n        height = book[0]\n    shelves.append((height, book[1]))\n    total_height += height\n\nprint(total_height)\n```\n\nThis code reads the input and builds a priority queue of books. Then it iterates over the books, adding them to the shelves one by one. If a shelf is full, it removes the top shelf and adds a new one with the current book. The height of each shelf is updated accordingly.", "time_gen": "\ntime generating: 11.303984s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=136": {"code": "```\nfrom collections import Counter\n\nN, L, C = map(int, input().split())\nspeeds = list(map(int, [input() for _ in range(N)]))\n\nevent_times = [(C*i/L) for i in speeds]\nevent_times.sort()\n\ncount = 0\nlast_event_time = 0\nfor time in event_times:\n    count += (time - last_event_time)\n    last_event_time = time\n\nprint(count + sum(Counter(event_times).values()) - len(event_times))\n```", "time_gen": "\ntime generating: 6.742723s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=137": {"code": "Here is a Python solution for this problem:\n\n```markdown\n```\n```python\nimport sys\n\nn, m, bx, by = map(int, sys.stdin.readline().split())\nfence_posts = []\nfor _ in range(n):\n    x, y = map(int, sys.stdin.readline().split())\n    fence_posts.append((x, y))\n\nrope_segments = []\nfor _ in range(m):\n    x1, y1 = map(int, sys.stdin.readline().split())\n    x2, y2 = map(int, sys.stdin.readline().split())\n    rope_segments.append(((min(x1, x2), min(y1, y2)), (max(x1, x2), max(y1, y2))))\n\ndef intersect(p1, p2):\n    x1, y1 = p1\n    x2, y2 = p2\n    if y1 > y2:\n        return True, False\n    if y1 < y2:\n        return False, True\n    if x1 > x2:\n        return True, True\n    if x1 < x2:\n        return False, False\n    return (x1 <= y1 and x2 >= y2), (x1 >= y1 and x2 <= y2)\n\ndef solve():\n    rope = []\n    for segment in rope_segments:\n        p1, p2 = segment\n        if p1 == p2:\n            continue\n        if intersect(p1, p2):\n            if p1[0] < p2[0]:\n                rope.append(p1)\n                rope.append(p2)\n            else:\n                rope.append(p2)\n                rope.append(p1)\n\n    posts = []\n    for post in fence_posts:\n        found = False\n        for segment in rope:\n            if intersect(post, segment):\n                found = True\n                break\n        if not found:\n            posts.append(post)\n\n    return len(posts) - 1\n\nprint(solve())\n```", "time_gen": "\ntime generating: 21.232557s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=138": {"code": "Here is the Python solution for the problem:\n```\nn, l = map(int, input().split())\nshelf_heights = []\ntotal_width = 0\nfor _ in range(n):\n    h, w = map(int, input().split())\n    if total_width + w > l:\n        shelf_heights.append(h)\n        total_width = w\n    else:\n        total_width += w\nprint(max(shelf_heights) + sum(shelf_heights))\n```", "time_gen": "\ntime generating: 6.606089s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=139": {"code": "```\ndef subsets():\n    n = int(input())\n    total_milk = sum(int(input()) for _ in range(n))\n    balanced_subsets = 0\n    for i in range(2**n):\n        left_milk = sum(int(input()) for j in bin(i)[2:].zfill(n))\n        if left_milk == (total_milk - left_milk):\n            balanced_subsets += 1\n    print(balanced_subsets)\n```\n\nPlease note that this code assumes the input is in the format provided in the problem description.", "time_gen": "\ntime generating: 6.946564s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=187": {"code": "Here is the solution:\n```\nn = int(input())\npairs = 0\nleft = 0\nfor i in range(n):\n    if input()[i] == '(':\n        left += 1\n    elif input()[i] == ')':\n        if left > 0:\n            pairs += 1\n            left -= 1\n\nprint(pairs)\n```", "time_gen": "\ntime generating: 5.305858s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=188": {"code": "Here is the Python code for the problem:\n```markdown\ndef typo(s):\n    count = 0\n    bal = 0\n    for i, c in enumerate(s):\n        if c == '(':\n            bal += 1\n        else:\n            bal -= 1\n        if bal < 0:\n            count += 1\n    return count\n```\nYou can run this code with the input string `()(())))` to get the output `4`.", "time_gen": "\ntime generating: 6.397023s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=189": {"code": "```\ndef hshoe(n):\n    grid = [list(input().strip()) for _ in range(n)]\n    \n    def dfs(i, j, count):\n        if i < 0 or i >= n or j < 0 or j >= n:\n            return 0\n        \n        val = 1 if grid[i][j] == '(' else -1\n        new_count = count + val\n        \n        if new_count > 0:\n            return dfs(i, j+1, new_count) + 1\n        elif new_count < 0:\n            return dfs(i+1, j, new_count) + 1\n        else:\n            return val\n    \n    max_len = 0\n    \n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == '(':\n                count = dfs(i, j, 1)\n                if count > 0:\n                    max_len = max(max_len, count*2)\n    \n    return max_len\n\nn = int(input())\nprint(hshoe(n))\n```", "time_gen": "\ntime generating: 11.958433s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=190": {"code": "Here is a Python solution for the problem:\n```\ndef clumsy(s):\n    stack = []\n    toggles = 0\n    for c in s:\n        if c == '(':\n            stack.append(c)\n        else:\n            if not stack or stack.pop() != '(':\n                toggles += 1\n    return toggles + len(stack)\n\nif __name__ == '__main__':\n    with open('clumsy.in', 'r') as f:\n        s = f.readline().strip()\n    print(clumsy(s))\n```\nThis code uses a stack to keep track of the opening parentheses. For each closing parenthesis, it checks if the stack is empty or the top element is not an opening parenthesis. If either condition is true, it increments the `toggles` counter. Finally, it adds the number of remaining opening parentheses in the stack to the `toggles` count and returns the result.", "time_gen": "\ntime generating: 9.495335s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=191": {"code": "Here is the Python solution for the problem:\n```\nA, B = map(int, input().split())\nN = int(input())\n\ngrid = [list(input()) for _ in range(N)]\n\ndef dfs(i, j):\n    if i < 0 or i >= N or j < 0 or j >= N:\n        return float('inf')\n    if grid[i][j] == '(':\n        return B\n    left = dfs(i - 1, j)\n    right = dfs(i + 1, j)\n    up = dfs(i, j - 1)\n    down = dfs(i, j + 1)\n    return min(left, right, up, down) + A\n\nprint(dfs(0, 0))\n```", "time_gen": "\ntime generating: 8.734847s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=192": {"code": "Here is the Python code for the problem:\n```\nn = int(input())\ndp = [[0, 0] for _ in range(n + 1)]\n\nfor i in range(1, n + 1):\n    if input()[0] == '(':\n        dp[i][0] = dp[i - 1][0] + 1\n        dp[i][1] = dp[i - 1][1]\n    else:\n        dp[i][0] = dp[i - 1][0]\n        dp[i][1] = dp[i - 1][1] + 1\n\nans = (dp[n][0] * (dp[n][1] + 1)) % 2012\nprint(ans)\n```", "time_gen": "\ntime generating: 9.305568s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=193": {"code": "Here is the Python code to solve the problem:\n```\nn = int(input())\nans = 0\nfor i in range(n // 2 + 1):\n    for j in range(i, n - i):\n        if (i == 0 and j == 0) or (j == 0 and i == j) or ((i > 0) and (j < n - i) and (str.count(input(), '(') - str.count(input(), ')') == i)) and ((i > 0) and (j < n - i) and (str.count(input().rjust(n-j), '(') - str.count(input().rjust(n-j), ')') == i)):\n            ans += 1\nprint(ans % 2012)\n```", "time_gen": "\ntime generating: 9.6031s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=194": {"code": "Here is the solution in Python:\n```\nn, k = map(int, input().split())\ns = [input() for _ in range(k)]\nans = 0\nfor i in range(1, n):\n    if all(s[j][i:].count('(') >= s[j][i:].count(')') for j in range(k)):\n        ans += 1\n\nprint(ans)\n```", "time_gen": "\ntime generating: 6.543783s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=195": {"code": "```\ndef btree(n, edges, labels):\n    tree = [0] * (n + 1)\n    for p in range(2, n + 1):\n        parent = int(edges[p - 1])\n        if parent > 0:\n            tree[parent] += 1\n    max_depth = 0\n    stack = [(i, 0) for i in range(1, n + 1)]\n    while stack:\n        node, depth = stack.pop()\n        max_depth = max(max_depth, depth)\n        if tree[node]:\n            for child in range(tree[node]):\n                stack.append((tree.index(labels), depth + 1))\n    return max_depth\n```", "time_gen": "\ntime generating: 10.045713s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=205": {"code": "```\ndef greet(bessie_movements, elsie_movements):\n    bessie_position = 0\n    elsie_position = 0\n    total_moos = 0\n    \n    for i in range(len(bessie_movements)):\n        if bessie_movements[i][1] == \"L\":\n            bessie_position -= bessie_movements[i][0]\n        else:\n            bessie_position += bessie_movements[i][0]\n        \n        for j in range(len(elsie_movements)):\n            if elsie_movements[j][1] == \"L\":\n                elsie_position -= elsie_movements[j][0]\n            else:\n                elsie_position += elsie_movements[j][0]\n            \n            if abs(bessie_position - elsie_position) <= 1:\n                total_moos += 1\n    \n    return total_moos\n\nb, e = map(int, input().split())\nbessie_movements = [list(map(int, input().split())) for _ in range(b)]\nelsie_movements = [list(map(int, input().split())) for _ in range(e)]\n\nprint(greet(bessie_movements, elsie_movements))\n```", "time_gen": "\ntime generating: 13.882517s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=206": {"code": "```\nn = int(input())\nans = []\nfor _ in range(n):\n    s = input()\n    sorted_s = \"\".join(sorted(s))\n    start, end = 1, n\n    for c in sorted_s:\n        i = 0\n        while True:\n            if s[i] == c:\n                if i + 1 < len(s) and s[i+1] < c:\n                    start = max(start, i + 2)\n                else:\n                    end = min(end, i + 1)\n                break\n            i += 1\n    ans.append((start, end))\nprint(*ans, sep='\\n')\n```", "time_gen": "\ntime generating: 7.895282s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=207": {"code": "Here is the Python code for this problem:\n```\nimport heapq\nfrom collections import defaultdict\n\ndef crazy():\n    N, C = map(int, input().split())\n    fences = []\n    cows = []\n    for _ in range(N):\n        x1, y1, x2, y2 = map(int, input().split())\n        if x1 == x2:\n            fences.append(((x1, min(y1, y2)), (x1, max(y1, y2))) for y in range(min(y1, y2), max(y1, y2) + 1))\n        else:\n            fences.append(((min(x1, x2), y1), (max(x1, x2), y1)) for x in range(min(x1, x2), max(x1, x2) + 1))\n    for _ in range(C):\n        x, y = map(int, input().split())\n        cows.append((x, y))\n\n    communities = defaultdict(set)\n    for cow in cows:\n        community = None\n        heap = [(0, (cow[0], cow[1]))]\n        while heap and not community:\n            dist, pos = heapq.heappop(heap)\n            if any(0 <= x - p_x <= 1e-6 and 0 <= y - p_y <= 1e-6 for p_x, p_y in fences):\n                continue\n            community = {pos}\n            for fence in fences:\n                for p in fence:\n                    if abs(pos[0] - p[0]) + abs(pos[1] - p[1]) < dist:\n                        break\n                else:\n                    heap.append((dist + 1, p))\n        communities[community].add(tuple(cow))\n\n    max_community = max(communities.values(), key=len)\n    return len(max_community)\n\nprint(crazy())\n```", "time_gen": "\ntime generating: 19.536499s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=208": {"code": "```\ndef find_largest_community():\n    n, c = map(int, input().split())\n    \n    fences = []\n    for _ in range(n):\n        x1, y1, x2, y2 = map(int, input().split())\n        fences.append((x1, y1, x2, y2))\n    \n    cows = []\n    for _ in range(c):\n        x, y = map(int, input().split())\n        cows.append((x, y))\n    \n    largest_community = 0\n    \n    for i in range(len(cows)):\n        visited = [False] * len(cows)\n        visited[i] = True\n        stack = [(cows[i][0], cows[i][1])]\n        while stack:\n            x, y = stack.pop()\n            for j, (x2, y2) in enumerate(fences):\n                if x == x2 or y == y2:\n                    x3, y3 = ((x1 + x2) // 2, (y1 + y2) // 2) if x == x2 else ((x1 + x) // 2, (y1 + y) // 2)\n                    for k in range(len(cows)):\n                        if cows[k][0] == x3 and cows[k][1] == y3:\n                            visited[k] = True\n                            stack.append((cows[k][0], cows[k][1]))\n        largest_community = max(largest_community, sum(visited))\n\n    print(largest_community)\n```", "time_gen": "\ntime generating: 16.26199s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=209": {"code": "Here is the Python code for the problem:\n```\nA, B = map(int, input().split())\ncows = list(map(int, [input() for _ in range(N)]))\ncow_positions = sorted(cows)\nmin_cost = float('inf')\nfor i in range(1, len(cow_positions)):\n    r = (cow_positions[i] - cow_positions[i-1]) / 2\n    cost = A + B * r\n    if cost < min_cost:\n        min_cost = cost\n\nprint(min_cost)\n```\nNote that this code assumes the input is in the format specified in the problem statement, with three integers on the first line (`N`, `A`, and `B`), followed by `N` lines each containing an integer representing a cow's position.", "time_gen": "\ntime generating: 9.396125s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=210": {"code": "```\nimport heapq\nn, m, x = map(int, input().split())\npipes = []\nfor _ in range(m):\n    i, j, l, c = map(int, input().split())\n    pipes.append((l, 1/c, (i, j)))\n\nheap = [(0, float('inf'), (1, n))] # (latency, capacity, path)\nwhile heap:\n    latency, capacity, path = heapq.heappop(heap)\n    if path[0] == n:  # reached the tank\n        x -= capacity * (path[1] - 1)\n        if x <= 0:\n            print(latency + sum(1/c for l, c, _ in pipes))\n            break\n    for i, j, l, c in pipes:\n        if path[1] == i or path[1] == j:  # only consider adjacent pipes\n            new_capacity = min(capacity * (path[1] - i) / l, capacity)\n            heapq.heappush(heap, (latency + l, new_capacity, (i, j)))\n```", "time_gen": "\ntime generating: 13.761137s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=211": {"code": "Here is the Python solution:\n```markdown\n```\n```python\nimport sys\n\ndef read_input():\n    n, m = map(int, input().split())\n    gangs = [0] * (m + 1)\n    for i in range(1, m + 1):\n        gangs[i] = int(input())\n    return n, m, gangs\n\ndef solve(n, m, gangs):\n    total_cows = sum(gangs)\n    bessie_gang = gangs[1]\n    max_bessie_on_field = min(bessie_gang, (n + 1) // 2)\n    if max_bessie_on_field == 0:\n        return \"NO\\n0\"\n    else:\n        return \"YES\\n\" + str(max_bessie_on_field) + \"\\n\"\n        for i in range(1, n + 1):\n            gang = min(range(1, m + 1), key=lambda x: gangs[x])\n            if bessie_gang <= i // 2:\n                print(1)\n            else:\n                print(gang)\n\nif __name__ == \"__main__\":\n    n, m, gangs = read_input()\n    solve(n, m, gangs)\n```\nPlease note that this code assumes that the input is correct and does not include any error handling.", "time_gen": "\ntime generating: 16.140063s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=212": {"code": "```\nimport fileinput\n\ndef get_first_strings(filename):\n    with open(filename, 'r') as f:\n        n = int(f.readline())\n        first_strings = []\n        for _ in range(n):\n            s = f.readline().strip()\n            is_first = True\n            for t in first_strings:\n                if t < s and can_be_before(t, s):\n                    is_first = False\n                    break\n            if is_first:\n                first_strings.append(s)\n    return len(first_strings), first_strings\n\ndef can_be_before(s1, s2):\n    for c1, c2 in zip(s1, s2):\n        if c1 < c2:\n            return True\n        elif c1 > c2:\n            return False\n    return len(s1) < len(s2)\n\n_, first_strings = get_first_strings('first.in')\nprint(len(first_strings))\nfor s in first_strings:\n    print(s)\n```", "time_gen": "\ntime generating: 10.637027s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=213": {"code": "```\ndef runaway(N, L):\n    graph = {}\n    for i in range(1, N+1):\n        graph[i] = []\n        for j in range(i-1, 0, -1):\n            if (i-j) <= L:\n                graph[i].append(j)\n                break\n    count = [0]*(N+1)\n    for i in range(N, 0, -1):\n        for to in graph[i]:\n            count[to] += 1\n    return ' '.join(map(str, count[1:]))\n\n\nN, L = map(int, input().split())\nprint(runaway(N, L))\n```", "time_gen": "\ntime generating: 8.311524s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=223": {"code": "Here is the Python solution for the problem:\n```\nimport math\n\ndef orientation(x, y):\n    if x == 0 and y > 0:\n        return '/'\n    elif x == 0 and y < 0:\n        return '\\'\n    else:\n        return '/' if math.atan2(y, -x) > math.pi / 4 else '\\\\'\n\ndef can_see(a, b, fences):\n    for i in range(len(fences)):\n        x, y = int(fences[i].split()[0]), int(fences[i].split()[1])\n        orientation_ = fences[i].split()[-1]\n        if (a >= x and a <= x + 1) or (b >= y and b <= y + 1):\n            if orientation_ == '/':\n                return False\n            else:\n                a = min(a, x + 1)\n                b = min(b, y + 1)\n    return True\n\nn, a, b = map(int, input().split())\nfences = [input() for _ in range(n)]\nfor i in range(n):\n    x, y, direction = int(fences[i].split()[0]), int(fences[i].split()[1]), fences[i].split()[-1]\n    if can_see(a, b, fences[:i+1]):\n        print(i)\n        break\nelse:\n    print(-1)\n```", "time_gen": "\ntime generating: 17.088728s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=224": {"code": "```\n```python\npaint_moves = []\nfor _ in range(int(input())):\n    direction, distance = input().split()\n    distance = int(distance)\n    if direction == 'L':\n        paint_moves.append(-distance)\n    else:\n        paint_moves.append(distance)\n\ncurrent_position = 0\nprevious_positions = set()\n\npainted_area = 0\n\nfor move in paint_moves:\n    current_position += move\n    previous_positions.add(current_position)\n    if len(previous_positions) > 1:\n        painted_area += abs(min(previous_positions)) + abs(max(previous_positions))\n\nprint(painted_area)\n```", "time_gen": "\ntime generating: 7.611887s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=225": {"code": "Here is the Python code for Problem 3:\n```\nn, m = map(int, input().split())\ntruthful_cows = set()\nliars = set()\n\nfor _ in range(m):\n    x, y, t = input().split()\n    x, y = int(x), int(y)\n    \n    if t == 'T':\n        truthful_cows.add(y)\n    else:\n        liars.add(y)\n\nmax_a = 0\nfor i in range(n):\n    for j in range(i+1, n):\n        if (i in truthful_cows and j not in truthful_cows) or (i not in truthful_cows and j in truthful_cows):\n            max_a += 1\n            break\n\nprint(max_a)\n```", "time_gen": "\ntime generating: 9.250247s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=226": {"code": "```\n```\n\n```python\ndef solve():\n    N, K = map(int, input().split())\n    moves = [list(map(int, input().split())) for _ in range(N)]\n    \n    intervals = []\n    for move in moves:\n        if move[0] > 0:\n            intervals.append((move[1], 'R'))\n        else:\n            intervals.append((-move[1], 'L'))\n\n    intervals.sort()\n    painted = set()\n\n    for i in range(len(intervals) - 1):\n        start, dir = intervals[i]\n        end, _ = intervals[i + 1]\n\n        if dir == 'R' and end < start:\n            continue\n\n        segment = (min(start, 0), max(end, 0))\n        if segment[0] <= 0 and segment[1] >= 0:\n            painted.add(segment)\n        elif segment[0] > 0:\n            for p in list(painted):\n                if p[1] < segment[0]:\n                    painted.remove(p)\n\n    area = sum((p[1] - p[0]) for p in painted) + 1\n    print(min(area, K * (K - 1)))\n\nif __name__ == \"__main__\":\n    solve()\n```\n**Problem**: Painting the Fence", "time_gen": "\ntime generating: 13.744201s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=227": {"code": "```\ndef find_overlap_area(pastures):\n    overlaps = set()\n    for i in range(len(pastures)):\n        for j in range(i+1, len(pastures)):\n            x1, y1 = pastures[i]\n            x2, y2 = pastures[j]\n\n            if abs(x1-x2) > K or abs(y1-y2) > K:\n                continue\n\n            overlap_area = 0\n            for dx in range(-K, K+1):\n                for dy in range(-K, K+1):\n                    x = x1 + dx\n                    y = y1 + dy\n\n                    if (x-K)**2 + (y-K)**2 <= K**2:\n                        if min(x1-K, x2-K) <= x <= max(x1-K, x2-K) and min(y1-K, y2-K) <= y <= max(y1-K, y2-K):\n                            overlap_area += 1\n\n            if overlap_area > 0:\n                overlaps.add((i, j))\n    return -1 if len(overlaps) > 1 else sum(((K- abs(x1-x2)) * (K-abs(y1-y2))) for x1, y1 in pastures for x2, y2 in pastures if (x1, y1) in overlaps and (x2, y2) in overlaps)\n```", "time_gen": "\ntime generating: 14.474197s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=228": {"code": "Here is the Python code for the problem:\n```\nimport heapq\n\nN, G = map(int, input().split())\ninvited = set([1])\npq = [(G, 0)]  # priority queue (group size, group index)\n\nwhile pq:\n    g, i = heapq.heappop(pq)\n    while i < len(groups[i]):\n        x = groups[i].pop()\n        if x not in invited:\n            invited.add(x)\n            for j in range(len(groups)):\n                if set(groups[j]).issubset(set([x])):\n                    s = len(groups.pop(j))\n                    heapq.heappush(pq, (s, j))\n            break\n    if i == G - 1:\n        break\n\nprint(len(invited) - 1)\n```", "time_gen": "\ntime generating: 9.434334s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=229": {"code": "```\ndef solve(N, K):\n    seen = set()\n    max_length = 0\n    current_length = 1\n    for i in range(1, N+1):\n        breed_id = int(input())\n        if breed_id not in seen:\n            seen.add(breed_id)\n            if current_length > max_length:\n                max_length = current_length\n            current_length = 1\n        else:\n            current_length += 1\n\n    if K == 0:\n        return N\n\n    to_remove = set()\n    for i in range(1, N+1):\n        breed_id = int(input())\n        if breed_id not in seen:\n            continue\n        seen.add(breed_id)\n        if breed_id not in to_remove:\n            to_remove.add(breed_id)\n            current_length -= 1\n        else:\n            if current_length > max_length:\n                max_length = current_length\n            current_length = 1\n\n    return max(max_length, N - len(to_remove))\n\nN, K = map(int, input().split())\nprint(solve(N, K))\n```", "time_gen": "\ntime generating: 11.76379s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=230": {"code": "```\ndef find_distance(grid):\n    R, C = len(grid), len(grid[0])\n    visited = [[False]*C for _ in range(R)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = []\n    min_distance = float('inf')\n\n    def dfs(x, y):\n        if visited[x][y]:\n            return\n        visited[x][y] = True\n        for dx, dy in directions:\n            nx, ny = x+dx, y+dy\n            if (0 <= nx < R and 0 <= ny < C and \n                grid[nx][ny] == 'X' and not visited[nx][ny]):\n                queue.append((nx, ny))\n        return len(queue)\n\n    for r in range(R):\n        for c in range(C):\n            if grid[r][c] == 'X':\n                min_distance = min(min_distance, dfs(r, c))\n\n    return min_distance\n\nR, C = map(int, input().split())\ngrid = [list(input()) for _ in range(R)]\nprint(find_distance(grid))\n```", "time_gen": "\ntime generating: 13.192462s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=231": {"code": "```\ndef seating():\n    N, M = map(int, input().split())\n    seats = [0] * (N + 1)\n    turned_away = 0\n    \n    for _ in range(M):\n        event = input()\n        \n        if 'A' in event:\n            p = int(event.split()[1])\n            \n            if sum(seats[i:i+p]) > 0 or i + p > N:\n                turned_away += 1\n            else:\n                seats[i:i+p] = [p] * p\n                \n        elif 'L' in event:\n            a, b = map(int, event.split()[1:])\n            \n            for i in range(a-1, b):\n                seats[i] = 0\n                \n    print(turned_away)\n```", "time_gen": "\ntime generating: 9.102961s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=241": {"code": "```\ndef count_non_loopy_cows():\n    N = int(input())\n    F = [0] * (N + 1)\n    for i in range(1, N + 1):\n        F[i] = int(input())\n\n    visited = [False] * (N + 1)\n\n    def dfs(i):\n        if visited[i]:\n            return False\n        visited[i] = True\n\n        next_i = F[i]\n        while next_i != i and not visited[next_i]:\n            next_i = F[next_i]\n        if next_i == i:\n            return True\n        return False\n\n    count = 0\n    for i in range(1, N + 1):\n        if dfs(i):\n            count += 1\n\n    print(count)\n\ncount_non_loopy_cows()\n```", "time_gen": "\ntime generating: 9.10355s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=242": {"code": "```\ndef cow_crossings():\n    n = int(input())\n    intersections = 0\n    for _ in range(n):\n        a, b = map(int, input().split())\n        if a > b:\n            a, b = b, a\n        intersections += len([i for i in range(a+1, b) if (i*(i+1))%2==0])\n    print(n-intersections)\n\ncow_crossings()\n```", "time_gen": "\ntime generating: 5.933575s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=243": {"code": "Here is the Python code for the problem:\n```\nimport sys\n\ndef perimeter(hay_bales):\n    max_x = max(x for x, _ in hay_bales)\n    min_x = min(x for x, _ in hay_bales)\n    max_y = max(y for _, y in hay_bales)\n    min_y = min(y for _, y in hay_bales)\n\n    perimeter = 2 * (max_x - min_x + max_y - min_y)\n\n    return perimeter\n\nif __name__ == \"__main__\":\n    N = int(sys.stdin.readline())\n    hay_bales = []\n    for _ in range(N):\n        x, y = map(int, sys.stdin.readline().split())\n        hay_bales.append((x, y))\n\n    print(perimeter(hay_bales))\n```", "time_gen": "\ntime generating: 9.414731s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=244": {"code": "Here is the Python code for the problem:\n```\nfrom collections import deque\n\ndef perimeter(hay_bales):\n    # Find all connected bales\n    visited = set()\n    queue = deque([(x, y) for x, y in hay_bales])\n    while queue:\n        x, y = queue.popleft()\n        if (x, y) not in visited:\n            visited.add((x, y))\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if (nx, ny) in hay_bales and (nx, ny) not in visited:\n                    queue.append((nx, ny))\n\n    # Find the perimeter\n    max_x = max(x for x, _ in hay_bales)\n    min_x = min(x for x, _ in hay_bales)\n    max_y = max(y for _, y in hay_bales)\n    min_y = min(y for _, y in hay_bales)\n\n    return 2 * ((max_x - min_x) + (max_y - min_y))\n\n# Read the input\nN = int(input())\nhay_bales = []\nfor _ in range(N):\n    x, y = map(int, input().split())\n    hay_bales.append((x, y))\n\nprint(perimeter(hay_bales))\n```\nThis code uses a breadth-first search (BFS) algorithm to find all connected bales, and then calculates the perimeter by finding the minimum and maximum coordinates of the bales.", "time_gen": "\ntime generating: 16.678748s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=245": {"code": "```python\nimport sys\nfrom collections import deque\n\ndef bfs(grid, start):\n    visited = [[False] * len(grid[0]) for _ in range(len(grid))]\n    queue = deque([(start, 0)])\n    max_height_diff = 0\n\n    while queue:\n        (x, y), height_diff = queue.popleft()\n        if visited[x][y]:\n            continue\n        visited[x][y] = True\n\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and\n                    not visited[nx][ny] and abs(grid[nx][ny] - grid[x][y]) <= height_diff):\n                queue.append(((nx, ny), height_diff))\n                max_height_diff = max(max_height_diff, abs(grid[nx][ny] - grid[x][y]))\n\n    return max_height_diff\n\n\ndef solve():\n    N = int(input())\n    elevations = [list(map(int, input().split())) for _ in range(N)]\n    total_cells = N * N\n    visited_cells = sum(1 for row in elevations if any(cell > 0 for cell in row))\n\n    half_visited_cells = (visited_cells + 1) // 2\n    remaining_cells = total_cells - visited_cells\n\n    min_cost = float('inf')\n\n    for _ in range(N):\n        start = (0, 0)\n        while True:\n            height_diff = bfs(elevations, start)\n            if len(list(filter(lambda x: abs(x[1] - elevations[x[0]][x[2]]) <= height_diff, enumerate(elevations)))) >= half_visited_cells + remaining_cells // 2:\n                min_cost = min(min_cost, height_diff)\n                break\n            start = (min(i for i in range(N) if any(abs(elevations[i][j] - elevations[x[0]][x[2]]) <= height_diff for j in range(len(elevations[0])))), 0)\n\n    print(min_cost)\n\n\nif __name__ == \"__main__\":\n    solve()\n```", "time_gen": "\ntime generating: 22.754318s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=246": {"code": "```\ndef milk_scheduling():\n    N, M = [int(x) for x in input().split()]\n    times = list(map(int, input().split()))\n    constraints = []\n    for _ in range(M):\n        A, B = map(int, input().split())\n        constraints.append((A - 1, B - 1))\n\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    for i in range(1, N + 1):\n        dp[i][i] = times[i - 1]\n\n    for A, B in constraints:\n        for i in range(A, B):\n            dp[A][B] = max(dp[A][i], dp[i][B])\n\n    return sum(max(dp[i][j] for j in range(i + 1, N + 1)) for i in range(N))\n\nprint(milk_scheduling())\n```", "time_gen": "\ntime generating: 10.689404s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=247": {"code": "```\nimport heapq\n\ndef partition(n, k, pastures):\n    # Initialize a priority queue to store the number of cows\n    pq = [(pasture[0], 1) for pasture in pastures]\n    heapq.heapify(pq)\n\n    while k > 0:\n        # Extract the largest group from the priority queue\n        total_cows, group_size = heapq.heappop(pq)\n        if group_size * (n - 1) + total_cows > n ** 2 / 4:  # Check if it's possible to split the group into two groups\n            new_group_size = (group_size * (n - 1) + total_cows) // (n - 1)\n            heapq.heappush(pq, (new_group_size * (n - 1), new_group_size))\n        k -= 1\n\n    # The maximum possible size of the largest group is stored in the priority queue\n    return -heapq.heappop(pq)[0] + 1\n\n\n# Read input\nwith open(\"partition.in\", \"r\") as f:\n    n, k = map(int, f.readline().split())\n    pastures = [list(map(int, line.split())) for line in f.readlines()]\n\nprint(partition(n, k, pastures))\n```", "time_gen": "\ntime generating: 13.339201s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=248": {"code": "Here is the Python solution for Problem 2: Taxi:\n```\nM, N = map(int, input().split())\nstart_pos = [0] * N\nend_pos = [0] * N\n\nfor i in range(N):\n    start_pos[i], end_pos[i] = map(int, input().split())\n\npos = list(range(M))\npos.sort()\n\ntotal_distance = 0\ncurrent_pos = 0\n\nfor i in range(N):\n    while current_pos < start_pos[i]:\n        total_distance += pos[0]\n        current_pos = pos[0]\n    while current_pos > end_pos[i]:\n        total_distance -= pos[-1]\n        current_pos = pos[-1]\n    total_distance += abs(start_pos[i] - end_pos[i])\n\nprint(total_distance)\n```", "time_gen": "\ntime generating: 9.612112s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=249": {"code": "```\n```\n\n```python\nfrom heapq import *\n\ndef read_data():\n    n, m, r = map(int, input().split())\n    left_sites = [int(input()) for _ in range(n)]\n    right_sites = [int(input()) for _ in range(m)]\n    routes = []\n    for _ in range(r):\n        i, j = map(int, input().split())\n        routes.append((i-1, j-1))  # subtract 1 because indexing starts at 0\n    return left_sites, right_sites, routes\n\ndef solve():\n    left_sites, right_sites, routes = read_data()\n    graph = [[] for _ in range(len(left_sites) + len(right_sites))]\n    for i, j in routes:\n        graph[i].append((j, -left_sites[i]))  # negative because we want to minimize\n        graph[j+len(left_sites)].append((i, left_sites[i]))\n    dp = [float('inf')] * (len(left_sites) + len(right_sites))\n    dp[0] = 0\n    pq = [(0, 0)]  # priority queue\n    while pq:\n        val, node = heappop(pq)\n        for neighbor, edge_val in graph[node]:\n            new_val = val + edge_val\n            if new_val > dp[neighbor]:\n                dp[neighbor] = new_val\n                heappush(pq, (new_val, neighbor))\n    return -dp[-1]\n\nprint(solve())\n```", "time_gen": "\ntime generating: 17.531507s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=259": {"code": "```\n```python\nN, M = map(int, input().split())\nbessie_segments = []\nfor _ in range(N):\n    speed, time = map(int, input().split())\n    bessie_segments.append((speed, time))\n\nelsie_segments = []\nfor _ in range(M):\n    speed, time = map(int, input().split())\n    elsie_segments.append((speed, time))\n\ntotal_distance = sum(s * t for s, t in zip(*[s + (0,) for s in [bessie_segments, elsie_segments]]))\ndistance_so_far = 0\n\nleadership_changes = 0\nfor bessie_speed, bessie_time in bessie_segments:\n    distance_bessie_runs = bessie_speed * min(bessie_time, total_distance - distance_so_far)\n    distance_so_far += distance_bessie_runs\n    for elsie_speed, elsie_time in elsie_segments:\n        if total_distance - distance_so_far < elsie_time:\n            break\n        distance_elsie_runs = elsie_speed * min(elsie_time, total_distance - distance_so_far)\n        distance_so_far += distance_elsie_runs\n        if distance_bessie_runs + distance_elsie_runs > 0 and (distance_bessie_runs - distance_elsie_runs) % (bessie_speed + elsie_speed) == 0:\n            leadership_changes += 1\n\nprint(leadership_changes)\n```", "time_gen": "\ntime generating: 16.919994s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=260": {"code": "```\nfrom collections import defaultdict\n\nN, K = map(int, input().split())\nbreads = [int(input()) for _ in range(N)]\n\nmax_breed_id = -1\nseen_breeds = set()\nfor i in range(N):\n    if breeds[i] in seen_breeds:\n        max_breed_id = max(max_breed_id, breeds[i])\n    else:\n        seen_breeds.add(breads[i])\n\nprint(max_breed_id)\n```", "time_gen": "\ntime generating: 5.867695s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=261": {"code": "Here is the Python code:\n```\nn, k = map(int, input().split())\ngraph = [[] for _ in range(n)]\nfor _ in range(k):\n    x, y = input().split()\n    if x == 'S':\n        graph[x-1].append(y-1)\n        graph[y-1].append(x-1)\n    elif x == 'D':\n        graph[x-1].append(str(-y))\n        graph[y-1].append(str(-x))\n\ndef dfs(node, color):\n    visited.add(node)\n    for neighbor in graph[node]:\n        if neighbor < 0:\n            return True\n        if neighbor not in visited and dfs(int(neighbor), -color):\n            return True\n\ntotal = 0\nfor i in range(n):\n    if i not in visited:\n        total += 1 if dfs(i, 1) else 0\n\nprint(total)\n```", "time_gen": "\ntime generating: 10.061331s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=262": {"code": "```python\nn = int(input())\na = [int(x) for x in input().split()]\ns, e = 1, n\nans = 0\nfor i in range(len(a)):\n    if a[i] < s:\n        s = a[i]\n    elif a[i] > e:\n        e = a[i]\n    else:\n        ans += (e - s + 1)\n        s = a[i]\n        e = a[i]\nprint(ans+1)```", "time_gen": "\ntime generating: 6.044435s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=263": {"code": "```\nimport sys\ndef main():\n    N = int(sys.stdin.readline().strip())\n    count = 0\n    for _ in range(N):\n        x1, y1, x2, y2 = map(int, sys.stdin.readline().split())\n        for i in range(x1, x2+1):\n            for j in range(y1, y2+1):\n                if (i < x1 or i > x2) and (j < y1 or j > y2): \n                    count += 1\n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n```", "time_gen": "\ntime generating: 6.537482s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=264": {"code": "```\nimport heapq\nn = int(input())\ncows = [(int(line), i) for i, line in enumerate(map(int, input().split()))]\ncows.sort()\nheap = []\ntotal_damage = 0\nfor i, (damage, pos) in enumerate(cows):\n    while len(heap) > i:\n        prev_damage, _ = heapq.heappop(heap)\n        total_damage += damage - prev_damage\n    heapq.heappush(heap, (pos, damage))\nprint(total_damage)\n```", "time_gen": "\ntime generating: 3.307438s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=265": {"code": "```\ndef cowrun(input_file):\n    with open(input_file, 'r') as file:\n        N = int(file.readline())\n        cows = [int(line.strip()) for line in file.readlines()]\n    \n    cows.sort()\n    total_damage = 0\n    for i in range(N-1):\n        distance = abs(cows[i] - cows[i+1])\n        damage = distance * (i + 2)\n        total_damage += damage\n    \n    print(total_damage)\n\ncowrun('cowrun.in')\n```", "time_gen": "\ntime generating: 5.827819s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=266": {"code": "```\n```\n\n```python\nn = int(input())\nhills = []\nfor _ in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    hills.append((x1, y1, x2, y2))\n\ncount = 0\nx, y = 0, 0\n\nwhile True:\n    for hill in hills:\n        if x >= hill[0] and x <= hill[2]:\n            if y < hill[1] or y > hill[3]:\n                break\n    else:\n        count += 1\n    if y == -float('inf'):\n        break\n    x = min(hill[2] for hill in hills)\n    y -= 1\n\nprint(count)\n```\n\nNote: This code assumes that the input is correct and does not contain any invalid or inconsistent data.", "time_gen": "\ntime generating: 5.47816s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=267": {"code": "```\n```\ndef find_min_stones_to_remove(necklace, name):\n    m = len(name)\n    n = len(necklace)\n\n    stones_to_remove = 0\n    for i in range(n - m + 1):\n        if necklace[i:i+m] == name:\n            stones_to_remove += m\n\n    return stones_to_remove\n\nif __name__ == \"__main__\":\n    with open(\"necklace.in\", \"r\") as f:\n        necklace = f.readline().strip()\n        name = f.readline().strip()\n\n    print(find_min_stones_to_remove(necklace, name))\n```", "time_gen": "\ntime generating: 5.314247s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=278": {"code": "```python\ndef ballet(dance):\n    x, y = 0, 0\n    for i in dance:\n        if i[0] == 'F':\n            dx, dy = {'R': 1, 'L': -1}.get(i[1], 0), {'B': -1, 'F': 1}.get(i[2], 0)\n        else:\n            dx, dy = 0, 0\n            if i[0] == 'F':\n                x, y = y, -x\n            elif i[0] == 'R':\n                x, y = -y, x\n            elif i[0] == 'L':\n                x, y = y, -x\n        x += dx\n        y += dy\n        if abs(x) + abs(y) > 1000:\n            return -1\n    min_x, max_x = min(0, x), max(0, x)\n    min_y, max_y = min(0, y), max(0, y)\n    return (max_x + 1) * (max_y + 1)\n```", "time_gen": "\ntime generating: 18.615467s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=279": {"code": "```\npython\nN, B = [int(x) for x in input().split()]\nlights = list(map(int, input().split()))\nfor _ in range(B):\n    new_lights = [(lights[i-1] + lights[(i+1)%N]) % 2 for i in range(N)]\n    lights = new_lights\nprint(*lights, sep='\\n')\n```", "time_gen": "\ntime generating: 7.366463s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=280": {"code": "```markdown\n```python\nimport sys\n\ndef photo(N, K):\n    pairs = []\n    for _ in range(K):\n        a, b = map(int, sys.stdin.readline().split())\n        pairs.append((min(a, b), max(a, b)))\n\n    pairs.sort()\n\n    photos = 0\n    last_pair_end = -1\n    for pair in pairs:\n        if pair[0] > last_pair_end + 1:\n            photos += 1\n            last_pair_end = pair[1]\n        else:\n            last_pair_end = max(last_pair_end, pair[1])\n\n    if last_pair_end < N:\n        photos += 1\n\n    print(photos)\n\nphoto(*map(int, sys.stdin.readline().split()))\n```\n```", "time_gen": "\ntime generating: 9.373626s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=281": {"code": "Here is a Python solution for the Haywire problem:\n\n```\ndef count_hay(cow_friends):\n    cow_friends.sort()\n    hay_count = 0\n    i = 0\n    while i < len(cow_friends) - 1:\n        j = i + 1\n        while j < len(cow_friends):\n            if cow_friends[j] > cow_friends[i]:\n                break\n            j += 1\n        hay_count += (j - i) * (j - i - 1) // 2\n        i = j\n    return hay_count\n\ndef main():\n    N = int(input())\n    cow_friends = [list(map(int, input().split())) for _ in range(N)]\n    \n    min_hay = float('inf')\n    for perm in itertools.permutations(range(1, N+1)):\n        this_perm_hay = count_hay([i-1 for i in perm])\n        min_hay = min(min_hay, this_perm_hay)\n\n    print(min_hay)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis code uses the itertools.permutations function to generate all possible orderings of the cows. It then calculates the total amount of hay required for each ordering and keeps track of the minimum.", "time_gen": "\ntime generating: 15.473619s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=282": {"code": "```\nimport sys\n\ndef read_input():\n    N, M = map(int, input().split())\n    world = [input() for _ in range(N)]\n    start_captain = None\n    doctor_location = None\n    for i in range(N):\n        for j in range(M):\n            if world[i][j] == 'C':\n                start_captain = (i, j)\n            elif world[i][j] == 'D':\n                doctor_location = (i, j)\n    return N, M, world, start_captain, doctor_location\n\ndef is_valid_position(world, position):\n    row, col = position\n    if row < 0 or row >= len(world) or col < 0 or col >= len(world[0]):\n        return False\n    return world[row][col] != '#'\n\ndef calculate_distance(world, start, end):\n    queue = [(start, 0)]\n    visited = set([start])\n    while queue:\n        position, distance = queue.pop(0)\n        if position == end:\n            return distance\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_position = (position[0] + dx, position[1] + dy)\n            if is_valid_position(world, new_position) and new_position not in visited:\n                queue.append((new_position, distance + 1))\n                visited.add(new_position)\n    return -1\n\ndef solve():\n    N, M, world, start_captain, doctor_location = read_input()\n    gravity_flips = calculate_distance(world, start_captain, doctor_location)\n    if gravity_flips == -1:\n        print(-1)\n    else:\n        print(gravity_flips)\n\nif __name__ == \"__main__\":\n    solve()\n```", "time_gen": "\ntime generating: 22.777423s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=283": {"code": "```\npython\n```\n\n```markdown\ndef solve():\n    N, G, B, D = map(int, input().split())\n    stations = [list(map(int, input().split())) for _ in range(N)]\n    dp = [[float('inf')] * (G + 1) for _ in range(D + 1)]\n\n    dp[0][B] = 0\n    for i in range(D):\n        for j in range(min(G, D - i), -1, -1):\n            if dp[i][j] != float('inf'):\n                x, y = stations[i]\n                if j + y <= G:\n                    dp[i + 1][min(j + y, G)] = min(dp[i + 1][min(j + y, G)], dp[i][j] + y)\n                if i >= x and j >= y:\n                    dp[x][j - y] = min(dp[x][j - y], dp[i][j] + y)\n\n    return dp[D][G] if dp[D][G] != float('inf') else -1\n\nprint(solve())\n```", "time_gen": "\ntime generating: 15.760772s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=284": {"code": "```\npython\nN, M, K = [int(x) for x in input().split()]\nport_directions = [input().split() for _ in range(N)]\ndirection_sequence = list(input())\n\ncurrent_port = 1\nfor _ in range(K):\n    if direction_sequence.pop(0) == 'L':\n        next_port = int(port_directions[current_port-1][0])\n    else:\n        next_port = int(port_directions[current_port-1][1])\n    current_port = next_port\n\nprint(current_port)\n```", "time_gen": "\ntime generating: 8.780866s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=285": {"code": "```\n```\n\n```\nn, m = [int(x) for x in input().split()]\nspots = set()\nfor _ in range(m):\n    a, b = [int(x) for x in input().split()]\n    if a == 1:\n        spots.add(b)\n    elif b == n:\n        spots.add(a - 1)\n    else:\n        if (a + b) % 2 == 0:\n            if a < b:\n                spots.add(b)\n            else:\n                spots.add(a - 1)\n        else:\n            if a < b:\n                spots.add(a - 1)\n            else:\n                spots.add(b)\nprint(min(spots) if len(spots) > 0 else -1)\n```", "time_gen": "\ntime generating: 10.279394s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=286": {"code": "```\n```python\ndef read_input():\n    N = int(input())\n    edges = []\n    for _ in range(N-1):\n        a, b, t = map(int, input().split())\n        edges.append((a, b, t))\n    return N, edges\n\n\ndef find_paths(N, edges):\n    paths = set()\n    for i in range(N-1):\n        for j in range(i+1, N):\n            path = [i+1]\n            while True:\n                for edge in edges:\n                    if len(path) == 0 or (path[-1] == edge[0] and edge[1] not in path) or (path[-1] == edge[1] and edge[0] not in path):\n                        path.append(edge[0] if edge[1] == j else edge[1])\n                        break\n                else:\n                    continue\n                break\n            if len(path) > 2 and path.count(path[0]) == 1 and path.count(path[-1]) == 1:\n                paths.add(tuple(sorted(map(int, path))))\n    return paths\n\n\ndef main():\n    N, edges = read_input()\n    paths = find_paths(N, edges)\n    print(len(paths))\n\n\nif __name__ == \"__main__\":\n    main()```", "time_gen": "\ntime generating: 16.448615s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=287": {"code": "```python\ndef find_max_score(marble):\n    N = len(marble)\n    max_score = -1\n    \n    for top_left_x in range(N):\n        for top_left_y in range(N):\n            if marble[top_left_y][top_left_x] == '*':\n                continue\n            \n            for bottom_right_x in range(top_left_x, N):\n                for bottom_right_y in range(N-1, top_left_y, -1):\n                    if marble[bottom_right_y][bottom_right_x] == '*':\n                        break\n                    if marble[top_left_y][top_left_x] != '.':\n                        continue\n                    \n                    top_width = 0\n                    while top_left_x + top_width < bottom_right_x and marble[top_left_y][top_left_x+top_width] == '.':\n                        top_width += 1\n                        \n                    bottom_width = 0\n                    while bottom_right_y - bottom_width > top_left_y and marble[bottom_right_y-bottom_width][bottom_right_x] == '.':\n                        bottom_width += 1\n                        \n                    if top_width * bottom_width > max_score:\n                        max_score = top_width * bottom_width\n    \n    return max_score\n\n# Read input\nN = int(input())\nmarble = [list(line) for line in [input() for _ in range(N)]]\n\nprint(find_max_score(marble))\n```", "time_gen": "\ntime generating: 17.176296s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=340": {"code": "```\ndef count_combinations(N, farmer, master):\n    total = 0\n    for i1 in range(N + 1):\n        for i2 in range(N + 1):\n            for i3 in range(N + 1):\n                diff_farmer = abs(i1 - farmer[0]) + abs(i2 - farmer[1]) + abs(i3 - farmer[2])\n                diff_master = abs(i1 - master[0]) + abs(i2 - master[1]) + abs(i3 - master[2])\n                if min(diff_farmer, diff_master) <= 2:\n                    total += 1\n    return total\n\nN = int(input())\nfarmer = list(map(int, input().split()))\nmaster = list(map(int, input().split()))\n\nprint(count_combinations(N, farmer, master))\n```", "time_gen": "\ntime generating: 10.910419s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=341": {"code": "Here is the Python solution for the problem:\n```\nn, x, y, z = map(int, input().split())\ntotal_milk = 0\nfor _ in range(n):\n    a, b = map(int, input().split())\n    if a <= x:\n        total_milk += x\n    elif b >= y:\n        total_milk += y\n    else:\n        for t in range(a, b+1):\n            if t < x:\n                total_milk += x\n            elif t > y:\n                total_milk += z\n            else:\n                total_milk += y\nprint(total_milk)\n```\nThis code first reads the input values `n`, `x`, `y`, and `z`. Then, it iterates over each cow, reading its temperature range `[a, b]`. For each cow, it checks if the optimal temperature is below `x` (in which case all milk produced is `x`), above `y` (in which case all milk produced is `z`), or within the comfortable range `[a, b]` (in which case the maximum milk produced is `y`). The total milk produced by all cows is then printed.", "time_gen": "\ntime generating: 6.964444s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=342": {"code": "```\npython\nN, K = map(int, input().split())\nadjectives = set()\nfor _ in range(N):\n    adjectives.update(adjs.strip(\"no the \").lower().split() for adjs in input().strip().replace(\"has no \", \"have not \").split(\".\")[0].split())\n\ncombinations = set()\nfor adjective in adjectives:\n    combinations.add(adjective)\n    if len(combinations) == 2 ** (adjectives.index(adjective) + 1):\n        break\n\ncombinations = sorted(list(combinations))\nprint(f\"large {' '.join(['brown' if i & 1 else 'white' for i in range(3)])} {combinations[K-1]} cow.\")\n```", "time_gen": "\ntime generating: 5.484686s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=343": {"code": "```\nN, K = map(int, input().split())\nadjectives = []\nfor _ in range(N):\n    line = input().strip()\n    words = line.split()\n    adjectives.append([word for word in words[6:-1] if word != 'no'])\n\nresult = ''\nfor adjective_set in set(tuple(sorted(adjective)) for adjective in product(*adjectives)):\n    result += (' ' + ' '.join(adjective) for adjective in zip(*adjective_set))[0]\n\nprint(result.split()[K-1])\n```", "time_gen": "\ntime generating: 4.476325s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=344": {"code": "```\nimport sys\n\nN, D = map(int, sys.stdin.readline().split())\n\ncows = []\nfor _ in range(N):\n    x, h = map(int, sys.stdin.readline().split())\n    cows.append((x, h))\n\ncrowded_cows = 0\nfor i in range(N):\n    left_count = right_count = 0\n    for j in range(i-1, -1, -1):\n        if abs(cows[j][0] - cows[i][0]) <= D and cows[j][1] >= cows[i][1]/2:\n            left_count += 1\n            break\n    for k in range(i+1, N):\n        if abs(cows[k][0] - cows[i][0]) <= D and cows[k][1] >= cows[i][1]/2:\n            right_count += 1\n            break\n    if left_count > 0 and right_count > 0:\n        crowded_cows += 1\n\nprint(crowded_cows)\n```", "time_gen": "\ntime generating: 5.939611s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=345": {"code": "Here is the Python solution for Problem 3: Pogo-Cow:\n```\ndef solve():\n    n = int(input())\n    targets = []\n    for _ in range(n):\n        x, p = map(int, input().split())\n        targets.append((x, p))\n    targets.sort()\n    dp = [0] * (targets[-1][0] + 2)\n    for i in range(1, len(dp)):\n        max_points = 0\n        for j in range(len(targets) - 1):\n            if targets[j][0] <= i:\n                max_points = max(max_points, dp[targets[j][0]] + targets[j][1])\n                break\n        dp[i] = max_points\n    return max(dp)\n\nprint(solve())\n```\nThis code reads in the target positions and values, sorts them by position, and then uses dynamic programming to calculate the maximum points that Bessie can receive.", "time_gen": "\ntime generating: 6.025504s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=346": {"code": "Here is the solution to the problem:\n\n```markdown\n```\n```python\ndef empty_stalls(N, K):\n    stalls = [0] * N\n    for _ in range(K):\n        x, y, a, b = map(int, input().split())\n        for i in range(x, y+1):\n            stalls[(a+i+b)%N] += 1\n    return min(i for i in range(N) if stalls[i] == 0)\n\nN, K = map(int, input().split())\nprint(empty_stalls(N, K))\n```", "time_gen": "\ntime generating: 5.896535s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=347": {"code": "```\n```\ndef line_of_sight():\n    n, r = [int(x) for x in input().split()]\n    cows = []\n    for _ in range(n):\n        x, y = [int(x) for x in input().split()]\n        cows.append((x, y))\n\n    count = 0\n    for i in range(len(cows)):\n        for j in range(i+1, len(cows)):\n            dx = abs(cows[i][0] - cows[j][0])\n            dy = abs(cows[i][1] - cows[j][1])\n            if (dx == 0 and dy > r) or (dy == 0 and dx > r):\n                continue\n            if (cows[i][0]**2 + cows[i][1]**2)**0.5 + (cows[j][0]**2 + cows[j][1]**2)**0.5 <= 2*r:\n                count += 1\n\n    print(count)\n```\n```\n\nNote: This code is written in Python and solves the problem as described.", "time_gen": "\ntime generating: 7.824611s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=348": {"code": "```\nimport heapq\n\ndef no_change(k, n, c, p):\n    # Initialize priority queue for coins\n    heap = [(v, i) for i, v in enumerate(c)]\n    heapq.heapify(heap)\n\n    # Initialize maximum amount of money FJ can end up with\n    max_amount = 0\n\n    for x in p:\n        while True:\n            # Get the largest coin that is greater than or equal to the purchase cost\n            while heap and -heap[0][0] < x:\n                v, i = heapq.heappop(heap)\n                if v >= x:\n                    max_amount += v - x\n                    break\n                else:\n                    max_amount -= (v + 1) - x\n            # If no such coin is found, FJ cannot make the purchase\n            if not heap:\n                return -1\n    return max_amount\n\nk = int(input())\nn = int(input())\nc = [int(input()) for _ in range(k)]\np = [int(input()) for _ in range(n)]\n\nprint(no_change(k, n, c, p))", "time_gen": "\ntime generating: 7.33172s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=358": {"code": "```\nfrom collections import Counter\n\nn = int(input())\ncow_lists = [input().split() for _ in range(n)]\n\ndef record_group(cow_lists):\n    groups = [tuple(sorted(group)) for group in cow_lists]\n    return max(Counter(groups).values())\n\nprint(record_group(cow_lists))\n```", "time_gen": "\ntime generating: 2.863831s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=359": {"code": "Here is the Python code for the problem:\n```\nn = int(input())\ncows = list(map(int, input().split()))\ncounts = [0] * 1001\nfor i in range(2, n):\n    counts[cows[i-1]] += 1\n    for j in range(i+1, n):\n        if cows[j-1] - cows[i-1] <= 200000000 and cows[j-1] - cows[i-1] >= 1:\n            print(counts[i-1])\n```\nThis code reads the input file line by line. It first reads the number of cows `n`, then reads the positions of all cows. Then it counts the number of possible triples (X, Y, Z) for each cow i, considering only cows with positions between `i-1` and 200000000.", "time_gen": "\ntime generating: 5.554441s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=360": {"code": "```\ndef count_wormhole_pairs(wormholes):\n    x_coords = [int(x) for x, _ in wormholes]\n    y_coords = [int(y) for _, y in wormholes]\n\n    min_x = min(x_coords)\n    max_x = max(x_coords)\n    min_y = min(y_coords)\n    max_y = max(y_coords)\n\n    pairs = 0\n    for i in range(0, len(wormholes), 2):\n        x1, y1 = wormholes[i]\n        x2, y2 = wormholes[i + 1]\n\n        if (x1 == min_x or x1 == max_x) and (y1 == min_y or y1 == max_y):\n            pairs += 1\n\n    return pairs\n\n\nif __name__ == \"__main__\":\n    N = int(input())\n    wormholes = []\n    for _ in range(N):\n        wormhole = input().split()\n        wormhole = [int(x) for x in wormhole]\n        wormholes.append(wormhole)\n\n    print(count_wormhole_pairs(wormholes))\n```", "time_gen": "\ntime generating: 8.413615s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=361": {"code": "Here is a Python solution for the problem:\n```\nn = int(input())\nmilk_gallons = []\ndeadlines = []\nfor i in range(n):\n    g, d = map(int, input().split())\n    milk_gallons.append(g)\n    deadlines.append(d)\n\nmilk_gallons.sort()\ndeadlines.sort()\n\ni = j = 0\nmax_milk = 0\n\nwhile i < n and j < n:\n    if deadlines[j] >= i + 1:\n        max_milk += milk_gallons[i]\n        i += 1\n    else:\n        j += 1\n\nprint(max_milk)\n```", "time_gen": "\ntime generating: 4.798133s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=362": {"code": "```\npython\n```vacation.py\nN, M, K, Q = map(int, input().split())\ngraph = {}\nfor i in range(M):\n    u, v, d = map(int, input().split())\n    if u not in graph:\n        graph[u] = []\n    if v not in graph:\n        graph[v] = []\n    graph[u].append((v, d))\n    graph[v].append((u, d))\n\ndef dfs(farm, visited, path_cost):\n    for neighbor, cost in graph[farm]:\n        if neighbor == K:  # we've reached a hub\n            return min(dfs(hub, set(visited + [hub]), path_cost + cost) for hub in graph[neighbor] if hub not in visited)\n        elif neighbor not in visited:\n            new_path_cost = path_cost + cost\n            result = dfs(neighbor, visited + [neighbor], new_path_cost)\n            if result is not None:\n                return min(result, new_path_cost)\n    return None\n\ntotal_trips = 0\ntotal_route_cost = 0\nfor i in range(Q):\n    start, end = map(int, input().split())\n    route_cost = dfs(start, [start], 0) if end != K else dfs(end, [end], 0)\n    if route_cost is not None:\n        total_trips += 1\n        total_route_cost += route_cost\n\nprint(total_trips)\nprint(total_route_cost)\n```", "time_gen": "\ntime generating: 11.676163s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=363": {"code": "```\ndef shuffle(N, M, Q):\n    cards = list(range(1, N+1))\n    top_cards = []\n    for _ in range(M):\n        for i in range(len(cards)-1, -1, -1):\n            if i >= len(cards) // 2:\n                cards[i], cards[len(cards) - 1] = cards[len(cards) - 1], cards[i]\n                top_cards.append(cards.pop())\n            else:\n                cards[0], cards[i] = cards[i], cards[0]\n                cards.pop(0)\n        if len(top_cards):\n            top_cards[-1].pop(0)\n\n    result = []\n    for _ in range(Q):\n        query_pos = int(input())\n        result.append(cards[query_pos-1])\n\n    return '\\n'.join(map(str, result))\n\nN, M, Q = map(int, input().split())\nprint(shuffle(N, M, Q))\n```", "time_gen": "\ntime generating: 8.067687s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=364": {"code": "```\npython\nN, M, K, Q = map(int, input().split())\ngraph = [[] for _ in range(N+1)]\nfor i in range(M):\n    u, v, d = map(int, input().split())\n    graph[u].append((v, d))\n    graph[v].append((u, d))\n\nhubs = set()\nfor i in range(K):\n    hubs.add(int(input()))\n\ndp = [[float('inf')] * (N+1) for _ in range(N+1)]\nfor a in range(1, N+1):\n    dp[a][a] = 0\nfor a in range(1, N+1):\n    for b, d in graph[a]:\n        if a != b:\n            for c in range(b+1, N+1):\n                if (c, d) not in graph[b]:\n                    dp[a][c] = min(dp[a][c], dp[a][b] + d)\n\nrequests = []\nfor i in range(Q):\n    a, b = map(int, input().split())\n    requests.append((a, b))\n\npossible_requests = 0\nmin_cost = float('inf')\nfor a, b in requests:\n    if (dp[a][b] != float('inf')):\n        possible_requests += 1\n        min_cost = min(min_cost, dp[a][b])\n\nprint(possible_requests)\nprint(min_cost)\n```", "time_gen": "\ntime generating: 9.934894s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=365": {"code": "```\n```\n```python\nn, d = map(int, input().split())\nmilk = list(map(int, input().split()))\nfor _ in range(d):\n    i, m = map(int, input().split())\n    milk[i-1] = m\n\ndp = [[0, 0]] * (d + 1)\nfor day in range(1, d + 1):\n    for j in range(min(day+1, n+1)):\n        if j == 0:\n            dp[day][j] = max(dp[day-1][j], sum(milk[:i]))\n        elif j < i:\n            dp[day][j] = dp[day-1][j]\n        else:\n            dp[day][j] = max(dp[day-1][j], dp[day-1][j-2] + milk[i-1])\nprint(int(max(dp[-1])))\n```\n```", "time_gen": "\ntime generating: 7.330855s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=366": {"code": "```\n```\n```\n```", "time_gen": "\ntime generating: 3.167971s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=376": {"code": "Here is the Python code for the problem:\n```\nn = int(input())\nhills = list(map(int, input().split() for _ in range(n)))\n\n# Calculate the maximum and minimum heights\nmax_height = max(hills)\nmin_height = min(hills)\n\ndiff = max_height - min_height\n\ncost = 0\nwhile diff > 17:\n    if diff % 2 == 1:\n        cost += (diff // 2 + 1) ** 2\n        diff -= (diff // 2 + 1) * 2\n    else:\n        cost += (diff // 2) ** 2\n        diff -= diff // 2 * 2\n\nprint(cost)\n```", "time_gen": "\ntime generating: 5.630964s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=377": {"code": "```\npython\nN = int(input())\ntime = 0\nspeed = 1\nfor _ in range(N):\n    event = input().split()\n    if event[0] == 'T':\n        time += int(event[1])\n    elif event[0] == 'D':\n        time += (int(event[1]) * speed) / sum(range(1, speed+1))\n        speed //= sum(range(1, speed+1))\nprint(time)\n```", "time_gen": "\ntime generating: 4.874844s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=378": {"code": "Here is the solution:\n```\ntotal_skill = sum(map(int, open('input.txt', 'r').read().strip().split('\\n')))\nmin_diff = total_skill // 4\nmax_diff = (total_skill - min_diff) // 3\nwhile max_diff > min_diff:\n    max_diff -= 1\nprint(min_diff)\n```", "time_gen": "\ntime generating: 3.353463s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=379": {"code": "```\npython\nimport sys\n\ndef slowdown(events):\n    distance = 0\n    speed = 1\n    time = 0\n    for event in events:\n        if 'T' in event:\n            time += int(event.split()[1])\n        elif 'D' in event:\n            distance += int(event.split()[1]) * speed\n            speed /= 2\n        if distance >= 1000:\n            break\n    return round(time + (distance - 1000) * speed)\n\nN = int(sys.stdin.readline())\nevents = []\nfor _ in range(N):\n    events.append(sys.stdin.readline().strip())\n\nprint(slowdown(events))\n```", "time_gen": "\ntime generating: 6.375377s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=380": {"code": "```\n```\n```\n```\n\n```python\nfrom collections import deque\n\ndef ccski():\n    M, N = map(int, input().split())\n    grid_elevations = [list(map(int, input().split())) for _ in range(M)]\n    grid_waypoints = [[int(x) for x in input().split()] for _ in range(M)]\n\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n\ndef bfs(row, col, D):\n    visited = [[False] * N for _ in range(M)]\n    queue = deque([(row, col)])\n\n    while queue:\n        r, c = queue.popleft()\n        if visited[r][c]:\n            continue\n        visited[r][c] = True\n\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < M and 0 <= nc < N and grid_elevations[nr][nc] - grid_elevations[r][c] <= D:\n                if grid_waypoints[nr][nc]:\n                    return True\n                queue.append((nr, nc))\n\n    return False\n\n\ndef solve():\n    min_D = float('inf')\n    for r in range(M):\n        for c in range(N):\n            if grid_waypoints[r][c]:\n                for d in range(1, 1000001):  # D <= M x N\n                    if bfs(r, c, d):\n                        min_D = min(min_D, d)\n                        break\n\n    return min_D\n\n\nprint(solve())\n```", "time_gen": "\ntime generating: 11.135766s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=381": {"code": "Here is the Python solution for the problem:\n```\nimport sys\n\nn = int(sys.stdin.readline())\ntimes = []\nfor i in range(n):\n    start, end = map(int, sys.stdin.readline().split())\n    times.append((start, 1))  # mark as program 1\n    times.append((end, -1))   # mark as program end\n\ntimes.sort()\nlast_start = 0\nrecording_count = 0\nfor time, delta in times:\n    if delta == 1:\n        last_start = time\n        recording_count += 1\n    elif delta == -1:\n        recording_count -= 1\n\nprint(recording_count)\n```", "time_gen": "\ntime generating: 4.761105s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=382": {"code": "Here is the Python code for the problem:\n```\nn = int(input())\nteam_a_stones = []\nteam_b_stones = []\n\nfor i in range(n):\n    a_x, a_y = map(int, input().split())\n    team_a_stones.append((a_x, a_y))\n\nfor i in range(n, 2*n):\n    b_x, b_y = map(int, input().split())\n    team_b_stones.append((b_x, b_y))\n\ndef is_point_inside_triangle(p1, p2, p3, x, y):\n    v1 = (x - p1[0], y - p1[1])\n    v2 = (p2[0] - p1[0], p2[1] - p1[1])\n    v3 = (p3[0] - p1[0], p3[1] - p1[1])\n\n    if ((v1[0]*v2[1] - v1[1]*v2[0]) + (v2[0]*v3[1] - v2[1]*v3[0]) + (v3[0]*v1[1] - v3[1]*v1[0])) % 4 == 0:\n        return True\n    else:\n        return False\n\nscore_a = 0\nscore_b = 0\n\nfor stone in team_b_stones:\n    if is_point_inside_triangle(min(team_a_stones, key=lambda p: (p[0]**2 + p[1]**2)), \n                                  max(team_a_stones, key=lambda p: (p[0]**2 + p[1]**2)), \n                                  (min(team_a_stones, key=lambda p: p[0]), min(team_a_stones, key=lambda p: p[1])), \n                                  stone[0], stone[1]):\n        score_b += 1\n    if is_point_inside_triangle(min(team_b_stones, key=lambda p: (p[0]**2 + p[1]**2)), \n                                  max(team_b_stones, key=lambda p: (p[0]**2 + p[1]**2)), \n                                  (min(team_b_stones, key=lambda p: p[0]), min(team_b_stones, key=lambda p: p[1])), \n                                  stone[0], stone[1]):\n        score_a += 1\n\nprint(f\"{score_a} {score_b}\")\n```", "time_gen": "\ntime generating: 15.501134s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=383": {"code": "Here is the Python code for the problem:\n```\nM, N = [int(x) for x in input().split()]\ndesired_course = [list(input()) for _ in range(M)]\n\ndef find_max_b(desired_course):\n    max_b = 0\n    for i in range(len(desired_course)):\n        for j in range(len(desired_course[i])):\n            rough_neighbors = 0\n            smooth_neighbors = 0\n            if i > 0 and desired_course[i-1][j] == 'R':\n                rough_neighbors += 1\n            if i < len(desired_course) - 1 and desired_course[i+1][j] == 'R':\n                rough_neighbors += 1\n            if j > 0 and desired_course[i][j-1] == 'R':\n                rough_neighbors += 1\n            if j < len(desired_course[i]) - 1 and desired_course[i][j+1] == 'R':\n                rough_neighbors += 1\n            if i > 0 and desired_course[i-1][j] == 'S':\n                smooth_neighbors += 1\n            if i < len(desired_course) - 1 and desired_course[i+1][j] == 'S':\n                smooth_neighbors += 1\n            if j > 0 and desired_course[i][j-1] == 'S':\n                smooth_neighbors += 1\n            if j < len(desired_course[i]) - 1 and desired_course[i][j+1] == 'S':\n                smooth_neighbors += 1\n            if rough_neighbors > 0 and smooth_neighbors > 0:\n                max_b = max(max_b, min(rough_neighbors, smooth_neighbors))\n    return max_b\n\nprint(find_max_b(desired_course))\n```\nThis code reads in the desired course design from input, then uses a brute force approach to find the maximum value of B that can be used to create the desired course. The maximum value is determined by finding the minimum number of rough or smooth patches that are needed to create the desired course.", "time_gen": "\ntime generating: 13.57328s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=384": {"code": "Here is the solution to the problem:\n```\nM = int(input())\nN = int(input())\nT = int(input())\n\ngrid_elevations = [list(map(int, input().split())) for _ in range(M)]\nstart_points = [[int(x) for x in input().split()] for _ in range(M)]\n\ndef dfs(i, j, D):\n    if i < 0 or i >= M or j < 0 or j >= N:\n        return float('inf')\n    if start_points[i][j] == 1:\n        return 0\n    if grid_elevations[i][j] > 100000000:\n        return float('inf')\n    return min(dfs(i-1, j, D), dfs(i+1, j, D), dfs(i, j-1, D), dfs(i, j+1, D)) + (abs(grid_elevations[i][j]) - abs(D))\n\ndifficulty_ratings = [dfs(i, j, 0) for i in range(M) for j in range(N) if start_points[i][j] == 1]\nprint(sum(difficulty_ratings))\n```\nNote: This code assumes that the input is a Python file named `skilevel.in` and the output should be written to a file named `skilevel.out`.", "time_gen": "\ntime generating: 8.824847s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=394": {"code": "```\n```python\nn, m = map(int, input().split())\nmirrors = []\nfor _ in range(n):\n    mirrors.append(list(input()))\n\nmax_mirrors = 0\nfor i in range(n):\n    for j in range(m):\n        if mirrors[i][j] == '/':\n            max_mirrors += 1\n        else:\n            max_mirrors -= 1\n\nprint(max_mirrors)\n```", "time_gen": "\ntime generating: 3.962784s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=395": {"code": "```\ndef auto_complete():\n    W, N = map(int, input().split())\n    words = set()\n    \n    for _ in range(W):\n        word = input()\n        words.add(word)\n        \n    for _ in range(N):\n        K, partial_word = input().split()\n        K = int(K)\n        \n        completions = [word for word in words if word.startswith(partial_word)]\n        completions.sort()\n        \n        if len(completions) < K:\n            print(-1)\n        else:\n            print(completions[K-1].index(partial_word)+1)\n\nauto_complete()", "time_gen": "\ntime generating: 5.187134s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=396": {"code": "Here is the Python code for Problem 3: Secret Code:\n```\ndef scode(input_string):\n    n = len(input_string)\n    if n == 0 or n % 2 != 0:\n        return 0\n    res = 1\n    for i in range(1, n // 2 + 1):\n        if input_string[i:] + input_string[:i] == input_string:\n            res *= (n - i) * i\n    return res\n\nwith open(\"scode.in\", \"r\") as f:\n    s = f.readline().strip()\n\nprint(scode(s))\n```\nNote: This code assumes that the input file `scode.in` contains the secret message in a single line, and the output should be written to the console.", "time_gen": "\ntime generating: 5.690209s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=397": {"code": "Here is the Python solution for the problem:\n```\nimport sys\n\nW, N = map(int, input().split())\nwords = set()\nfor _ in range(W):\n    words.add(input())\n\nfor _ in range(N):\n    k, partial = input().split()\n    k = int(k)\n    completions = [word for word in words if word.startswith(partial)]\n    completions.sort()\n    try:\n        print(completions[k-1].index(partial) + 1)\n    except IndexError:\n        print(-1)\n```", "time_gen": "\ntime generating: 4.722228s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=398": {"code": "```\n```\n\n```python\nimport sys\n\ndef find_max_increase(n, m):\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    parent = [[-1] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        dp[i][i] = 0\n\n    for j in range(m):\n        a, b, length = map(int, sys.stdin.readline().split())\n        if dp[a][b] == 0:\n            for k in range(a + 1, b):\n                if parent[k][a] == -1:\n                    parent[k][a] = k\n                dp[b][k] = max(dp[b][k], dp[a][b] + length)\n        else:\n            for k in range(b + 1, a, -1):\n                if parent[k][b] == -1:\n                    parent[k][b] = k\n                dp[k][a] = min(dp[k][a], dp[b][k] + length)\n\n    max_increase = 0\n    for i in range(1, n):\n        for j in range(i + 1, n + 1):\n            max_increase = max(max_increase, dp[i][j])\n\n    return max_increase\n\n\nn, m = map(int, sys.stdin.readline().split())\nprint(find_max_increase(n, m))\n```", "time_gen": "\ntime generating: 11.091003s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=399": {"code": "Here is the Python solution for the problem:\n```markdown\n```\npython\ndef scode():\n    s = input()\n    n = len(s)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dp[i][i] = 1\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 1\n            else:\n                dp[i][j] = dp[i][j - 1] + dp[i + 1][j]\n    print(dp[0][n - 1] % 2014)\n```\n```", "time_gen": "\ntime generating: 7.475731s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=400": {"code": "```\n```python\ndef roadblock():\n    N, M = map(int, input().split())\n    paths = []\n    for _ in range(M):\n        a, b, length = map(int, input().split())\n        paths.append((a, b, length))\n\n    graph = [[] for _ in range(N+1)]\n    for path in paths:\n        a, b, length = path\n        graph[a].append((b, length))\n        graph[b].append((a, length))\n\n    visited = set()\n    dp = [float('inf')] * (N + 1)\n    dp[0] = 0\n\n    def dfs(node):\n        if node in visited:\n            return dp[node]\n        visited.add(node)\n        for neighbor, length in graph[node]:\n            dp[node] = min(dp[node], dfs(neighbor) + length)\n        return dp[node]\n\n    max_increase = 0\n    for i in range(N - 1):\n        increase = float('inf')\n        for path in paths:\n            a, b, original_length = path\n            if a == i + 1 and b == i + 2:  # This is the current edge\n                new_length = original_length * 2\n                new_path_length = dfs(i + 2) - length + new_length\n                increase = min(increase, new_path_length)\n        max_increase = max(max_increase, increase)\n\n    print(max_increase)\n```\n```", "time_gen": "\ntime generating: 11.450938s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=401": {"code": "Here is the Python solution for the problem:\n```markdown\n```\n```python\nimport sys\n\ndef solve():\n    N, B = map(int, input().split())\n    bonuses = []\n    for _ in range(B):\n        K, P, A = map(int, input().split())\n        bonuses.append((K, P, A))\n\n    cows = []\n    for _ in range(N):\n        skills = list(map(int, input().split()))\n        cows.append(skills)\n\n    dp = [[0] * (B + 1) for _ in range(2**N)]\n    for i in range(B + 1):\n        if i == 0:\n            continue\n        K, P, A = bonuses[i - 1]\n        for j in range(N):\n            for k in range(B):\n                dp[2**j][i] = max(dp[2**(j-1)][k] + cows[j][k], dp[2**j][k] + A)\n\n    return max(max(row) for row in dp)\n\nprint(solve())\n```\nThis code uses dynamic programming to find the maximum score that the cows can achieve. It iterates over each bonus and each possible combination of events, keeping track of the maximum score achieved so far. The final answer is the maximum score obtained from all possible combinations.", "time_gen": "\ntime generating: 11.113539s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=402": {"code": "```\npython\nN = int(input())\nseats = list(map(int, input().split()))\ntime_taken = 0\nseat_taken = [False] * N\n\nfor i in range(N):\n    while seats[i] < 1:\n        time_taken += 1\n        for j in range(i+1, N):\n            if not seat_taken[j]:\n                seats[j] -= 1\n        seats[i] += 1\n    time_taken += sum(seats[:i])\n    for i in range(N):\n        seat_taken[seats[i]-1] = True\n\nprint(time_taken)\n```", "time_gen": "\ntime generating: 5.692745s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=412": {"code": "Here is a Python solution for the problem:\n```\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nshifts = 0\nmax_shift_length = 0\n\ni = 0\nwhile i < n:\n    if a[i] == b[i]:\n        i += 1\n    else:\n        j = i + 1\n        while j < n and a[j] != b[i]:\n            j += 1\n        if j < n:\n            shifts += 1\n            max_shift_length = max(max_shift_length, j - i)\n        i = j\n\nprint(shifts, max_shift_length if shifts > 0 else -1)\n```", "time_gen": "\ntime generating: 6.375239s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=413": {"code": "```\nfrom bisect import bisect_left\n\nn, k = map(int, input().split())\npatches = []\nfor _ in range(n):\n    g, x = map(int, input().split())\n    patches.append((x, -g))\npatches.sort()\n\nans = 0\ntotal = 0\nleft = 0\nfor right in range(len(patches)):\n    while total + patches[right][1] > k and left < right:\n        total -= patches[left][1]\n        left += 1\n    if left <= right:\n        ans = max(ans, total + patches[right][1])\nprint(ans)\n```", "time_gen": "\ntime generating: 5.034979s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=414": {"code": "```\ndef cow_art(n):\n    regions_human = 0\n    regions_cow = 0\n    \n    for i in range(n):\n        prev_color = None\n        current_regions_human = 1\n        current_regions_cow = 1\n        \n        for j in range(n):\n            if (j > 0 and ((prev_color == 'R' and grid[i][j] in ['G', 'B']) or \n                           (prev_color == 'G' and grid[i][j] in ['R', 'B']) or\n                           (prev_color == 'B' and grid[i][j] in ['R', 'G']))):\n                if prev_color == 'R':\n                    current_regions_human -= 1\n                elif prev_color == 'G':\n                    current_regions_cow -= 1\n                else:\n                    current_regions_cow -= 1\n            elif (j < n - 1 and ((grid[i][j] in ['R', 'B'] and grid[i][j+1] in ['G']) or \n                                  (grid[i][j] in ['G'] and grid[i][j+1] in ['R']))):\n                if grid[i][j] == 'R':\n                    current_regions_human += 1\n                elif grid[i][j] == 'G':\n                    current_regions_cow += 1\n            \n            prev_color = grid[i][j]\n        \n        regions_human += current_regions_human\n        regions_cow += current_regions_cow\n    \n    return f\"{regions_human} {regions_cow}\"\n\n\nn = int(input())\ngrid = [input() for _ in range(n)]\n\nprint(cow_art(n))\n```", "time_gen": "\ntime generating: 10.639996s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=415": {"code": "```\nimport sys\n\ndef read_input():\n    N, C = map(int, raw_input().split())\n    fields = []\n    for _ in range(N):\n        x, y = map(int, raw_input().split())\n        fields.append((x, y))\n    return N, C, fields\n\ndef distance(p1, p2):\n    return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n\ndef kruskal(N, C, fields):\n    edges = []\n    for i in range(N):\n        for j in range(i+1, N):\n            edge = ((fields[i][0]-fields[j][0])**2 + (fields[i][1]-fields[j][1])**2, i, j)\n            if edge[0] >= C:\n                edges.append(edge)\n    edges.sort()\n\n    parent = dict((i, i) for i in range(N))\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    mst_cost = 0\n    for edge in edges:\n        u, v = edge[1], edge[2]\n        if find(u) != find(v):\n            parent[find(v)] = find(u)\n            mst_cost += edge[0]\n    if any(find(i) != find(0) for i in range(N)):\n        return -1\n    else:\n        return mst_cost\n\nN, C, fields = read_input()\nprint(kruskal(N, C, fields))\n```", "time_gen": "\ntime generating: 10.561557s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=416": {"code": "```\ndef lazy_cow():\n    N, K = map(int, input().split())\n    G = [list(map(int, input().split())) for _ in range(N)]\n    \n    dp = [[0]*N for _ in range(N)]\n    max_grass = 0\n    \n    for r in range(N):\n        for c in range(N):\n            if K > 0:\n                for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nr, nc = r+dr, c+dc\n                    if 0 <= nr < N and 0 <= nc < N and K > abs(dr)+abs(dc):\n                        dp[r][c] = max(dp[r][c], G[nr][nc]+dp[nr][nc])\n            else:\n                dp[r][c] = G[r][c]\n            \n            max_grass = max(max_grass, dp[r][c])\n    \n    print(max_grass)\n```\nTo run this code, you can save it in a file named `lazy.py`, then execute it using Python: `python lazy.py`. You can also input the sample data and see the output.", "time_gen": "\ntime generating: 8.550396s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=417": {"code": "```\n```\n```\n```python\ndef mooomoo():\n    N, B = map(int, input().split())\n    V = list(map(int, input() for _ in range(B)))\n    A = list(map(int, input() for _ in range(N)))\n    \n    dp = [0] * (N + 1)\n    for i in range(1, N + 1):\n        for j in range(B):\n            if V[j] <= A[i - 1]:\n                dp[i] = max(dp[i], dp[i - 1])\n            else:\n                dp[i] = max(dp[i], dp[i - 1] + 1)\n    \n    return min(N, min(dp)) if any(dp) else -1\n\nprint(mooomoo())\n```", "time_gen": "\ntime generating: 6.476373s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=418": {"code": "```\nimport math\n\ndef lazy_cow(n, k):\n    grasses = []\n    for _ in range(n):\n        g, x, y = map(int, input().split())\n        grasses.append((g, x, y))\n\n    max_grass = 0\n    for i in range(2000001):  # brute force search\n        for j in range(2000001):\n            total_grass = sum(g if math.hypot(i-x, j-y) <= k else 0 for g, x, y in grasses)\n            max_grass = max(max_grass, total_grass)\n\n    return max_grass\n\nn, k = map(int, input().split())\nprint(lazy_cow(n, k))\n```", "time_gen": "\ntime generating: 6.315081s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=419": {"code": "```python\ndef sabotage():\n    N = int(input())\n    milk_production = [0] * (N + 1)\n    for i in range(1, N + 1):\n        milk_production[i] = int(input())\n\n    total_milk = sum(milk_production[1:N-1])\n    min_avg = float('inf')\n    \n    left = right = 0\n    curr_sum = 0\n    for i in range(1, N - 1):\n        curr_sum += milk_production[i]\n        if i >= right:\n            right = i\n            while right + 1 <= N and curr_sum / (right - left + 1) < min_avg:\n                curr_sum -= milk_production[left]\n                left += 1\n            if i == right:\n                total_milk -= milk_production[right]\n            else:\n                total_milk -= milk_production[right] - milk_production[left]\n        if i >= N // 2 and (i == right or i < left):\n            min_avg = min(min_avg, curr_sum / (right - left + 1))\n    \n    avg = total_milk / (N - 2)\n    print(f\"{avg:.3f}\")\n```\nNote: The problem name is \"sabotage\" and the input format consists of N followed by a list of milk production for each machine.", "time_gen": "\ntime generating: 8.750474s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=420": {"code": "```\npython\nN = int(input())\nfriends = list(map(int, input().split() for _ in range(N)))\n\ncounts = {}\nfor friend in friends:\n    if friend in counts:\n        counts[friend] += 1\n    else:\n        counts[friend] = 1\n\ntotal_friends = sum(friends)\nodd = False\nfor count in counts.values():\n    if count % 2 != 0:\n        odd = True\n        break\n\nif not odd:\n    K = len([k for k, v in counts.items() if v == 1])\nelse:\n    K = total_friends - N*(N-1)//2\n\nprint(K)\npossible_friends = [i+1 for i in range(N) if friends[i] in counts and counts[friends[i]] == 1]\nprint(*possible_friends, sep='\\n')\n```", "time_gen": "\ntime generating: 6.739923s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=430": {"code": "Here is the Python solution for the problem:\n```\ndef odometer():\n    x, y = map(int, input().split())\n    count = 0\n    for i in range(x+1, y):\n        str_i = str(i)\n        if len(set(str_i.lstrip('0'))) == 1:\n            count += 1\n    print(count)\n\nodometer()\n```\nThis code reads the input values of `x` and `y`, then iterates over all numbers in the range from `x+1` to `y`. For each number, it converts the integer to a string, strips off leading zeros using the `lstrip('0')` method, and then uses the `set` data structure to get the unique digits. If there is only one unique digit (i.e., all digits are the same except for one), it increments the count. Finally, it prints out the total count of mooing events.", "time_gen": "\ntime generating: 6.44194s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=431": {"code": "```\n*problem_name: fairphoto*\n\n**input**\nN = int(input())\n\ncows = []\nfor i in range(N):\n    x, b = map(str, input().split())\n    cows.append((int(x), b))\n\n**solution**\nmax_size = 0\nleft = 0\ncount_guernsey = count_holstein = 0\n\nfor right in range(len(cows)):\n    if cows[right][1] == 'G':\n        count_guernsey += 1\n    else:\n        count_holstein += 1\n\n    while count_guernsey > count_holstein and left <= right:\n        if cows[left][1] == 'G':\n            count_guernsey -= 1\n        else:\n            count_holstein -= 1\n        left += 1\n\n    max_size = max(max_size, right - left + 1)\n\n**output**\nprint(max_size)\n```", "time_gen": "\ntime generating: 6.816582s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=432": {"code": "```\ndef decorate():\n    n, m = map(int, input().split())\n    graph = [[] for _ in range(n+1)]\n    \n    for _ in range(m):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    visited = [0] * (n + 1)\n    connected_components = 0\n    \n    for i in range(1, n+1):\n        if visited[i] == 0:\n            dfs(graph, visited, i)\n            connected_components += 1\n    \n    return max(0, connected_components - 1)\n\n\ndef dfs(graph, visited, node):\n    visited[node] = 1\n    for neighbor in graph[node]:\n        if visited[neighbor] == 0:\n            dfs(graph, visited, neighbor)\n\n\nif __name__ == \"__main__\":\n    print(decorate())\n```", "time_gen": "\ntime generating: 6.949807s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=433": {"code": "```\npython\nn = int(input())\npositions = []\nfor _ in range(n):\n    x, cow = input().split()\n    positions.append(int(x))\n    cow = cow[0]  # W or S\n    if cow == 'W':\n        is_spotted = False\n    else:\n        is_spotted = True\n\npositions.sort()\n\nwhite_cows = [i for i, (x, c) in enumerate(positions) if x == w and not c]\nspotted_cows = [i for i, (x, c) in enumerate(positions) if x == s]\n\nmin_position = positions[0]\nmax_position = positions[-1]\n\ntotal_spotted = sum(1 for _ in spotted_cows)\ntotal_white = len(white_cows)\n\nmin_spots = min(total_spotted, total_white)\nspots_to_add = max_spots - min_spots\n\nprint(max_position - min_position + 1 + spots_to_add)\n```", "time_gen": "\ntime generating: 7.111515s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=434": {"code": "```\npython\n```\n\n```markdow\nfrom heapq import heappop, heapreplace, heapify\ndef solve():\n    N, M = map(int, input().split())\n    graph = [[] for _ in range(N+1)]\n    times = [list(map(int, input().split())) for _ in range(M)]\n    for i, (A, B, P, Q) in enumerate(times):\n        graph[A].append((B, P))\n        graph[B].append((A, Q))\n\n    def dijkstra(start, end):\n        heap = [(0, start)]  # (time, intersection)\n        distances = [float('inf')] * (N+1)\n        distances[start] = 0\n        while heap:\n            time, node = heappop(heap)\n            if time > distances[node]:\n                continue\n            for neighbor, t in graph[node]:\n                new_time = time + t\n                if new_time < distances[neighbor]:\n                    distances[neighbor] = new_time\n                    heapreplace(heap, (new_time, neighbor))\n        return distances[end]\n\n    total_complaints = 0\n    for i in range(N):\n        start = 1\n        end = N\n        dist1, dist2 = dijkstra(start, i), dijkstra(i, end)\n        if dist1 != float('inf') and dist2 != float('inf'):\n            total_complaints += min(dist1, dist2) - (dist1 + dist2) // 2\n\n    print(total_complaints)\n```", "time_gen": "\ntime generating: 11.543983s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=435": {"code": "Here is the Python code to solve this problem:\n```\nx, y = map(int, input().split())\ncount = 0\nfor i in range(x+1, y):\n    digits = str(i)\n    if len(digits) % 2 == 1:\n        digits = digits[1:]\n    same = set(digits[0])\n    for d in digits:\n        same &= set(d)\n    if len(same) >= len(set(digits)) // 2:\n        count += 1\nprint(count + 2)\n```\nThis code takes the input `x` and `y` as integers, then loops through all numbers from `x+1` to `y`. For each number, it checks if at least half of its digits are the same. If so, it increments a counter. Finally, it prints the total count plus 2 (for the start and end points of the trip).", "time_gen": "\ntime generating: 6.205759s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=436": {"code": "```\ndef solve():\n    n, k = map(int, input().split())\n    breeds = {}\n    for _ in range(n):\n        x, b = map(int, input().split())\n        if b not in breeds:\n            breeds[b] = []\n        breeds[b].append(x)\n\n    max_size = -1\n    for breed, positions in breeds.items():\n        if len(positions) < k:\n            continue\n        positions.sort()\n        max_size = max(max_size, positions[-1] - positions[0])\n\n    print(max_size)\n\n\nif __name__ == \"__main__\":\n    solve()\n```", "time_gen": "\ntime generating: 5.438519s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=437": {"code": "```\nimport math\n\ndef get_possible_locations(n, bx, by, mirrors):\n    possible_locations = set()\n\n    for i in range(1, n + 1):\n        mirror_x, mirror_y, orientation = eval(\"({})\".format(mirrors[i]))\n\n        if orientation == '\\\\':\n            if mirror_y < by:\n                possible_locations.add((bx - (by - mirror_y), by))\n        elif orientation == '/':\n            if mirror_y > by:\n                possible_locations.add((bx + (mirror_y - by), by))\n\n    return len(possible_locations)\n\nn, bx, by = map(int, input().split())\nmirrors = []\nfor i in range(n):\n    mirrors.append(input().split())\n\nprint(get_possible_locations(n, bx, by, mirrors))\n```", "time_gen": "\ntime generating: 6.429132s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=438": {"code": "Here is the Python solution for the problem:\n```\nN, M = map(int, input().split())\nparent = [0] * N\nfor i in range(N-1):\n    parent[i+1] = int(input()) - 1\n\nrouted_out = set()\nfor _ in range(M):\n    v, s = input().split()\n    v, s = int(v), int(s)\n    for i in range(4):\n        routed_out.add(int(s) * (10 ** (3-i)) + parent[v])\n\nprint(len(routed_out) % 1234567)\n```", "time_gen": "\ntime generating: 5.468168s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=487": {"code": "Here is the Python solution:\n```\ndef min_distance(file_name):\n    with open(file_name, 'r') as f:\n        N = int(f.readline())\n        checkpoints = []\n        for _ in range(N):\n            x, y = map(int, f.readline().split())\n            checkpoints.append((x, y))\n\n    min_distance = float('inf')\n    for i in range(1, N - 1):\n        total_distance = 0\n        for j in range(N):\n            if j == i:\n                continue\n            dx = abs(checkpoints[i][0] - checkpoints[j][0])\n            dy = abs(checkpoints[i][1] - checkpoints[j][1])\n            total_distance += dx + dy\n        min_distance = min(min_distance, total_distance)\n\n    print(min_distance)\n```\nYou can run this code by saving it in a file named `marathon.py` and then running it with the command `python marathon.py marathon.in`. This will output the minimum distance that Bessie can run by skipping up to one checkpoint.", "time_gen": "\ntime generating: 7.859258s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=488": {"code": "```\npython\n```python\ndef get_clue_numbers(filename):\n    with open(filename, 'r') as f:\n        n, m = map(int, f.readline().split())\n        grid = [list(line.strip()) for line in f.readlines()]\n\n    clue_count = 0\n    clue_positions = []\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                is_left_blocked = (i > 0 and grid[i-1][j] == '#') or (j < m - 1 and j == 0)\n                is_right_clear = j < m - 1 and grid[i][j+1] == '.'\n                if is_left_blocked and is_right_clear:\n                    clue_count += 1\n                    clue_positions.append((i, j))\n\n    for i in range(m):\n        for j in range(n):\n            if grid[j][i] == '.':\n                is_above_blocked = (i > 0 and grid[j-1][i] == '#') or (j < n - 1 and j == 0)\n                is_below_clear = j < n - 1 and grid[j+1][i] == '.'\n                if is_above_blocked and is_below_clear:\n                    clue_count += 1\n                    clue_positions.append((j, i))\n\n    with open('crosswords.out', 'w') as f:\n        f.write(str(clue_count) + '\\n')\n        for position in sorted(set(clue_positions)):\n            f.write(str(position[0] + 1) + ' ' + str(position[1] + 1) + '\\n')\n\nif __name__ == '__main__':\n    get_clue_numbers('crosswords.in')```", "time_gen": "\ntime generating: 11.841532s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=489": {"code": "```\nimport sys\nn = int(input())\ncows = []\nfor _ in range(n):\n    pos, speed = map(int, input().split())\n    cows.append((pos, speed))\n\ncows.sort()\ngroups = 1\nlast_group = 0\nfor i in range(1, n):\n    if cows[i][0] - cows[i-1][0] > cows[i-1][1]:\n        groups += 1\n        last_group = i\n\nprint(groups)\n```", "time_gen": "\ntime generating: 3.63787s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=490": {"code": "```\nweights = []\nspot_cows = []\n\nwith open('learning.in', 'r') as f:\n    N, A, B = map(int, f.readline().split())\n    for _ in range(N):\n        line = f.readline().strip()\n        if line.startswith('S'):\n            weight, _ = map(int, line.split()[1:])\n            weights.append(weight)\n            spot_cows.append(True)\n        else:\n            weight, _ = map(int, line.split()[1:])\n            weights.append(weight)\n            spot_cows.append(False)\n\nweights.sort()\n\nans = 0\nfor w in range(A, B+1):\n    idx = binary_search(weights, w)\n    if spot_cows[idx]:\n        ans += 1\n\nprint(ans)\n\ndef binary_search(arr, target):\n    low, high = 0, len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return low\n```", "time_gen": "\ntime generating: 8.408279s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=491": {"code": "Here is a Python solution for this problem:\n```\nimport sys\nfrom collections import deque\n\ndef read_input():\n    B, E, P, N, M = map(int, sys.stdin.readline().split())\n    connections = [[] for _ in range(N+1)]\n    for _ in range(M):\n        a, b = map(int, sys.stdin.readline().split())\n        connections[a].append(b)\n        connections[b].append(a)\n    return B, E, P, N, M, connections\n\ndef bfs(B, E, P, N, connections):\n    visited = [[False] * N for _ in range(N)]\n    queue = deque([(1, 0), (2, 0)])\n    total_energy = [B, E]\n    for a, b in queue:\n        if a == 2 and b == N-1:\n            break\n        if not visited[a][b]:\n            if a == 2 or b == N-1:\n                total_energy[0] += B\n                total_energy[1] += E\n            else:\n                for c in connections[a][1:]:\n                    if c == b:\n                        continue\n                    if visited[c][b]:\n                        continue\n                    queue.append((c, b))\n            visited[a][b] = True\n    return min(total_energy)\n\nB, E, P, N, M, connections = read_input()\nprint(bfs(B, E, P, N, connections))\n```", "time_gen": "\ntime generating: 10.268461s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=492": {"code": "```\ndef calculate_distance(checkpoints):\n    total_distance = 0\n    x, y = checkpoints[0]\n    for i in range(1, len(checkpoints)):\n        new_x, new_y = checkpoints[i]\n        total_distance += abs(x - new_x) + abs(y - new_y)\n        x, y = new_x, new_y\n    return total_distance\n\n\ndef find_minimum_distance(N, K, checkpoints):\n    all_distances = []\n    for i in range(K + 1):\n        distances = [calculate_distance(checkpoints[:i] + checkpoints[i+1:])]\n        if i > 0:\n            for j in range(i):\n                distances.append(calculate_distance(checkpoints[:j] + checkpoints[j:i] + checkpoints[i+1:]))\n        all_distances.extend(distances)\n    return min(all_distances)\n\n\nN, K = [int(x) for x in open('marathon.in').read().strip().split()]\ncheckpoints = [list(map(int, line.split())) for line in open('marathon.in').readlines()[1:]]\n\nprint(find_minimum_distance(N, K, checkpoints))\n```", "time_gen": "\ntime generating: 7.739326s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=493": {"code": "```\nimport sys\nfrom collections import defaultdict\n\ninput = open('cowjog.in', 'r')\noutput = open('cowjog.out', 'w')\n\nn, t = map(int, input.readline().split())\npositions = []\nfor _ in range(n):\n    pos, speed = map(int, input.readline().split())\n    positions.append((pos, speed))\n\ngroups = defaultdict(list)\nfor i in range(n):\n    group = sum(1 for x in positions if x[0] <= positions[i][0] + positions[i][1]*t) - 1\n    groups[group].append(positions[i])\n\nfinal_groups = {}\nfor key in sorted(groups.keys()):\n    final_groups[key] = len(groups[key])\noutput.write(str(len(final_groups)) + '\\n')\n```", "time_gen": "\ntime generating: 5.3331s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=494": {"code": "```\n```\n\n```python\nN, H = map(int, input().split())\ncows = []\nfor _ in range(N):\n    h, w, s = map(int, input().split())\n    cows.append((h, w, s))\n\ncows.sort(reverse=True)\n\nmax_weight = 0\nmax_strength = 0\nfor cow in cows:\n    if cow[0] + max_weight > H:\n        break\n    max_weight += cow[1]\n    max_strength = min(max_strength, cow[2])\n\nif max_weight < H:\n    print(\"Mark is too tall\")\nelse:\n    print(max_strength)\n```", "time_gen": "\ntime generating: 4.701893s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=495": {"code": "```\n```\n\n```python\ndef calculate_distance(i, j):\n    return abs(checkpoints[i][0] - checkpoints[j][0]) + abs(checkpoints[i][1] - checkpoints[j][1])\n\nwith open('marathon.in', 'r') as f:\n    N, Q = map(int, f.readline().split())\n    global checkpoints\n    checkpoints = []\n    for _ in range(N):\n        x, y = map(int, f.readline().split())\n        checkpoints.append((x, y))\n\nqueries = []\nfor _ in range(Q):\n    query_type = f.readline().strip()\n    if query_type.startswith('U'):\n        i, x, y = map(int, query_type.split()[1:])\n        for j in range(N):\n            if j == i:\n                continue\n            checkpoints[i] = (x, y)\n        queries.append((None, None))\n    elif query_type.startswith('Q'):\n        i, j = map(int, query_type.split()[1:])\n        queries.append((i, j))\n\nwith open('marathon.out', 'w') as f:\n    for query in queries:\n        if query[0] is not None:\n            f.write(str(calculate_distance(query[0], query[1])) + '\\n')\n```", "time_gen": "\ntime generating: 9.048301s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=496": {"code": "```\ndef cow_jog():\n    N, T = [int(x) for x in input().split()]\n    positions = [[0, 0]] + [[*map(int, line.split())] for line in [input().split() for _ in range(N-1)]]\n    positions.sort()\n    lanes = 1\n    max_position = 0\n    for pos, speed in positions:\n        max_position += speed\n        if max_position > T:\n            break\n        while max_position > positions[lanes][0] + positions[lanes][1]:\n            lanes += 1\n    print(lanes)\n```", "time_gen": "\ntime generating: 4.548964s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=507": {"code": "```\ndef read_input():\n    A, B, N = map(int, input().split())\n    routes = []\n    for _ in range(N):\n        cost, length = map(int, input().split())\n        route = list(map(int, input().split()))\n        routes.append((cost, length, route))\n    return A, B, routes\n\ndef find_min_cost(A, B, routes):\n    min_cost = float('inf')\n    for cost, _, route in routes:\n        if route[0] == A and route[-1] == B:\n            min_cost = min(min_cost, cost)\n        elif route[0] == B and route[-1] == A:\n            min_cost = min(min_cost, cost)\n        else:\n            start = 0\n            for end in range(1, len(route)):\n                if route[end] == A or route[end] == B:\n                    break\n                if route[start] == A or route[start] == B:\n                    continue\n                if route[start] < A and route[end] > A:\n                    min_cost = min(min_cost, cost)\n                elif route[start] > A and route[end] < A:\n                    min_cost = min(min_cost, cost)\n    return -1 if min_cost == float('inf') else min_cost\n\nA, B, routes = read_input()\nprint(find_min_cost(A, B, routes))\n```", "time_gen": "\ntime generating: 10.256728s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=508": {"code": "```\ndef cow_routing():\n    N = int(input())\n    routes = []\n    for _ in range(N):\n        cost, cities = map(int, input().split()), list(map(int, input().split()))\n        routes.append((cost, cities))\n\n    A, B, min_cost = map(int, input().split())\n\n    dp = [[float('inf')] * (B + 1) for _ in range(A + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, A + 1):\n        for j in range(1, B + 1):\n            for route in routes:\n                cost, cities = route\n                if len(cities) > 1 and cities[0] == i and cities[-1] <= j:\n                    dp[i][j] = min(dp[i][j], dp[cities[0]][cities[-1]] + cost)\n\n    return -1 if dp[A][B] == float('inf') else dp[A][B]\n\nprint(cow_routing())\n```", "time_gen": "\ntime generating: 7.918434s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=509": {"code": "```\npython\ndef what_base():\n    k = int(open('whatbase.in', 'r').readline())\n    for _ in range(k):\n        n1, n2 = map(int, open('whatbase.in', 'r').readline().strip().split())\n        max_b = 10000\n        for b1 in range(10, max_b+1):\n            for b2 in range(10, max_b+1):\n                if convert_base(n1, b1) == convert_base(n2, b2):\n                    print(b1, b2)\n                    break\n\ndef convert_base(n, base):\n    conv_table = \"0123456789ABCDEF\"\n    if n < base:\n        return conv_table[n]\n    else:\n        return convert_base(n//base, base) + conv_table[n%base]\n\nwhat_base()\n```", "time_gen": "\ntime generating: 7.401804s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=510": {"code": "```\nimport heapq\n\ndef meeting_time():\n    N, M = map(int, input().split())\n    paths = []\n    for _ in range(M):\n        A, B, C, D = map(int, input().split())\n        if A > B:\n            A, B = B, A\n            C, D = D, C\n        paths.append((C, D))\n    \n    pq = [(0, 1)]  # (time, field)\n    visited = set()\n    while pq:\n        time, field = heapq.heappop(pq)\n        if field == N:\n            return time\n        \n        if field in visited:\n            continue\n        visited.add(field)\n        \n        for C, D in paths:\n            next_time = time + min(C, D)  # Bessie travels faster than Elsie\n            next_field = A\n            if field < A:\n                next_time += (A - field) * 2  # travel up to the path\n                next_field = A\n            elif field > B:\n                next_time += (field - B)  # travel down from the path\n                next_field = B\n            else:  # we're on the path\n                if C < D:\n                    next_time += (B - field)\n                    next_field = B\n                else:\n                    next_time += (A - field)\n                    next_field = A\n            \n            heapq.heappush(pq, (next_time, next_field))\n    \n    return \"IMPOSSIBLE\"\n\nprint(meeting_time())\n```", "time_gen": "\ntime generating: 10.567309s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=511": {"code": "```\npython\nfrom bisect import bisect_left\n\nn = int(input())\ncows = []\nfor _ in range(n):\n    x, y, r = map(int, input().split())\n    cows.append((y, x, r))\n\ncows.sort()\nans = 0\nmax_y = -1e9\nfor i in range(n):\n    if cows[i][0] > max_y:\n        ans += 1\n        max_y = cows[i][2] * (i // cows[i][2]) + cows[i][1]\n\nprint(ans)\n```", "time_gen": "\ntime generating: 4.987888s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=512": {"code": "```\ndef cow_routing():\n    A, B, N = map(int, input().split())\n    \n    routes = []\n    for _ in range(N):\n        cost, route_len = map(int, input().split())\n        route = list(map(int, input().split()))\n        \n        for i in range(1, route_len):\n            routes.append((cost, route[0], route[i-1], route[i]))\n    \n    dp = [[float('inf'), float('inf')] for _ in range(B+1)]\n    dp[A][A] = 0\n    \n    for k in range(A+1, B+1):\n        for i in range(k):\n            for j in range(1, len(routes)):\n                if routes[j][2] == i and routes[j][3] == k:\n                    dp[k][k-1] = min(dp[k][k-1], dp[i][i-1] + routes[j][0])\n    \n    if dp[B][A] != float('inf'):\n        return \"{} {}\".format(dp[B][A], (dp[B][A] - 1) // max(routes, key=lambda x: x[0])[0] + 1)\n    else:\n        return \"-1 -1\"\n```", "time_gen": "\ntime generating: 9.102485s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=513": {"code": "```\nimport heapq\n\nN, M = map(int, input().split())\n\ngraph = {}\nfor _ in range(M):\n    a, b, ca, da = map(int, input().split())\n    if a not in graph:\n        graph[a] = []\n    if b not in graph:\n        graph[b] = []\n    graph[a].append((b, ca))\n    graph[b].append((a, da))\n\ndist = {i: float('inf') for i in range(1, N+1)}\npq = [(0, 1)]\nwhile pq:\n    d, node = heapq.heappop(pq)\n    if d > dist[node]:\n        continue\n    for neighbor, ca in graph.get(node, []):\n        c = d + ca\n        if c < dist[neighbor]:\n            dist[neighbor] = c\n            heapq.heappush(pq, (c, neighbor))\n\nif dist[N] == float('inf'):\n    print(\"IMPOSSIBLE\")\nelse:\n    print(dist[N])\n```", "time_gen": "\ntime generating: 7.679869s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=514": {"code": "```markdown\n```\n```\nimport sys\nfrom collections import defaultdict\n\ndef cow_rectangles():\n    N = int(sys.stdin.readline())\n    cows = [defaultdict(int) for _ in range(N)]\n    max_holsteins = 0\n    min_area = float('inf')\n\n    for i in range(N):\n        x, y, breed = map(int, sys.stdin.readline().split())\n        if breed == 'H':\n            cows[i][x] += 1\n            cows[i][y] += 1\n\n    for cow in cows:\n        if (len(cow) > max_holsteins):\n            max_holsteins = len(cow)\n        area = sum((max(row.values()) - min(row.values())) * count for row, count in cow.items())\n        if (area < min_area):\n            min_area = area\n\n    print(max_holsteins, min_area)\n\ncow_rectangles()\n```", "time_gen": "\ntime generating: 6.359298s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=515": {"code": "```\nimport heapq\nN, L = map(int, open(\"movie.in\", \"r\").readline().split())\nmovies = []\nfor _ in range(N):\n    duration, num_showtimes = map(int, open(\"movie.in\", \"r\").readline().split())\n    showtimes = list(map(int, open(\"movie.in\", \"r\").readline().split()))\n    movies.append((showtimes[0], duration, num_showtimes))\nmovies.sort(key=lambda x: x[0])\n\nqueue = [(0, 0)]\nans = 0\ntotal_time = 0\n\nwhile queue and total_time < L:\n    time, idx = heapq.heappop(queue)\n    if time >= L:\n        break\n    movie_time, duration, num_showtimes = movies[idx]\n    if time + movie_time <= L:\n        ans += 1\n        total_time += movie_time\n        if idx < N - 1 and movies[idx+1][0] > time:\n            heapq.heappush(queue, (movies[idx+1][0], idx+1))\n    else:\n        remaining_time = L - time\n        if remaining_time <= duration:\n            ans += 1\n            total_time += duration\n        else:\n            ans += 1\n            total_time += duration - (remaining_time % duration)\n        heapq.heappush(queue, ((time + duration) % movies[idx][0], idx))\nprint(-1 if queue or total_time < L else ans)\n```", "time_gen": "\ntime generating: 9.907817s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=516": {"code": "```\nimport heapq\nfrom collections import defaultdict\n\nn, m = map(int, open('grass.in').readline().split())\ngraph = defaultdict(list)\nfor _ in range(m):\n    a, b = map(int, open('grass.in').readline().split())\n    graph[a].append(b)\n\ndef bfs():\n    visited = set()\n    pq = [(1, 0)] # (node, count of nodes reached)\n    max_count = 0\n    while pq:\n        node, count = heapq.heappop(pq)\n        if node not in visited:\n            visited.add(node)\n            max_count = max(max_count, count + 1)\n            for neighbor in graph[node]:\n                if neighbor == 1: continue\n                heapq.heappush(pq, (neighbor, count + 1))\n    return max_count\n\nprint(bfs())\n```", "time_gen": "\ntime generating: 7.028298s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=526": {"code": "```\ndef censor(S, T):\n    res = S\n    while T in res:\n        pos = res.index(T)\n        res = res[:pos] + res[pos+len(T):]\n    return res\n\nS = input()\nT = input()\n\nprint(censor(S, T))```", "time_gen": "\ntime generating: 2.774164s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=527": {"code": "```\nn = int(input())\ns = input()\ncow_count = 0\nlast_c = -1\nfor i in range(n):\n    if s[i] == 'C':\n        last_c = i\n    elif s[i] == 'O' and i >= last_c:\n        cow_count += (i - last_c) // 3 + 1\n        last_c = i\n    elif s[i] == 'W' and i >= last_c:\n        if i - last_c > 2:\n            cow_count += (i - last_c) // 4 + ((i - last_c) % 4) // 3 * (i - last_c > 6)\nprint(cow_count)\n```", "time_gen": "\ntime generating: 4.953309s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=528": {"code": "```\ndef hopscotch(r, c, grid):\n    dp = [[0] * (c + 1) for _ in range(r + 1)]\n\n    dp[0][0] = 1\n    for i in range(1, r + 1):\n        for j in range(c + 1):\n            if i < r or j < c:\n                if i > 0 and grid[i - 1][j] != grid[i][j]:\n                    dp[i][j] += dp[i - 1][min(j, c)]\n                if j > 0 and grid[i][j - 1] != grid[i][j]:\n                    dp[i][j] += dp[max(0, i), j - 1]\n    return dp[r][c]\n\nr, c = map(int, open('hopscotch.in', 'r').read().strip().split())\ngrid = [list(line) for line in open('hopscotch.in', 'r').read().strip().split('\\n')]\nprint(hopscotch(r, c, grid))\n```", "time_gen": "\ntime generating: 7.067432s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=529": {"code": "```\ndef censor(S, T):\n    S = list(S)\n    while T in S:\n        start = S.index(T)\n        S.pop(start)\n    return ''.join(S)\n\nS = input()\nT = input()\n\nprint(censor(S, T))\n```", "time_gen": "\ntime generating: 2.543422s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=530": {"code": "```\ndef count_jumps(R, C, K):\n    # Initialize a memoization table with all values being -1\n    memo = [[-1 for _ in range(K+1)] for _ in range(R+C)]\n\n    def dfs(i, j, label):\n        if i == R and j == C:\n            return 1\n        if memo[i][label] != -1:\n            return memo[i][label]\n        \n        result = 0\n        for k in range(1, K+1):\n            if (k != label and \n                i+1 <= R and j+1 <= C and \n                int((i+j)/2) < label and \n                label > k):\n                result += dfs(i+1, j+1, k)\n        memo[i][label] = result % 1000000007\n        return result\n\n    total_count = 0\n    for i in range(R):\n        for j in range(C):\n            if (i == 0 and j == 0) or (int((i+j)/2) < K):\n                total_count += dfs(i, j, int((R+C-1)/2))\n    \n    return total_count\n\n# Read input\nR, C, K = map(int, raw_input().split())\n\ngrid = []\nfor i in range(R):\n    grid.append(map(int, raw_input().split()))\n\nprint(count_jumps(R, C, K))\n\n```", "time_gen": "\ntime generating: 9.379271s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=531": {"code": "```\nfrom itertools import permutations\nfrom functools import reduce\nfrom operator import xor\n\nn = int(input())\n\nteam_ids = [int(input()) for _ in range(n)]\n\nmax_points = 0\nfor p in permutations(team_ids, n-1):\n    points = sum([p[i] ^ p[i+1] for i in range(n-1)])\n    max_points = max(max_points, points)\n\nprint(max_points)\n```", "time_gen": "\ntime generating: 4.205557s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=532": {"code": "```\ndef cow_hops(R, C, K):\n    grid = [list(map(int, input().split())) for _ in range(R)]\n    \n    def dfs(r, c, prev_num, dp):\n        if r == R-1 and c == C-1:\n            return 1\n        \n        count = 0\n        for dr, dc in [(-1, 0), (0, -1)]:\n            nr, nc = r + dr, c + dc\n            \n            if 0 <= nr < R and 0 <= nc < C and grid[nr][nc] != prev_num:\n                count += dp(nr, nc, grid[nr][nc])\n        \n        return count % 1000000007\n    \n    return dfs(0, 0, -1, lambda r, c, num: 1 if r == R-1 and c == C-1 else 0)\n```", "time_gen": "\ntime generating: 6.241467s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=533": {"code": "Here is a Python solution for the problem:\n\n```\ndef censor(S, t):\n    while True:\n        found = False\n        start = -1\n        for i in range(len(S)):\n            for j in range(len(t)):\n                if S[i+j] == t[j]:\n                    if start == -1:\n                        start = i\n                    else:\n                        break\n            else:\n                continue\n            break\n        if start != -1:\n            S = S[:start] + S[start+len(t):]\n            found = True\n        if not found:\n            break\n    return S\n\nS = input()\nN = int(input())\nt = []\nfor i in range(N):\n    t.append(input())\n\nprint(censor(S, ''.join(t)))\n```", "time_gen": "\ntime generating: 5.442154s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=534": {"code": "```\nN, Q = map(int, input().split())\npoints = [list(map(int, input().split())) for _ in range(N)]\nqueries = []\nfor _ in range(Q):\n    query = list(map(int, input().split()))\n    if len(query) == 3:\n        a, b, c = query\n        queries.append((a, b, c))\n    else:\n        x, y = query[1:]\n        points.append([x, y])\n\ndef check_fence(a, b, c):\n    left = [point for point in points if (a * point[0] + b * point[1] - c) <= 0]\n    right = [point for point in points if (a * point[0] + b * point[1] - c) > 0]\n    return len(left) == 0 or len(right) == 0\n\nfor query in queries:\n    if len(query) == 3:\n        print(\"YES\" if check_fence(*query) else \"NO\")\n    else:\n        x, y = query[1:]\n        left = [point for point in points if (2 * point[0] + 2 * point[1] - 3) <= 0]\n        right = [point for point in points if (2 * point[0] + 2 * point[1] - 3) > 0]\n        print(\"YES\" if len(left) == 0 or len(right) == 0 else \"NO\")\n```", "time_gen": "\ntime generating: 11.338266s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=545": {"code": "```\n```\n\n```python\ndef max_moons(N, M, puzzle):\n    count = 0\n    for i in range(N):\n        for j in range(M):\n            if puzzle[i][j] == 'M':\n                count += 1\n    return count\n\nN, M = [int(i) for i in open('moocrypt.in').read().split()]\npuzzle = [list(line.strip()) for line in open('moocrypt.in').readlines()[:N]]\nprint(max_moons(N, M, puzzle))\n```", "time_gen": "\ntime generating: 4.546039s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=546": {"code": "```\nimport itertools\n\ndef geteven():\n    N = int(input().strip())\n    variables = {}\n    for _ in range(N):\n        var, value = input().split()\n        variables[var] = [int(x) for x in str(value).split(\",\")]\n    \n    total_count = 0\n    for values in itertools.product(*[v for v in variables.values()]):\n        expression_values = {k: v[0] for k, v in zip(variables.keys(), values)}\n        if eval('({}+{}+{}+{}+{}+{})*({}+{}+{})*(1+{})'.format(*[str(expression_values[v]) for v in 'BESSIEMOG'])) % 2 == 0:\n            total_count += 1\n    \n    print(total_count)\n\ngeteven()\n```", "time_gen": "\ntime generating: 6.611745s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=547": {"code": "Here is the Python solution for the problem:\n\n```\nn = int(input())\ntotal_area = 0\nleftmost = float('inf')\nrightmost = float('-inf')\n\nfor _ in range(n):\n    size, pos = map(int, input().split())\n    leftmost = min(leftmost, pos)\n    rightmost = max(rightmost, pos)\n\n    if size < rightmost - leftmost + 1:\n        total_area += (size - 1) * 2\n    else:\n        total_area += rightmost - leftmost + 1\n\nprint(total_area)\n```", "time_gen": "\ntime generating: 4.854818s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=548": {"code": "```\nn = int(input())\ngrid = []\nfor i in range(n):\n    row = input()\n    grid.append(row)\n\npalindromes = set()\n\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef generate_palindrome(i, j, path):\n    if i >= n or j >= n:\n        palindromes.add(path)\n        return\n    for direction in [(0, 1), (1, 0)]:\n        new_i = i + direction[0]\n        new_j = j + direction[1]\n        if 0 <= new_i < n and 0 <= new_j < n:\n            generate_palindrome(new_i, new_j, path + grid[new_i][new_j])\n\nfor i in range(n):\n    for j in range(n):\n        generate_palindrome(i, j, grid[i][j])\n\nprint(len(palindromes))\n```", "time_gen": "\ntime generating: 6.325015s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=549": {"code": "```\nimport sys\nfrom functools import lru_cache\n\nN = int(input())\nvar_values = {}\nfor _ in range(N):\n    var, val = input().split()\n    if var not in var_values:\n        var_values[var] = []\n    var_values[var].append(int(val))\n\n@lru_cache(None)\ndef solve(var_vals):\n    if len(var_vals) == 7:\n        return int(eval(''.join(str(v) for v in var_vals)) % 7)\n    else:\n        total_ways = 0\n        for val in set(var_values[var]):\n            new_var_vals = var_vals + [val]\n            ways = solve(new_var_vals)\n            if ways is not None:\n                total_ways += ways\n        return total_ways\n\nprint(solve([]))\n```", "time_gen": "\ntime generating: 6.137376s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=550": {"code": "```\nfrom bisect import bisect_left\n\nN = int(input())\nB = int(input())\n\nbales = []\nfor _ in range(N):\n    size, pos = map(int, input().split())\n    bales.append((pos, size))\n\nif len(bales) < 2:\n    print(-1)\nelse:\n    leftmost = bales[0][1]\n    rightmost = bales[-1][1]\n\n    if B > rightmost and B + N > leftmost:\n        idx = bisect_left(bales, (B,))\n        if idx == len(bales):\n            add_to_bale = max(0, rightmost - leftmost + 1)\n        elif idx == 0:\n            add_to_bale = max(0, leftmost - B)\n        else:\n            left_pos, left_size = bales[idx-1]\n            right_pos, right_size = bales[idx]\n            if B > right_pos:\n                add_to_bale = max(0, B - right_pos + 1)\n            elif B < left_pos:\n                add_to_bale = max(0, left_pos - B)\n\n        print(add_to_bale)\n```", "time_gen": "\ntime generating: 9.023579s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=551": {"code": "```\ndef maximum_energy_quality(n, edges, qualities):\n    visited = [False] * (n + 1)\n    max_energy = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            stack = [i]\n            current_quality = qualities[i - 1]\n\n            while stack:\n                node = stack.pop()\n                visited[node] = True\n\n                for neighbor in edges[node]:\n                    if not visited[neighbor]:\n                        stack.append(neighbor)\n                    else:\n                        max_energy[neighbor] = max(max_energy[neighbor], max_energy[node] + (qualities[neighbor - 1] - current_quality))\n\n    return max(max_energy)\n\nn, e = map(int, input().split())\nedges = [[] for _ in range(n + 1)]\nqualities = list(map(int, input() for _ in range(n)))\n\nfor i in range(e):\n    u, v = map(int, input().split())\n    edges[u].append(v)\n    edges[v].append(u)\n\nprint(maximum_energy_quality(n, edges, qualities))\n```", "time_gen": "\ntime generating: 7.871919s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=552": {"code": "```\ndef get_children(employee_id):\n    while True:\n        children = int(input())\n        if children == 0:\n            return None\n        left, right = map(int, input().split())\n        if (left, right) == (-1, -1):  # special case for CEO\n            return (None, None)\n        yield (left, right)\n\ndef find_n():\n    n = 0\n    parent = None\n    for children in get_children(1):\n        parent = n\n        n += 2\n        if children:\n            yield from ((n - 1) * 2 + child[0] for child in children)\n            yield from ((n - 1) * 2 + child[1] for child in children)\n\n    return parent\n\nprint(\"Answer \" + str(next(find_n())))\n```", "time_gen": "\ntime generating: 6.954995s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=553": {"code": "```\nfrom collections import Counter\n\nN = int(input())\ngrid = [input().strip() for _ in range(N)]\nn = N * N\n\n# Initialize the dynamic programming table\ndp = [[0] * (n + 1) for _ in range(n + 1)]\n\n# Base case: a single character is always a palindrome\nfor i in range(1, n + 1):\n    dp[i][i] = 1\n\n# Fill up the table using dynamic programming\nfor length in range(2, n + 1):\n    for i in range(n - length + 1):\n        j = i + length - 1\n        if grid[0][i] == grid[0][j]:\n            dp[i][j] = dp[i + 1][j - 1] + 1\n        else:\n            dp[i][j] = dp[i][j - 1] + dp[i + 1][j]\n\n# Count the number of distinct palindromes\ntotal_palindromes = 0\n\nfor i in range(1, n):\n    for j in range(n - 1, i - 1, -1):\n        if grid[0][i] == grid[0][j]:\n            break\n        total_palindromes += dp[i][j]\n\nprint((total_palindromes + 1) % 1000000007)\n```", "time_gen": "\ntime generating: 9.600633s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=554": {"code": "Here is the Python solution for the problem:\n```\nn = int(input())\ntotal_area = 0\nleftmost = float('inf')\nrightmost = float('-inf')\n\nfor _ in range(n):\n    s, p = map(int, input().split())\n    leftmost = min(leftmost, p)\n    rightmost = max(rightmost, p + s)\n\nif leftmost < rightmost:\n    total_area += (leftmost - 1) * (rightmost - leftmost)\nelse:\n    total_area = 0\n\nprint(total_area)\n```", "time_gen": "\ntime generating: 4.105943s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=567": {"code": "```\nmax_length = max(b, d)\nmin_length = min(a, c)\ntotal_length = (max_length - min_length) + abs(min(c, a) - max(d, b))\nprint(total_length)\n```", "time_gen": "\ntime generating: 2.630479s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=568": {"code": "```\n```\npython\n```\n```python\ndef speeding(input_file):\n    with open(input_file, 'r') as f:\n        N, M = map(int, f.readline().split())\n        road_segments = []\n        for _ in range(N):\n            length, speed_limit = map(int, f.readline().split())\n            road_segments.append((length, speed_limit))\n        \n        bessie_segments = []\n        for _ in range(M):\n            length, speed = map(int, f.readline().split())\n            bessie_segments.append((length, speed))\n\n    total_length = sum(length for length, _ in road_segments)\n    max_speed_over = 0\n\n    current_segment_index = 0\n    current_bessie_index = 0\n    current_time = 0.0\n\n    while True:\n        if current_segment_index >= N or current_bessie_index >= M:\n            break\n        \n        if road_segments[current_segment_index][1] < bessie_segments[current_bessie_index][1]:\n            current_segment_length, _ = road_segments[current_segment_index]\n            current_segment_speed_limit = road_segments[current_segment_index][1]\n\n            while True:\n                if current_time + (current_segment_length / float(current_segment_speed_limit)) > 100.0:\n                    break\n                current_time += (current_segment_length / float(current_segment_speed_limit))\n                current_segment_index += 1\n        else:\n            current_segment_length, speed = bessie_segments[current_bessie_index]\n            while True:\n                if current_time + current_segment_length / float(speed) > 100.0:\n                    break\n                current_time += current_segment_length / float(speed)\n                current_bessie_index += 1\n\n        max_speed_over = max(max_speed_over, abs(current_time - int(current_time)))\n\n    return str(int(max_speed_over))\n```\n\nTo run this code:\n\n```shell\npython speeding.py speeding.in > speeding.out\n```", "time_gen": "\ntime generating: 13.336868s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=569": {"code": "```\npython\n# Read input\nN, M, D, S = map(int, open('badmilk.in', 'r').read().split()[:4])\ndrink_times = []\nsick_times = []\n\n# Read drink times and sick times\nfor _ in range(D):\n    p, m, t = map(int, open('badmilk.in', 'r').read().split()[:3])\n    drink_times.append((p, m, t))\n\nfor _ in range(S):\n    p, t = map(int, open('badmilk.in', 'r').read().split()[:2])\n    sick_times.append((p, t))\n\n# Create a dictionary to store the drinks for each person\ndrinks = {}\nfor p, m, t in drink_times:\n    if p not in drinks:\n        drinks[p] = []\n    drinks[p].append(m)\n\n# Create a set to store the people who got sick and the time they got sick\nsick_people = set()\nfor p, t in sick_times:\n    sick_people.add(p)\n\n# Initialize the minimum medicine dose needed\nmin_dose = 0\n\n# Iterate over each milk type\nfor i in range(1, M + 1):\n    # Count the people who drank this milk and got sick\n    bad_milk_sick = sum([p for p, m in drinks.items() if m.count(i) > 0 and p in sick_people])\n    \n    # If all sick people drank this milk, increment min_dose by 1\n    if bad_milk_sick == len(sick_people):\n        min_dose += 1\n\n# Print the minimum medicine dose needed\nprint(min_dose)\n```", "time_gen": "\ntime generating: 13.957034s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=570": {"code": "```\nfrom collections import deque\n\ndef lightson():\n    N, M = map(int, input().split())\n    graph = [[0]*N for _ in range(N)]\n    for _ in range(M):\n        x, y, a, b = map(int, input().split())\n        if (x,y) != (a,b):\n            graph[x-1][y-1] = [(a-1, b-1)]\n\n    visited = set()\n    queue = deque([(0, 0)])\n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x+dx, y+dy\n            if 0 <= nx < N and 0 <= ny < N and (nx, ny) not in visited:\n                if graph[x][y]:\n                    for i, j in graph[x][y]:\n                        queue.append((i,j))\n                visited.add((nx, ny))\n    return len(visited)\n\nprint(lightson())\n```", "time_gen": "\ntime generating: 7.939653s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=571": {"code": "```\nimport sys\n\nN = int(input())\nElsie_cards = list(map(int, [input() for _ in range(N)]))\nBessie_cards = sorted([i for i in range(1, 2*N+1) if i not in Elsie_cards])\n\nmax_points = 0\ncurrent_card = 0\n\nfor card in sorted(Elsie_cards):\n    while Bessie_cards and Bessie_cards[0] < card:\n        current_card += 1\n    max_points += (Bessie_cards.pop(0) >= card)\n\nprint(max_points)\n```", "time_gen": "\ntime generating: 4.855037s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=572": {"code": "```\nfrom collections import defaultdict\n\nn, q = map(int, input().split())\nbreeds = defaultdict(int)\n\nfor _ in range(n):\n    breeds[int(input())] += 1\n\nfor _ in range(q):\n    a, b = map(int, input().split())\n    print(*[breeds[1], breeds[2]-breeds[1], breeds[3]-breeds[2]])\n```", "time_gen": "\ntime generating: 6.39333s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=573": {"code": "```\nimport sys\n\nn = int(sys.stdin.readline())\nelsie_cards = [int(line) for line in sys.stdin.readlines()]\n\nbessie_cards = sorted(set(elsie_cards))\n\nmax_points = 0\nfor i in range(n // 2):\n    if bessie_cards[i * 2] > elsie_cards[i]:\n        max_points += 1\n    elif bessie_cards[i * 2] < elsie_cards[i]:\n        max_points += -1\n\nprint(max_points)\n```", "time_gen": "\ntime generating: 8.264935s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=574": {"code": "```\nimport sys\ndef feast():\n    T, A, B = map(int, input().split())\n    return min(T, A + (T - B) // (A - B))\nprint(feast())\n```", "time_gen": "\ntime generating: 3.55819s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=575": {"code": "```\nimport sys\n\ndef bfs(maze):\n    N, M = len(maze), len(maze[0])\n    queue = [(0, 0, 0)]  # (row, col, smell)\n    visited = {(0, 0)}\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    smell_map = {(N-1, M-1): True}\n\n    while queue:\n        row, col, smell = queue.pop(0)\n        if (row, col) == (N-1, M-1):\n            return get_moves(maze, visited)\n\n        for dr, dc in directions:\n            nr, nc = row + dr, col + dc\n            if 0 <= nr < N and 0 <= nc < M and (nr, nc) not in visited:\n                if maze[nr][nc] == 1:  # pink tile\n                    queue.append((nr, nc, smell))\n                    visited.add((nr, nc))\n                elif maze[nr][nc] == 2:  # orange tile\n                    if smell:\n                        queue.append((nr, nc, 0))  # reset smell\n                    else:\n                        continue\n                elif maze[nr][nc] == 3:  # blue tile\n                    if smell:\n                        queue.append((nr, nc, smell))\n                        visited.add((nr, nc))\n                    else:\n                        continue\n                elif maze[nr][nc] == 4:  # purple tile\n                    slide = True\n                    while 0 <= nr < N and 0 <= nc < M and maze[nr][nc] == 4:\n                        nr, nc = nr + dr, nc + dc\n                    if (nr, nc) not in visited:\n                        queue.append((nr, nc, 0))  # reset smell\n                        visited.add((nr, nc))\n                    else:\n                        continue\n\n    return -1\n\ndef get_moves(maze, visited):\n    moves = []\n    row, col = N-1, M-1\n    while (row, col) != (0, 0):\n        if maze[row][col] == 1:  # pink tile\n            moves.append((row, col))\n        elif maze[row][col] == 2:  # orange tile\n            moves.extend([(i, j) for i in range(row, -1, -1) if maze[i][j] != 4])\n        elif maze[row][col] == 3:  # blue tile\n            while row > 0 and maze[row-1][col] == 2:\n                row -= 1\n            moves.extend([(i, col) for i in range(row, -1, -1)])\n        elif maze[row][col] == 4:  # purple tile\n            slide = True\n            while 0 <= row < N and 0 <= col < M and maze[row][col] == 4:\n                row += dr\n                col += dc\n            if (row, col) != (N-1, M-1):\n                moves.append((row, col))\n    return len(moves)\n\nif __name__ == \"__main__\":\n    N, M = map(int, sys.stdin.readline().split())\n    maze = [map(int, sys.stdin.readline().split()) for _ in range(N)]\n    print(bfs(maze))\n```", "time_gen": "\ntime generating: 38.210318s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=576": {"code": "```\nfrom collections import defaultdict, deque\n\nN, K = map(int, input().split())\nG = defaultdict(dict)\nfor _ in range(N - 1):\n    u, v = map(int, input().split())\n    G[u][v] = G[v].setdefault(u, 0) + 1\n    G[v][u] = G[u].setdefault(v, 0) + 1\n\nmax_flow = 0\nfor _ in range(K):\n    s, t = map(int, input().split())\n    G[s][t] -= 1\n    G[t][s] += 1\n    max_flow += 1\n\nprint(max_flow)\n```", "time_gen": "\ntime generating: 9.231081s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=577": {"code": "Here is the Python code for this problem:\n```\nN = int(input())\n\nelsie_cards = list(map(int, input().split()[:N]))\n\nmax_points = 0\npoints = 0\n\nfor i in range(N):\n    if elsie_cards[i] > points + 1:\n        points += 1\n    else:\n        if points > max_points:\n            max_points = points\n        points = 0\n\nprint(max_points)\n```", "time_gen": "\ntime generating: 6.818089s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=578": {"code": "Here is the solution to this problem:\n\n```markdown\nimport sys\n\nN, Q = map(int, input().split())\nfields = list(map(int, input().split()))\nfor _ in range(Q):\n    op = input().split()[0]\n    if op == 'M':\n        print(min(fields[A-1:B]))\n    elif op == 'P':\n        for i in range(A-1, B):\n            fields[i] += C\n    elif op == 'S':\n        print(sum(fields[A-1:B]))\n```", "time_gen": "\ntime generating: 8.194189s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=591": {"code": "```\nfrom io import open\n\nbr = int(open('promote.in', 'r').readline().split()[1])\nbs = int(open('promote.in', 'r').readline().split()[1])\nsg = int(open('promote.in', 'r').readline().split()[1])\nsp = int(open('promote.in', 'r').readline().split()[1])\n\nprint(br - bs)\nprint(bs - bg)\nprint(gg - gp)\n```", "time_gen": "\ntime generating: 7.351418s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=592": {"code": "```\nimport heapq\nn = int(input())\nheap = []\nmax_explosions = 0\nfor i in range(n):\n    x = int(input())\n    if len(heap) == 0 or x >= heap[0]:\n        heapq.heappush(heap, x)\n    else:\n        while len(heap) > 1 and heap[0] <= x - (i+1):\n            heapq.heappop(heap)\n        heapq.heappush(heap, x)\n    max_explosions = max(max_explosions, i+1 + len(heap))\nprint(max_explosions)\n```", "time_gen": "\ntime generating: 8.91243s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=593": {"code": "```\ndef mowing(x, directions):\n    x_max = x\n    for direction, steps in directions:\n        if direction == 'N':\n            max_y = 0\n        elif direction == 'S':\n            max_y = 10\n        elif direction == 'E':\n            max_x = 0\n        elif direction == 'W':\n            max_x = 10\n        for _ in range(steps):\n            if direction == 'N' and max_y > 5:\n                return -1\n            elif direction == 'S' and max_y < 5:\n                return -1\n            elif direction == 'E' and max_x > 5:\n                return -1\n            elif direction == 'W' and max_x < 5:\n                return -1\n            if direction == 'N':\n                max_y += 1\n            elif direction == 'S':\n                max_y -= 1\n            elif direction == 'E':\n                max_x += 1\n            elif direction == 'W':\n                max_x -= 1\n    return x_max\n\nn = int(input())\ndirections = []\nfor _ in range(n):\n    d, s = input().split()\n    directions.append((d, int(s)))\nx = mowing(0, directions)\nprint(x)\n```", "time_gen": "\ntime generating: 16.134312s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=594": {"code": "```\nimport sys\nN, K = map(int, sys.stdin.readline().split())\nx = sorted(map(int, (sys.stdin.read().split())))\nr = 0\nwhile len(set((i-x[j]) for i in x for j in range(len(x)))) > K:\n    r += 1\nprint(r)\n```", "time_gen": "\ntime generating: 5.359524s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=595": {"code": "```\nn = int(input())\ns = 0\nmax_len = 0\nfor _ in range(n):\n    s += int(input())\n    if s % 7 == 0:\n        max_len = max(max_len, len(str(s)) - len(str(int(s//7*7))))\n```", "time_gen": "\ntime generating: 4.831065s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=596": {"code": "```\n```\n```\n```\n```\n```python\nn = int(input())\npath = input()\n\nx, y = 0, 0\nparent = {(x, y): (x, y)}\nrank = {(x, y): 0}\n\ndef find(p):\n    if parent[p] != p:\n        parent[p] = find(parent[p])\n    return parent[p]\n\ndef union(uc, vc):\n    uc = find(uc)\n    vc = find(vc)\n    if uc == vc:\n        return\n    if rank[uc] < rank[vc]:\n        parent[uc] = vc\n    elif rank[uc] > rank[vc]:\n        parent[vc] = uc\n    else:\n        parent[vc] = uc\n        rank[uc] += 1\n\nfor step in path:\n    dx, dy = 0, 0\n    if step == 'N':\n        dy = -1\n    elif step == 'S':\n        dy = 1\n    elif step == 'E':\n        dx = 1\n    elif step == 'W':\n        dx = -1\n    x += dx\n    y += dy\n    p = (x, y)\n    if p in parent:\n        union(p, (x, y))\n    else:\n        parent[p] = p\n\nprint(len([p for p in parent if find(p) != p]) - 1)\n```", "time_gen": "\ntime generating: 16.226462s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=597": {"code": "```\nimport heapq\ndef angry_cows():\n    N = int(input())\n    positions = [int(x) for x in input().split()]\n    positions.sort()\n    heap = []\n    for i, pos in enumerate(positions):\n        if i == 0:\n            heapq.heappush(heap, (pos, 1))\n        else:\n            heapq.heappush(heap, (pos - positions[i-1], 1))\n    \n    ans = 0\n    while heap:\n        r, dist = heapq.heappop(heap)\n        ans = max(ans, dist)\n        for i in range(len(heap)):\n            if heap[i][0] >= r and heap[i][0] <= r + ans - 1:\n                heap.pop(i)\n                break\n    print(f\"{ans:.1f}\")\n```", "time_gen": "\ntime generating: 10.8016s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=598": {"code": "```\npython\ndef read_input():\n    with open('radio.in', 'r') as f:\n        N, M = map(int, f.readline().split())\n        fx, fy = map(int, f.readline().split())\n        bx, by = map(int, f.readline().split())\n        path_fj = f.readline().strip()\n        path_bessie = f.readline().strip()\n\n    return N, M, fx, fy, bx, by, path_fj, path_bessie\n\ndef calculate_energy(x1, y1, x2, y2):\n    return (abs(x2-x1) + abs(y2-y1)) ** 2\n\nN, M, fx, fy, bx, by, path_fj, path_bessie = read_input()\n\nmin_energy = float('inf')\n\nfor _ in range(N+1):\n    for move_fj in ['N', 'E', 'S', 'W']:\n        if move_fj == 'N':\n            new_fx, new_fy = fx, fy + 1\n        elif move_fj == 'E':\n            new_fx, new_fy = fx + 1, fy\n        elif move_fj == 'S':\n            new_fx, new_fy = fx, fy - 1\n        else:\n            new_fx, new_fy = fx - 1, fy\n\n        for _ in range(M+1):\n            for move_bessie in ['N', 'E', 'S', 'W']:\n                if move_bessie == 'N':\n                    new_bx, new_by = bx, by + 1\n                elif move_bessie == 'E':\n                    new_bx, new_by = bx + 1, by\n                elif move_bessie == 'S':\n                    new_bx, new_by = bx, by - 1\n                else:\n                    new_bx, new_by = bx - 1, by\n\n                energy = calculate_energy(new_fx, new_fy, new_bx, new_by)\n                if _ == M and move_bessie == path_bessie[-1]:\n                    min_energy = min(min_energy, energy)\n                    break\n            else:\n                continue\n            break\n        else:\n            continue\n        break\n\nprint(min_energy)\n```", "time_gen": "\ntime generating: 25.733863s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=599": {"code": "```\ndef read_barn(filename):\n    barn = []\n    with open(filename, 'r') as f:\n        N = int(f.readline())\n        for _ in range(N):\n            x, y = map(int, f.readline().split())\n            barn.append((x, y))\n    return barn\n\n\ndef calculate_distance(barn, start_idx):\n    angles = [0] * (len(barn) + 1)\n    edges = []\n    prev_angle = None\n    for i in range(len(barn)):\n        x1, y1 = barn[i]\n        x2, y2 = barn[(i + 1) % len(barn)]\n        if abs(x1 - x2) == 10:\n            angles[i] = (y2 - y1) * 1.0\n        else:\n            angles[i] = (x2 - x1) * 1.0\n    for i in range(len(barn)):\n        edges.append(((barn[i][0], barn[i][1]), (barn[(i + 1) % len(barn)][0], barn[(i + 1) % len(barn)][1])))\n\n    distance = 0\n    idx = start_idx - 1\n    while True:\n        if angles[idx] == 90:\n            break\n        direction = 1 if prev_angle is None or angles[idx] > prev_angle else -1\n        distance += edges[idx][1][0] - edges[idx][0][0]\n        idx = (idx + direction) % len(barn)\n    return distance\n\n\ndef solve(filename):\n    barn = read_barn(filename)\n    max_distance = 0\n    for i in range(1, len(barn)):\n        start_idx = i\n        lit_distance = calculate_distance(barn, start_idx)\n        dark_distance = calculate_distance(barn, start_idx) + len(barn)\n        max_distance = max(max_distance, abs(lit_distance - dark_distance))\n    return str(max_distance)\n\n\nprint(solve(\"lightsout.in\"))\n```", "time_gen": "\ntime generating: 26.291113s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=600": {"code": "```\npython\nN, M = map(int, open('fortmoo.in', 'r').readline().split())\nmax_area = 0\nfor i in range(N):\n    line = list(open('fortmoo.in', 'r').readline().strip())\n    for j in range(M):\n        if line[j] == 'X':\n            break\n    else:\n        max_width = M - j\n        max_height = N - i\n        max_area = max(max_area, max_width * max_height)\nprint(max_area)\n```", "time_gen": "\ntime generating: 7.261396s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=601": {"code": "```\nimport bisect\n\nx = []\ny = []\n\nfor _ in range(int(input())):\n    xi, yi = map(int, input().split())\n    if not x:\n        x.append(xi)\n        y.append(yi)\n    elif (x[-1] == xi):\n        y.append(yi)\n    else:\n        left = bisect.bisect_left(x, xi) - 1\n        x.insert(left + 1, xi)\n        y.insert(left + 1, yi)\n\ncrossings = 0\n\nfor i in range(1, len(x)):\n    if abs(x[i] - x[i-1]) > 1:\n        for j in range(i+1):\n            if abs(y[j] - y[i-1]) > 1 and (x[j] == x[i-1]):\n                crossings += 1\n\nprint(crossings)\n```", "time_gen": "\ntime generating: 11.261243s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=602": {"code": "```\ndef lights_out_distance(input_file):\n    with open(input_file, 'r') as f:\n        N = int(f.readline())\n        vertices = []\n        for _ in range(N):\n            x, y = map(int, f.readline().split())\n            vertices.append((x, y))\n\n    max_diff = 0\n    for i in range(1, N+1):\n        x, y = vertices[i-1]\n        start_vertex = (x, y)\n\n        clockwise_distance = counterclockwise_distance = 0\n        for j in range(i):\n            x, y = vertices[j%N]\n            if x == start_vertex[0]:\n                distance = abs(y - start_vertex[1])\n            else:\n                distance = abs(x - start_vertex[0])\n\n            if j % 2 == i % 2:\n                clockwise_distance += distance\n            else:\n                counterclockwise_distance += distance\n\n        max_diff = max(max_diff, abs(clockwise_distance - counterclockwise_distance))\n\n    return str(max_diff)\n\nprint(lights_out_distance('lightsout.in'))\n```", "time_gen": "\ntime generating: 14.199971s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=615": {"code": "```\nx, y, m = map(int, open('pails.in', 'r').read().split())\nmax_milk = min(m, x * (m // x) + min((m % x), y))\n\nprint(max_milk)\n```", "time_gen": "\ntime generating: 4.262947s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=616": {"code": "```\n```\n\n```\nn = int(input())\nrooms = list(map(int, input().split()))\ntotal_distance = 0\nfor i in range(n):\n    if rooms[i] > (i + 1) // 2:\n        total_distance += i * 2 - (i % 2)\n    else:\n        total_distance += n - i - 1\n\nprint(total_distance)\n```", "time_gen": "\ntime generating: 5.418242s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=617": {"code": "```\n**Code**\n```\nB, N = map(int, open('balancing.in', 'r').readline().split())\npoints = [map(int, line.split()) for line in open('balancing.in', 'r').readlines()[1:]]\n\ndef get_m(points):\n    x_coords = [point[0] for point in points]\n    y_coords = [point[1] for point in points]\n\n    max_x = max(x_coords)\n    min_x = min(x_coords)\n\n    max_y = max(y_coords)\n    min_y = min(y_coords)\n\n    x_partition = (max_x + min_x) // 2\n    y_partition = (max_y + min_y) // 2\n\n    a, b = x_partition, y_partition\n\n    x_partitions = [i for i in range(min_x, max_x+1) if i % 2 == a % 2]\n    y_partitions = [i for i in range(min_y, max_y+1) if i % 2 == b % 2]\n\n    count = 0\n    regions = [[], [], [], []]\n\n    for point in points:\n        x, y = point\n        if x < x_partition and y < y_partition:\n            regions[0].append(point)\n        elif x >= x_partition and y < y_partition:\n            regions[1].append(point)\n        elif x < x_partition and y >= y_partition:\n            regions[2].append(point)\n        else:\n            regions[3].append(point)\n\n    for region in regions:\n        count = max(count, len(region))\n\n    return count\n\nprint(get_m(points))\n```\n**Output**\n```\n2\n```", "time_gen": "\ntime generating: 17.667963s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=618": {"code": "```\nfrom math import sqrt\n\nn = int(input())\ncows = list(map(int, input().split() for _ in range(n)))\n\nmin_energy = 0\nfor i in range(1, n):\n    if cows[i] > cows[i-1]:\n        min_energy += (cows[i]-cows[i-1])**2\n    elif cows[i] < cows[i-1]:\n        min_energy += ((n-cows[i])-(n-cows[i-1]))**2\n\nprint(min_energy)\n```", "time_gen": "\ntime generating: 6.499401s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=619": {"code": "```\nimport math\n\ndef min_max_cows(x_coords, y_coords):\n    max_x = max(x_coords)\n    min_x = min(x_coords)\n\n    max_y = max(y_coords)\n    min_y = min(y_coords)\n\n    m1 = len([x for x in x_coords if min_x <= x <= (min_x + max_x) // 2])\n    m2 = len([y for y in y_coords if min_y <= y <= (min_y + max_y) // 2])\n\n    return min(m1, m2)\n\nn = int(input())\nx_coords = [int(x) for x in input().split()]\ny_coords = [int(y) for y in input().split()]\n\nprint(min_max_cows(x_coords, y_coords))\n```", "time_gen": "\ntime generating: 17.393288s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=620": {"code": "```\ndef get_min_error():\n    X, Y, K, M = map(int, input().split())\n    min_error = float('inf')\n\n    for i in range(K+1):\n        for j in range(K+1):\n            total_milk = min(i*X+j*Y, X) + min((K-i)*X+(K-j)*Y-Y, Y)\n            error = abs(M - total_milk)\n            if error < min_error:\n                min_error = error\n\n    return min_error\n\n\nprint(get_min_error())\n```", "time_gen": "\ntime generating: 22.39488s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=621": {"code": "```\n```\n\n```python\nn = int(input())\nenergy = 0\nfor i in range(n):\n    energy += (i + 1) * min(c[i-1], c[(i+1)%n]) + max(0, c[i] - 1)\nprint(energy)\n```", "time_gen": "\ntime generating: 14.111834s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=622": {"code": "```\nn, k = map(int, open('cbarn2.in', 'r').read().split()[0].split())\nroom_cows = [int(x) for x in open('cbarn2.in', 'r').read().split()[1:]]\n\ndef min_distance(n, k, room_cows):\n    total_distance = 0\n    for i in range(k+1):\n        current_room_index = (i+k)%n\n        for j in range(i, n):\n            if j > current_room_index:\n                j = (j-1)%n\n            total_distance += abs(room_cows[j] - room_cows[current_room_index])\n    return total_distance\n\nprint(min_distance(n, k, room_cows))\n```", "time_gen": "\ntime generating: 31.371037s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=623": {"code": "```\ndef min_fence_length():\n    A, B, n, m = map(int, input().split())\n    a = list(map(int, [input() for _ in range(n)]))\n    b = list(map(int, [input() for _ in range(m)]))\n\n    dp = [[0] * (B + 1) for _ in range(A + 1)]\n    \n    for i in range(A + 1):\n        dp[i][0] = i\n    for j in range(B + 1):\n        dp[0][j] = j\n\n    for i in range(1, A + 1):\n        for j in range(1, B + 1):\n            if (i == a[k - 1] or i > a[k - 1]) and (j == b[l - 1] or j > b[l - 1]):\n                dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1)\n            elif i < A and j < B:\n                dp[i][j] = min(dp[i+1][j] + 1, dp[i][j+1] + 1, dp[i-1][j-1] + 2)\n\n    print(dp[A][B])\n```", "time_gen": "\ntime generating: 49.390864s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=624": {"code": "Here is the Python code for the problem:\n```\nx_coords = []\ny_coords = []\n\nwith open('balancing.in', 'r') as f:\n    N = int(f.readline())\n    for _ in range(N):\n        x, y = map(int, f.readline().split())\n        if x % 2 == 1: x = x + 1\n        if y % 2 == 1: y = y + 1\n        x_coords.append(x)\n        y_coords.append(y)\n\nx_coords.sort()\ny_coords.sort()\n\na = x_coords[0]\nb = y_coords[0]\n\nprint(min(len(set([i for i in range(max(x_coords)) if i <= a])) +\n          len(set([i for i in range(max(y_coords)) if i <= b])),\n          4))\n```", "time_gen": "\ntime generating: 29.555545s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=625": {"code": "```\n```\n\n```python\nA, B, n, m = [int(x) for x in input().split()]\na = [int(input()) for _ in range(n)]\nb = [int(input()) for _ in range(m)]\n\ntotal_len = 0\n\nfor i in range(1, n):\n    total_len += A - (a[i] - a[i-1])\n\nfor i in range(1, m):\n    total_len += B - (b[i] - b[i-1])\n```", "time_gen": "\ntime generating: 23.204716s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=626": {"code": "```\nimport heapq\n\nn, k = map(int, input().split())\ndistances = [0] * n\nfor i in range(n):\n    distances[i] = (abs(i - 1) + abs(i - n)) // 2\n\nheap = [(0, i) for i in range(1, n)]\nwhile heap:\n    d, i = heapq.heappop(heap)\n    if i > 1 and distances[i-1] < d:\n        new_dist = (distances[i-1] + abs(i - 1)) // 2\n        if new_dist < d:\n            for j in range(k):\n                if distances[j] >= new_dist:\n                    distances[j] = new_dist\n                    heapq.heappush(heap, (new_dist, j))\n                    break\n\nprint(sum(distances))\n```", "time_gen": "\ntime generating: 40.417733s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=639": {"code": "```\nsorted_sizes = sorted([int(x) for x in open('diamond.in').readlines()][1:])\nn, k = int(open('diamond.in').readline().split()[0]), int(open('diamond.in').readline().split()[1])\ntotal = 0\nfor i in range(len(sorted_sizes)):\n    if i == 0:\n        total += 1\n    elif sorted_sizes[i] - sorted_sizes[i-1] > k:\n        total += 1\nprint(total)\n```", "time_gen": "\ntime generating: 21.401773s"}, "https://usaco.org/index.php?page=viewproblem2&cpid=640": {"code": "```\nN, K = map(int, input().split())\nfig = [list(input()) for _ in range(N)]\npieces = [[list(input()) for _ in range(N)] for _ in range(K)]\n\ndef get_indices(fig, pieces):\n    ans = []\n    for i in range(K):\n        if fig == shift(pieces[i]):\n            return str(i+1)\n        for j in range(K):\n            if i != j:\n                if fig == shift(shift(pieces[i], 0, 0) + pieces[j]):\n                    return str(i+1) + ' ' + str(j+1)\n    return ''\n\ndef shift(piece, x=0, y=0):\n    n = len(piece)\n    res = [['.' for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if piece[i][j] == '#':\n                res[(i+x)%n][(j+y)%n] = '#'\n    return [''.join(row) for row in res]\n\ndef find_match(fig, pieces):\n    for i in range(K):\n        if fig == shift(pieces[i]):\n            return str(i+1)\n        for j in range(K):\n            if i != j:\n                if fig == shift(shift(pieces[i], 0, 0) + pieces[j]):\n                    return str(i+1) + ' ' + str(j+1)\n\nprint(find_match(fig[0], [shift(piece, x=0, y=0) for piece in pieces]))", "time_gen": "\ntime generating: 83.290308s"}}